<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="分享钢哥人生路上的点点滴滴">
<meta name="keywords" content="个人成长 全栈 区块链">
<meta property="og:type" content="website">
<meta property="og:title" content="Keegan小钢">
<meta property="og:url" content="https://keeganlee.me/page/2/index.html">
<meta property="og:site_name" content="Keegan小钢">
<meta property="og:description" content="分享钢哥人生路上的点点滴滴">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Keegan小钢">
<meta name="twitter:description" content="分享钢哥人生路上的点点滴滴">





  
  
  <link rel="canonical" href="https://keeganlee.me/page/2/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Keegan小钢</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Keegan小钢</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">钢哥的个人博客</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/blockchain/20180425/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/blockchain/20180425/" class="post-title-link" itemprop="url">漫谈区块链共识机制</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-04-25 16:00:00" itemprop="dateCreated datePublished" datetime="2018-04-25T16:00:00+08:00">2018-04-25</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-02 11:18:29" itemprop="dateModified" datetime="2019-07-02T11:18:29+08:00">2019-07-02</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/blockchain/" itemprop="url" rel="index"><span itemprop="name">blockchain</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/blockchain/20180425"><strong>http://keeganlee.me/post/blockchain/20180425</strong></a><br>微信订阅号：<strong>keeganlee_me</strong><br>写于2018-04-25</p>
<hr>
<p>专栏地址：<a href="https://xiaozhuanlan.com/fullstack" target="_blank" rel="noopener">https://xiaozhuanlan.com/fullstack</a></p>
<hr>
<p>共识机制是区块链的一个核心特征，是保证区块链系统在分布式架构下的一致性方案。目前主流的也有好多种共识算法：POW、POS、DPOS、RCP、PBFT、DBFT 等等。网上已经充斥了很多对这些共识算法的简单介绍，但基本流于表面而缺少深入的讲解，从而读者们也很难理解到这些共识机制背后的核心原理。而本文将以深入浅出的方式讲解区块链共识机制，但由于篇幅有限，因此，只会讲解最重要的两种区块链的共识机制，即比特币和以太坊的共识机制。</p>
<h2 id="比特币共识机制"><a href="#比特币共识机制" class="headerlink" title="比特币共识机制"></a>比特币共识机制</h2><p>比特币是区块链的第一个应用，也是第一个实现了共识机制的，因此，要理解区块链共识机制，自然也要先从比特币共识机制开始。另外，虽然很多文章都提到比特币的共识机制为 <strong>POW（Proof of Work，工作量证明）</strong>，但实际上，POW 只是整个比特币共识机制中的一部分，虽然是核心的那部分，但却不是全部。其实，比特币的分布式共识是由网络节点的 4 种独立过程相互作用而达成的：</p>
<ul>
<li><strong>每个全节点基于一份长长的判断标准清单对每个交易进行独立验证</strong></li>
<li><strong>每个挖矿节点独立将多个交易打包进新区块，通过完成 POW 算法的验算</strong></li>
<li><strong>每个节点独立验证新区块并组装进区块链</strong></li>
<li><strong>每个节点独立选择最长链，即在 POW 机制下累计工作量最多的那条链</strong></li>
</ul>
<p>先说第一种过程，对交易的独立验证。每个节点收到每一个交易之后，都会先根据一份很长的判断标准清单对该交易进行有效性校验，包括但不限于校验交易的语法和数据结构是否正确、输入和输出是否为空、输入总额是否小于输出总额、每一个输入所引用的输出是否已经被消费，等等。如果该交易通过所有验证，则可以说明该交易是有效的，那么，该节点就会将该交易放入本地的<strong>交易池</strong>（或称<strong>内存池</strong>），并将该交易广播给其他相临的节点。如果没通过验证，则会废弃该交易，也不会将其广播出去。其他节点接收到该交易后，也各自做同样的独立校验，校验为交易有效之后，同样也放入各节点自己的<strong>交易池</strong>，并继续广播给其他节点。所以，理论上来说，无效的交易一开始就会被废弃，而有效的交易最终会到达整个网络所有节点，并被每个全节点所保存，即全网达成了“该交易有效”的共识。</p>
<p>接着，再来聊聊第二种过程，了解有效的交易是如何被打包进区块的。经过一段时间后，一般是 10 分钟左右，每个节点的交易池里会收集到很多有效但还未确认的交易，这些交易会组装成一颗 <strong>Merkle Tree</strong>。关于 <strong>Merkle Tree</strong> 的结构，我们在之前的文章<a href="https://xiaozhuanlan.com/topic/2394807516" target="_blank" rel="noopener">《014|从微观到宏观理解区块链》</a>已经讲过，这里就不赘述了。不过，组装进 <strong>Merkle Tree</strong> 的第一笔交易是比较特殊的，这是一笔<strong>创币交易</strong>，也叫 <strong>Coinbase 交易</strong>，新的比特币就是从该笔交易产生的。这笔交易是由节点自己创建的，并将挖矿奖励支付到矿工自己的地址，挖矿奖励包括新创建的比特币和打包进该区块所有交易的手续费总额。组装好 <strong>Merkle Tree</strong> 之后，就得到 <strong>Merkle Root</strong>，再结合区块头的其他 5 个字段——<strong>Version、Pre Block、Times、Difficulty、Nonce</strong>，总共 6 个字段合在一起经过<strong>两次 SHA256 计算</strong>得到区块哈希值。一个有效的区块要求其哈希值必须小于 Difficulty 难度值，写作本文时的难度要求哈希值至少已经有 18 个 0 开头。挖矿其实就是通过修改参数的值而不断计算区块哈希值，直到计算出符合难度要求的哈希值。一般是通过修改 Nonce 值来计算区块哈希值，其他 5 个字段基本是不变的。而由于哈希函数的特性，难度值越大，理论上计算出符合要求的哈希值所需的计算量就越大。举个简单例子，比如你扔三个骰子，如果难度要求总和小于18，那是非常容易达到的，基本扔个一两次就能满足要求了；而如果加大难度，要求总和小于9，那从概率上来说相对就没那么容易了，可能要扔个十几次甚至几十次才能达到；而如果要求总和等于 3，那只能扔出三个 1 才行，这谁都知道要达到的概率是很低的，也许扔个一两百次才可能出现。因此，从统计学来说，一定的难度值可以推算出概率上对应所需的计算次数，也就是“工作量”，所以，只要你达到了难度要求，也就间接证明你付出了对应的工作量，这就是<strong>工作量证明</strong>。</p>
<p>当某个节点计算出符合难度要求的区块哈希时，即说明该矿工挖矿成功了，该节点就会将此区块组装到本地的区块链，同时也将此区块广播给其他节点。然后，就进入第三种过程了。当其他节点收到此区块时，也会各自独立验证该区块是否有效。和独立验证交易一样，也存在一份验证标准清单，包括但不限于校验引用的上一个区块是否是否正确、难度值是否符合标准、区块哈希是否真的符合难度要求、Coinbase 交易中的挖矿奖励是否多于应得的、整个区块的每笔交易是否都是有效的，等等。其中，难度值是有标准的计算公式的，每个节点都会根据标准公式独立计算实际的难度值，所以，矿工如果不按照标准而自己设置一个较低的难度，在其他节点是无法通过的。同样，挖矿奖励也是有标准公式的，所以，如果矿工给自己奖励过多的比特币，在其他节点也是同样无法通过的。每个节点验证该区块为有效之后，也会各自将该区块组装进它们本地的区块链，并继续将该区块广播给其他节点。</p>
<p>由于所有节点同时在挖同一个区块，就有可能会出现多个节点同时挖出了同个区块，并都将各自挖到的区块广播到其他节点。假设有两个节点同时挖出了新区块，分别为区块 N1 和 N2，它们的上一个区块都是 P。有些节点会先收到 N1，它们会将 N1 先组装进它们本地的区块链，也称为主链。但之后不久，这些节点也会收到 N2，这时候，它们会将 N2 放入备选链。而其他节点则先收到 N2 再收到 N1，则 N2 在它们的主链上，而 N1 在它们的备选链上。这时候，整个区块链暂时就分成了两个分叉，而要打破这种局面，就要看下一个生成的区块是基于 N1 还是 N2 了。如果下一个区块是基于 N1，自然，N1 的这条链就变成了最长链，也是累计工作量最多的链。那么，那些将 N2 链设为主链的节点就会根据实际情况自己选择将 N1 链改为主链，而 N2 将成为<strong>孤块</strong>而被废弃。</p>
<p>以上就是比特币共识机制的核心内容了，说白了其实就是根据一些所有节点都认可的标准对每个交易和区块的创建和校验进行独立验证，当大多数节点都认可并写入自己的区块链的时候，就自动形成了分布式共识。所有区块链基本都是这个逻辑，不同区块链主要在于制定的标准不同，比特币主要就是基于 POW 机制，这种机制实现简单，但它会造成大量的能源浪费，由于所有节点同时竞争挖矿同一个区块，而基本只有一个节点能胜出，那其他未胜出的节点所消耗的算力能源就白费了。另外，每次交易确认（即出块时间）大概 10 分钟，一笔交易一般要有 6 次确认才算安全，那基本就要 1 个小时了，这共识达成的时间太长了。</p>
<h2 id="以太坊共识机制"><a href="#以太坊共识机制" class="headerlink" title="以太坊共识机制"></a>以太坊共识机制</h2><p>以太坊的共识机制也是基于 POW 的，但与比特币相比，主要有两点不同：一是挖矿时间控制在 10 ~ 19 秒之间，出块时间比比特币快了很多；二是对于<strong>孤块</strong>也有挖矿奖励。在比特币中，<strong>孤块</strong>（即上文的 N2 区块）是会被丢弃的，挖出了孤块的矿工是得不到任何奖励的。但在以太坊中，孤块是能被打包进区块里的，如果后续的区块将前面产生的孤块也打包进区块里，那这个孤块就变成了<strong>叔块</strong>，那么，挖到这个叔块的矿工就能得到奖励，而将叔块打包进区块的矿工也能得到额外的奖励，但每个区块最多只能包含两个叔块，而且也不能包含太久的孤块，最多只支持到 7 层的祖先孤块。由于以太坊的出块时间短很多，那自然更容易出现临时分叉而产生孤块，而且这么短的时间内，每个区块也很难能够在全网充分传播，那对于网速慢的矿工来说，就非常吃亏了。所以，为了平衡各方利益，以太坊才设计了叔块机制。写作本文时，叔块率在 16.9% 左右。</p>
<p>不过，以太坊正在计划从 POW 机制切换为 <strong>POS（Proof of Stack，权益证明）</strong>机制，其新的共识机制名为 <strong>Casper</strong>，其存在两个不同实现的版本，分别是：</p>
<ul>
<li>Casper the Friendly Finality Gadget（FFG）</li>
<li>Casper the Friendly GHOST: Correct-by-Construction（CBC）</li>
</ul>
<p>Casper FFG 是由 Vitalik 主导的，侧重于通过逐步迭代实现，慢慢过渡到 POS 机制。而 Casper CBC 则是由 Vlad Zamfir 主导的，不同于传统的协议设计方式，即先定义完整的协议，CBC 协议在开始阶段只是部分确定的，其余部分协议以证明能够满足所需/必需属性的方式得到。不过，也只是两种不同的方法，关于 POS 的核心理念还是一致的。相对来说，FFG 比较容易理解，也很大可能是即将第一个部署到以太坊的 Casper 版本，所以下面的篇幅主要讲解 FFG。</p>
<p>FFG 版本的 Casper 是一种混合 POW / POS 的共识机制，该机制下的每次出块依然还是采用 POW 挖矿机制，但每 100 个区块会增加一个 POS <strong>检查点（checkpoint）</strong>，通过<strong>验证人（validator）</strong>来评估区块的最终有效性。创世区块是一个检查点，区块高度为 100 的倍数的区块也是检查点，将这些检查点连起来就组成了一条<strong>检查点链（checkpoint chain）</strong>。检查点一般会有两种状态：<strong>justified</strong> 和 <strong>finalized</strong>，<strong>finalized</strong> 则表示已经确定为最终有效的，该状态的检查点至少已经存在一个子检查点，<strong>justified</strong> 则表示该检查点是已经被证明合理的，<strong>finalized</strong> 的检查点一定是 <strong>justified</strong> 的，但反过来则不一定。而一个检查点是否有效，是通过多个验证人投票得出的结果。下面，我们就来简单聊聊这个过程。</p>
<p>首先，要成为验证人，是需要投入<strong>保证金</strong>的，即抵押一定量的以太币作为权益证明，才有资格成为验证人。投入保证金是通过广播一条 <strong>deposit</strong> 消息进行操作的，只要这条消息是有效的并被打包进区块中，那就能加入<strong>验证人集合（validator set）</strong>，成为其中一个验证人。另外，如果要退出<strong>验证人集合</strong>，则可以再广播一条 <strong>withdraw</strong> 消息。不过，需要注意，一旦退出后，该验证人的公钥将被永久禁止再次加入验证人集合。</p>
<p>接着，成为验证人之后，就可以开始投票选举检查点了，通过广播一条 <strong>vote</strong> 消息到网络中。vote 消息主要包含五个信息：两个检查点 <strong>s</strong> 和 <strong>t</strong>，以及这两个检查点的高度 <strong>h(s)</strong> 和 <strong>h(t)</strong>，以及验证人的公钥 <strong>ν</strong>。要求 s 必须是 t 的祖先，一般来说，t 就是最新的检查点，而 s 是上一个已经确定为最终有效的检查点。另外，还要求验证人的公钥 v 必须在验证人集合中找得到，否则都认为该投票是无效的。当超过 2/3 的验证人（实际上是 2/3 的总保证金）都投给了 (s, t) 这对检查点时，那 s 就是 <strong>finalized</strong> 的，t 则是 <strong>justified</strong> 的。而且，那些投注了 (s, t) 的验证人还会得到货币奖励，得到的奖励是和抵押的保证金成比例的，就是说抵押的保证金越多，得到的奖励越多。这个奖励也可以理解为抵押保证金的利息。</p>
<p>另外，Casper 设置了两条戒律：</p>
<ol>
<li>验证人不能发布两个 h(t) 相同的投票，即如果存在两个投票：&lt;ν, s1, t1, h(s1), h(t1)&gt; 和 &lt;ν,s2,t2,h(s2),h(t2)&gt;，那么 h(t1) = h(t2) 是不允许的；</li>
<li>如果 h(s1) &lt; h(s2) &lt; h(t2) &lt; h(t1)，则第一个投票的跨度已经涵盖了第二个投票，这也是不允许的。</li>
</ol>
<p>如果验证人违反了上面的戒律，则会对验证人进行惩罚，没收他抵押的保证金。</p>
<p>最后，Casper 对分叉链的选择不同于 POW 机制下选择累计工作量最多的那条链，Casper 对分叉链选择的规则就是选择 justified 检查点高度最大的链，原文是：</p>
<ul>
<li><strong>FOLLOW THE CHAIN CONTAINING THE JUSTIFIED CHECKPOINT OF THE GREATEST HEIGHT.</strong></li>
</ul>
<p>很明显，以太坊的共识机制和比特币相比复杂得多，主要在于两点引起的：一是大大缩短了出块时间，二是引入了 POS 机制。在 POW 机制下将出块时间缩短到十几秒，虽然加快了性能，但其实减低了安全性，因为会引入很多其他问题，比如新区块难以在这么短的时间内扩散到全网，比如分叉链出现的概率更大，为了解决这些问题，就需要设计更多共识协议来提高安全性。引入 POS 机制变成 POW + POS 的混合机制，那这种复杂度不是 1 + 1 = 2 这么简单的。</p>
<h2 id="思考和实践"><a href="#思考和实践" class="headerlink" title="思考和实践"></a>思考和实践</h2><p>EOS 的共识机制是怎样的？其安全性和性能又如何呢？</p>
<hr>
<p>扫描以下二维码即可关注订阅号。</p>
<img src="/post/blockchain/20180425/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/blockchain/20180313/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/blockchain/20180313/" class="post-title-link" itemprop="url">详解区块链P2P网络</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-03-13 16:48:12" itemprop="dateCreated datePublished" datetime="2018-03-13T16:48:12+08:00">2018-03-13</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-02 11:18:30" itemprop="dateModified" datetime="2019-07-02T11:18:30+08:00">2019-07-02</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/blockchain/" itemprop="url" rel="index"><span itemprop="name">blockchain</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/blockchain/20180313"><strong>http://keeganlee.me/post/blockchain/20180313</strong></a><br>微信订阅号：<strong>keeganlee_me</strong><br>写于2018-03-13</p>
<hr>
<p>专栏地址：<a href="https://xiaozhuanlan.com/fullstack" target="_blank" rel="noopener">https://xiaozhuanlan.com/fullstack</a></p>
<hr>
<p>根据前一篇文章《<a href="http://keeganlee.me/post/blockchain/20180224">从微观到宏观理解区块链</a>》我们已经了解到，微观上，区块链本质就是一种<strong>不可篡改且可追踪溯源的哈希链条</strong>；宏观上，还具备了另外三个基本特征：<strong>分布式存储、P2P 网络和共识机制</strong>。分布式存储无非就是网络上大部分节点都保存了整条区块链，这容易理解也不复杂，所以就没必要再展开细讲了。但区块链的 P2P 网络和共识机制相对则复杂得多，因此我将用两篇文章分别展开讲讲这两部分内容，本篇文章就先来了解区块链的 P2P 网络。</p>
<h2 id="P2P-网络"><a href="#P2P-网络" class="headerlink" title="P2P 网络"></a>P2P 网络</h2><p>由于大部分人对 P2P 网络了解甚少，因此有必要先聊聊 P2P 网络的一些基本原理。这个章节的内容主要来自<strong>《P2P对等网络原理与应用》</strong>这本书，这本书较为系统地介绍了 P2P 的理论基础，非常适合希望全面掌握 P2P 知识的初级读者，建议大伙都可以看看。</p>
<p>P2P 网络不同于传统的<strong>客户端/服务端(client/server,C/S)结构</strong>，P2P 网络中的每个节点都可以既是客户端也是服务端，因此也不适合使用 HTTP 协议进行节点之间的通信，一般都是直接使用 Socket 进行网络编程。</p>
<p>P2P 主要存在四种不同的网络模型，也代表着 P2P 技术的四个发展阶段：<strong>集中式、纯分布式、混合式和结构化模型</strong>。不过需要指出的是，这里所说的网络模型主要是指路由查询结构，即不同节点之间如何建立连接通道，两个节点之间一旦建立连接，具体传输什么数据则是两个节点之间的事情了。</p>
<p>最简单的路由方式就是<strong>集中式</strong>，即存在一个中心节点保存了其他所有节点的索引信息，索引信息一般包括节点 IP 地址、端口、节点资源等。集中式路由的优点就是结构简单、实现容易。但缺点也很明显，由于中心节点需要存储所有节点的路由信息，当节点规模扩展时，就很容易出现性能瓶颈；而且也存在单点故障问题。</p>
<img src="/post/blockchain/20180313/2018-03-06-22-25-08.jpg">

<p>那第二种路由结构则是<strong>纯分布式</strong>的，移除了中心节点，在 P2P 节点之间建立随机网络，就是在一个新加入节点和 P2P 网络中的某个节点间随机建立连接通道，从而形成一个随机拓扑结构。新节点加入该网络的实现方法也有很多种，最简单的就是随机选择一个已经存在的节点并建立邻居关系。像比特币的话，则是使用 DNS 的方式来查询其他节点，DNS 一般是硬编码到代码里的，这些 DNS 服务器就会提供比特币节点的 IP 地址列表，从而新节点就可以找到其他节点建立连接通道。新节点与邻居节点建立连接后，还需要进行全网广播，让整个网络知道该节点的存在。全网广播的方式就是，该节点首先向邻居节点广播，邻居节点收到广播消息后，再继续向自己的邻居节点广播，以此类推，从而广播到整个网络。这种广播方法也称为<strong>泛洪机制</strong>。纯分布式结构不存在集中式结构的单点性能瓶颈问题和单点故障问题，具有较好的可扩展性，但泛洪机制引入了新的问题，主要是可控性差的问题，包括两个较大的问题，一是容易形成泛洪循环，比如节点 A 发出的消息经过节点 B 到 节点 C，节点 C 再广播到节点 A，这就形成了一个循环；另一个棘手问题则是响应消息风暴问题，如果节点 A 想请求的资源被很多节点所拥有，那么在很短时间内，会出现大量节点同时向节点 A 发送响应消息，这就可能会让节点 A 瞬间瘫痪。</p>
<img src="/post/blockchain/20180313/2018-03-07-10-54-06.jpg">

<p>再来看看第三种路由结构：<strong>混合式</strong>。混合式其实就是混合了集中式和分布式结构，如下图所示，网络中存在多个<strong>超级节点</strong>组成分布式网络，而每个超级节点则有多个<strong>普通节点</strong>与它组成局部的集中式网络。一个新的普通节点加入，则先选择一个超级节点进行通信，该超级节点再推送其他超级节点列表给新加入节点，加入节点再根据列表中的超级节点状态决定选择哪个具体的超级节点作为父节点。这种结构的泛洪广播就只是发生在超级节点之间，就可以避免大规模泛洪存在的问题。在实际应用中，混合式结构是相对灵活并且比较有效的组网架构，实现难度也相对较小，因此目前较多系统基于混合式结构进行开发实现。其实，比特币网络如今也是这种结构，后面再细说。</p>
<img src="/post/blockchain/20180313/2018-03-06-22-27-23.jpg">

<p>最后一种网络则是<strong>结构化 P2P 网络</strong>，它也是一种分布式网络结构，但与纯分布式结构不同。纯分布式网络就是一个随机网络，而结构化网络则将所有节点按照某种结构进行有序组织，比如形成一个环状网络或树状网络。而结构化网络的具体实现上，普遍都是基于 <strong>DHT(Distributed Hash Table，分布式哈希表) *<em>算法思想。DHT 只是提出一种网络模型，并不涉及具体实现，主要想解决如何在分布式环境下快速而又准确地路由、定位数据的问题。具体的实现方案有 Chord、Pastry、CAN、Kademlia 等算法，其中 *</em>Kademlia</strong> 也是以太坊网络的实现算法，很多常用的 P2P 应用如 BitTorrent、电驴等也是使用 Kademlia。因为篇幅有限，就不展开讲这些算法的具体原理了。目前，我们主要理解 DHT 的核心思想即可。</p>
<p>在 P2P 网络中，可以抽象出两种空间：<strong>资源空间</strong>和<strong>节点空间</strong>。资源空间就是所有节点保存的资源集合，节点空间就是所有节点的集合。对所有资源和节点分别进行编号，如把资源名称或内容用 Hash 函数变成一个数值（这也是 DHT 常用的一种方法），这样，每个资源就有对应的一个 ID，每个节点也有一个 ID，资源 ID 和节点 ID 之间建立起一种映射关系，比如，将资源 n 的所有索引信息存放到节点 n 上，那要搜索资源 n 时，只要找到节点 n 即可，从而就可以避免泛洪广播，能更快速而又准确地路由和定位数据。当然，在实际应用中，资源 ID 和节点 ID 之间是无法做到一一对应的，但因为 ID 都是数字，就存在大小关系或偏序关系等，基于这些关系就能建立两者的映射关系。这就是 DHT 的核心思想。DHT 算法在资源编号和节点编号上就是使用了分布式哈希表，使得资源空间和节点空间的编号有唯一性、均匀分布式等较好的性质，能够适合结构化分布式网络的要求。</p>
<p>综上，这就是 P2P 网络的一点理论基础，不同的区块链可能会使用不一样的网络模型，但基本原理是一样的。后面分别讲解下最有代表性的两个区块链的网络：比特币网络和以太坊网络。</p>
<h2 id="比特币网络"><a href="#比特币网络" class="headerlink" title="比特币网络"></a>比特币网络</h2><p>首先，比特币网络中的节点主要有四大功能：<strong>钱包、挖矿、区块链数据库、网络路由</strong>。每个节点都会具备路由功能，但其他功能不一定都具备，不同类型的节点可能只包含部分功能，一般只有<strong>比特币核心(bitcoin core)</strong>节点才会包含所有四大功能。</p>
<img src="/post/blockchain/20180313/2018-03-09-16-35-26.jpg">

<p>所有节点都会参与校验和广播交易及区块信息，且会发现和维持与其他节点的连接。有些节点会包含完整的区块链数据库，包括所有交易数据，这种节点也称为<strong>全节点(Full Node)</strong>。另外一些节点只存储了区块链数据库的一部分，一般只存储区块头而不存储交易数据，它们会通过“<strong>简化交易验证(SPV)</strong>”的方式完成交易校验，这样的节点也称为 <strong>SPV节点</strong>或<strong>轻节点(Lightweight Node)</strong>。钱包一般是 PC 或手机客户端的功能，用户通过钱包查看自己的账户金额、管理钱包地址和私钥、发起交易等。除了比特币核心钱包是全节点之外，大部分钱包都是<strong>轻节点</strong>。挖矿节点则通过解决<strong>工作量证明(PoW)</strong>算法问题，与其他挖矿节点相互竞争创建新区块。有些挖矿节点同时也是<strong>全节点</strong>，即也存储了完整的区块链数据库，这种节点一般都是<strong>独立矿工(Solo Miner)</strong>。还有一些挖矿节点不是独立挖矿的，而是和其他节点一起连接到<strong>矿池</strong>，参与集体挖矿，这种节点一般也称为<strong>矿池矿工(Pool Miner)</strong>。这会形成一个局部的集中式矿池网络，中心节点是一个<strong>矿池服务器</strong>，其他挖矿节点全部连接到矿池服务器。<strong>矿池矿工</strong>和<strong>矿池服务器</strong>之间的通信也不是采用标准的<strong>比特币协议</strong>，而是使用<strong>矿池挖矿协议</strong>，而矿池服务器作为一个<strong>全节点</strong>再与其他比特币节点使用主网络的<strong>比特币协议</strong>进行通信。</p>
<p>在整个比特币网络中，除了不同节点间使用<strong>比特币协议</strong>作为通信协议的主网络，也存在很多扩展网络，包括上面提到的<strong>矿池网络</strong>。不同的矿池网络可能还会使用不同的矿池挖矿协议，目前主流的具体矿池协议应该是 <strong>Stratum协议</strong>，该协议除了支持挖矿节点，也支持<strong>瘦客户端钱包</strong>。一个包含了比特币协议主网络各种节点和 Stratum 网络，以及其他矿池网络的扩展比特币网络大概如下图所示：</p>
<img src="/post/blockchain/20180313/bitcoin-network.jpeg">

<p>另外，挖矿这块还有特殊需求。我们知道，矿工创建新区块后，是需要广播给全网所有节点的，当全网都接受了该区块，给矿工的挖矿奖励才算是有效的，这之后才好开始下一个区块 Hash 的计算。所以矿工必须最大限度缩短新区块的广播和下一个区块 Hash 计算之间的时间。如果矿工之间传播区块只采用上图所示的比特币协议网络，那无疑会有很高的网络延迟，所以，需要一个专门的传播网络用来加快新区块在矿工之间的同步传播，这个专门网络也叫<strong>比特币传播网络</strong>或<strong>比特币中继网络(Bitcoin Relay Network)</strong>。</p>
<h2 id="以太坊网络"><a href="#以太坊网络" class="headerlink" title="以太坊网络"></a>以太坊网络</h2><p>和比特币一样，以太坊的节点也具备<strong>钱包、挖矿、区块链数据库、网络路由</strong>四大功能，也同样存在很多不同类型的节点，除了主网络之外也同样存在很多扩展网络。但与比特币不同的，比特币主网的 P2P 网络是无结构的，但以太坊的 P2P 网络是有结构的。前面我们已经提过，以太坊的 P2P 网络主要采用了 <strong>Kademlia(简称 Kad)</strong> 算法实现，Kad 是一种<strong>分布式哈希表(DHT)</strong>技术，使用该技术，可以实现在分布式环境下快速而又准确地路由、定位数据的问题。所以，下面主要讲解下以太坊的 Kad 网络。</p>
<p>在 Kad 网络中，每个节点都具有一个唯一的节点 ID。另外，也会计算不同节点之间的距离，但这个距离不是物理上的距离，而是逻辑上的距离，是通过对两个节点 ID 进行 <strong>异或(符号为^)</strong> 计算得到的，即 A、B 两节点之间的距离的计算公式为：<strong>D(A,B) = A.ID^B.ID</strong>。异或有一个重要的性质：假设 a、b、c 为任意三个数，如果 a^b = a^c 成立，那就一定 b = c。因此，如果给定一个结点 a 和距离 L，那就有且仅有一个结点 b, 会使得 D(a,b) = L。通过这种方式，就能有效度量 Kad 网络中不同节点之间的逻辑距离。</p>
<p>在异或距离度量的基础上，Kad 还可以将整个网络拓扑组织成如下图所示的一个<strong>二叉前缀树</strong>，每个 NodeID 会映射到二叉树上的某个叶子。</p>
<img src="/post/blockchain/20180313/2018-03-13-12-31-47.png">

<p>映射规则主要是：</p>
<ol>
<li>将 NodeID 以二进制形式表示，然后从高到低对每一位的 0 或 1 依次处理；</li>
<li>二进制的第 n 位就对应了二叉树的第 n 层；</li>
<li>如果该位是 0，进入左子树，是 1 则进入右子树（反过来也可以）；</li>
<li>全部位都处理完后，这个 NodeID 就对应了二叉树上的某个叶子。</li>
</ol>
<p>在这种二叉树结构下，对每个节点来说，离它越近的节点异或距离也是越近的。接着，可以按照离自己异或距离的远近，对整颗二叉树进行拆分。拆分规则是：从根节点开始，将不包括自己的那颗子树拆分出来，然后在包含自己的子树中，把不包括自己的下一层子树再拆分出来，以此类推，直到只剩下自己。以上图的 110 节点为例，从根节点开始，由于 110 节点在右子树，所以将左边的整颗子树拆分出来，即包含 000、001、010 这三个节点的这颗子树；接着，到第二层子树，将不包含 110 节点的左子树再拆分出来，即包含 100 和 101 这两个节点的子树；最后，再将 111 拆分出来。这样，就将 110 节点之外的整个二叉树拆分出了三颗子树。</p>
<p>完成子树拆分后，只要知道每个子树里面的其中一个节点，就可以进行递归路由实现整颗二叉树所有节点的遍历。但在实际场景下，由于节点是动态变化的，所以一般不会只知道每个子树的一个节点，而是需要知道多个节点。因此，Kad 中有一个叫 <strong>K-桶(K-bucket)</strong>的概念，每个桶会记录每颗子树里所知道的多个节点。其实，一个<strong>K-桶</strong>就是一张<strong>路由表</strong>，如果拆分出来有 m 颗子树，那对应节点就需要维护 m 个路由表。每个节点都会各自维护自己的 m 个 K-桶，每个 K-桶里记录的节点信息一般会包括 NodeID、IP、Endpoint、与 Target 节点（即维护该 K-桶的节点）的异或距离等信息。以太坊中，每个节点维护的 K-桶数量为 256 个，这 256 个 K-桶会根据与 Target 节点的异或距离进行排序，每个 K-桶保存的节点数量上限是 16。</p>
<p>在以太坊的 Kad 网络中，节点之间的通信是基于 UDP 的，另外设置了 4 个主要的通信协议：</p>
<ol>
<li><strong>Ping</strong>：用于探测一个节点是否在线</li>
<li><strong>Pong</strong>：用于响应 Ping 命令</li>
<li><strong>FindNode</strong>：用于查找与 Target 节点异或距离最近的其他节点</li>
<li><strong>Neighbours</strong>：用于响应 FindNode 命令，会返回一或多个节点</li>
</ol>
<p>通过以上 4 个命令，就可以实现新节点的加入、K-桶的刷新等机制。具体的实现流程就不细讲了，留给大伙自己去思考。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不同结构的 P2P 网络，会有不同的优点和缺点。比特币网络的结构明显容易理解，实现起来也相对容易得多，而以太坊网络引入了异或距离、二叉前缀树、K-桶等，结构上复杂不少，但在节点路由上的确会比比特币快很多。另外，不管是比特币还是以太坊，其实都只是一种或多种协议的集合，不同节点其实可以用不同的具体实现，比如，比特币就有用 C++ 实现的 Bitcoin Core，还有用 Java 实现的 BitcoinJ；以太坊也有用 Go 语言实现的 go-ethereum，也有用 C++ 实现的 go-ethereum，还有用 Java 实现的 Ethereum(J)。</p>
<h2 id="思考和实践"><a href="#思考和实践" class="headerlink" title="思考和实践"></a>思考和实践</h2><p>在以太坊的 Kad 网络中，新节点的加入和 K-桶的刷新流程是怎样的？比特币的新节点加入流程又是怎样的？哈希表有哪些实现方式？</p>
<hr>
<p>扫描以下二维码即可关注订阅号。</p>
<img src="/post/blockchain/20180313/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/blockchain/20180224/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/blockchain/20180224/" class="post-title-link" itemprop="url">从微观到宏观理解区块链</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-02-24 00:09:49" itemprop="dateCreated datePublished" datetime="2018-02-24T00:09:49+08:00">2018-02-24</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-02 11:18:28" itemprop="dateModified" datetime="2019-07-02T11:18:28+08:00">2019-07-02</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/blockchain/" itemprop="url" rel="index"><span itemprop="name">blockchain</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/blockchain/20180224"><strong>http://keeganlee.me/post/blockchain/20180224</strong></a><br>微信订阅号：<strong>keeganlee_me</strong><br>写于2018-02-24</p>
<hr>
<p>专栏地址：<a href="https://xiaozhuanlan.com/fullstack" target="_blank" rel="noopener">https://xiaozhuanlan.com/fullstack</a></p>
<hr>
<p>最近区块链异常火爆，而且就只是在这一两个月内的事情，无疑，今年应该会成为区块链爆发元年，相应地，对区块链技术人员的需求将会大幅度增加，为了让大家早日入门区块链开发领域，以取得先发优势，从而在这场区块链革命浪潮中立于不败之地，因此，我决定提前编写系列文章，跟大家聊聊区块链技术。</p>
<h2 id="微观区块链"><a href="#微观区块链" class="headerlink" title="微观区块链"></a>微观区块链</h2><p>相信不少人都听到说<strong>区块链</strong>是分布式账本、分布式数据库、去中心化的等等，有了一些大概的认知，但也只是一些碎片化的认知，还无法形成体系，所以也还不能理解区块链的本质。下面，我将从微观到宏观简单讲解区块链，力求让大伙更容易理解区块链的真正本质。</p>
<p>那么，从微观上理解区块链，就要从理解区块链最底层的数据结构开始。<strong>区块链(Blockchain)</strong>，简单来说就是按时间顺序将数据区块通过哈希指针的方式连接起来的一个链表。<strong>哈希指针</strong>是区块链里最常用的数据结构，其实就是一串数据的<strong>哈希值</strong>，我们知道，一串数据的哈希值就是这串数据的<strong>指纹/摘要</strong>，因此就可以用这个哈希值来指向这串数据，如下图：</p>
<img src="/post/blockchain/20180224/2018-02-07-12-50-00.jpg">
<p>区块链里的每一个区块都有对应本区块的哈希指针，而除了创世区块（即第一个区块）之外，其他每个区块都存储了前一个区块的哈希指针，从而形成如下所示的一个链条，即区块链：</p>
<img src="/post/blockchain/20180224/blockchain.png">
<p>这样的数据结构可以保证数据无法篡改，因为一旦篡改了任何区块的数据，对应的哈希指针就会出错，因此一旦有恶意篡改就能校验到。数据的无法篡改也是区块链本质上最核心的一个特性。</p>
<p>接着，再来看看区块链的基本单元——<strong>区块(block)</strong>，以比特币为例，每个区块的数据结构大致如下：</p>
<img src="/post/blockchain/20180224/block.png">
<p>其中，<strong>Tx0 ~ Tx3</strong> 表示每一笔交易数据，<strong>Hash0</strong> 则是 <strong>Tx0</strong> 这笔交易数据的哈希指针，<strong>Hash01</strong> 则是 <strong>Hash0 + Hash1</strong> 的哈希指针，这样层层叠加上去，得到最后的 <strong>Root Hash</strong>。从图中也可以看出，从Hash0 到 Root Hash 是一个三层的二叉树，由于这颗树的所有节点都是 Hash 值，所以也称为 Hash Tree，但更专业的名称叫 <strong>Merkle Tree</strong>。不过 Merkle Tree 不一定是二叉树，也可以是多叉树。Merkle Tree 的叶子节点（即Hash0 ~ Hash3）是数据块的 Hash 值，而非叶子节点的 value 则是根据下面的叶子节点的 Hash 值串联起来后再计算 Hash 得出的。通过 Merkle Tree 结构，底层的每一笔交易也都无法篡改，一旦篡改，Root Hash 就会不一致。</p>
<p>另外，该结构也简化了支付校验，比如，我们要校验 Tx3 这笔交易的有效性，那只要校验从 Tx3 到  Root Hash 的分支 Hash 值即可，如下图所示，计算 Tx3 的 Hash值得到 Hash3，再结合 Hash2，计算出 Hash23，再拼上 Hash01 计算出 Merkle Root，只要计算出来的 Merkle Root 和实际存储的 Root Hash 一致，则表明该该笔交易是有效的。</p>
<img src="/post/blockchain/20180224/2018-02-20-23-20-02.jpg">
<p>Root Hash 会保存在区块头里，区块头里一般会保存有以下信息：</p>
<ul>
<li><strong>Version</strong>：版本号</li>
<li><strong>Prev Block</strong>：上一个区块的 Hash 值</li>
<li><strong>Merkle Root</strong>：即上面所说的 Merkle Tree 的 Root Hash</li>
<li><strong>Time</strong>：区块的时间</li>
<li><strong>Difficulty</strong>：区块难度</li>
<li><strong>Nonce</strong>：随机数</li>
</ul>
<p>这是比特币的一个区块：<a href="https://btc.com/0000000000000000005b8d4d2508c14f6ea5cbbb3f1104566612dfb29d281b7a" target="_blank" rel="noopener">https://btc.com/0000000000000000005b8d4d2508c14f6ea5cbbb3f1104566612dfb29d281b7a</a>。比特币的每一笔交易，可以有多个输入和多个输出。比如说，我们要做一笔转账，从 A 转 3.3 个 BTC 到 B，假设 A 的钱包地址上原本有 10 个 BTC。那这笔转账，会有一个输入，即 A 的地址有 10 个 BTC，交易完成后变成两个输出，一个是 B 的地址增加 3.3 个 BTC，一个是 A 的地址变成 6.7 个 BTC。这样子，每一个地址的所有交易其实都是可以追溯的，每一个比特币的转账记录也是可以追溯的。</p>
<p>不过，以太坊的区块结构则复杂得多，每个区块并非只有一颗 Merkle Tree，而是有三颗 Merkle Tree，除了<strong>交易树</strong>，还有<strong>状态树</strong>和<strong>收据树</strong>。另外，使用的 Merkle Tree 也是复杂得多，叫 <strong>Merkle Patricia Tree</strong>。详细结构就不展开了，感兴趣的读者自行去搜索了解即可。</p>
<p>简而言之，从微观上来说，区块链就是一种哈希链条，其核心本质特征是<strong>不可篡改且可追踪溯源</strong>。</p>
<h2 id="宏观区块链"><a href="#宏观区块链" class="headerlink" title="宏观区块链"></a>宏观区块链</h2><p>如果只是从微观上理解区块链，那就像井底之蛙，是看不到区块链即将改变世界的未来的。毕竟，从微观上来看的话，要实现不可篡改且可追踪溯源的特性，并不一定需要使用区块链技术。所以，还要看懂区块链宏观上的本质，才能预见到区块链真实的未来。</p>
<p>当然，宏观上来说，区块链的本质是什么，不同人会有不同观点，不少人认为其本质特征是<strong>去中心化的</strong>，另一帮人认为其本质就是<strong>分布式数据库/分布式公共账本</strong>，而在我看来，其核心本质就是一种<strong>自信任的新一代互联网基础协议</strong>。下面我将逐步剖析我的观点。</p>
<p>首先，宏观上的区块链就是一种基础协议，而不是指代具体的技术。作为一种基础协议，有几个基本特征是必备的，那就是<strong>分布式存储、P2P 网络和共识机制</strong>，当然，还有微观层面的<strong>不可篡改且可追踪溯源</strong>，如果不具备这几个特征，哪怕只缺了一个，都不能称为区块链。</p>
<p>先来聊聊第一个基本特征——<strong>分布式存储</strong>。前面我们已经了解到，区块链最底层的数据结构就是一种哈希链条，是用来存储数据的，当然，采用哪种具体的数据库来存储区块链数据则是由各区块链的开发团队自己决定的，比如，比特币和以太坊就选择了 LevelDB。分布式存储，就是说，区块链数据的存储是分布式的，也因此很多人将区块链称为分布式数据库，但区块链的分布式存储与传统的分步式存储有所不同。传统的分布式存储是将数据分散存储到多个服务器上，每个存储服务器上的数据只是全量数据的一部分。但区块链的分布式存储，每个数据节点存储的都是全量数据。不过，区块链的节点可分为<strong>全节点</strong>和<strong>轻节点</strong>，全节点存储了整条区块链的所有数据，包括所有区块头和所有交易数据，而轻节点则只存储了整条链的所有区块头。那如果要在轻节点查询某笔交易的有效性，就需要转去全节点查询了，那节点之间如何通信呢？这就涉及到第二个基本特征——<strong>P2P 网络</strong>。另外，既然是分布式存储，那就还要解决数据一致性的问题，就这涉及到第三个基本特征——<strong>共识机制</strong>。</p>
<p><strong>P2P 网络</strong>，即<strong>对等网络</strong>，也称<strong>点对点网络</strong>或<strong>端对端网络</strong>，是区块链系统中不同节点之间通信的方式，也是一种分布式的网络结构。通过 P2P 网络，不同节点之间可以直接交互，而且彼此连接的每个节点都处于对等的地位。每个节点既充当服务器，为其他节点提供服务，同时也享用其他节点提供的服务。那么，既然每个节点的地位都是对等的，那不同节点之间出现分歧时，要如何达成一致共识呢？这也是<strong>共识机制</strong>所解决的问题。</p>
<p><strong>共识机制</strong>是区块链的一个核心特征，是保证区块链系统在分布式架构下的一致性方案。要理解共识机制，我们先来了解下交易写入区块链的简要过程。首先，当你在某个节点发起一笔交易时，比如从地址 A 转 0.1 个 BTC 到地址 B，该节点接收到交易信息后就对其进行校验，如果地址 A 上的未消费 BTC 的余额大于 0.1 个则可认为该笔交易是合法的，那就会将这笔交易信息放入本节点的 pending 池（待写入区块的交易池），并将这笔交易信息<strong>广播</strong>给其他已建立连接的节点，其他节点接收到交易信息后也做同样的校验并广播，当其中某个节点获得记账权时则可将它<strong>当前的区块（包含上面那笔交易）</strong>写入本节点存储的区块链中并将这个区块广播出去，其他大部分节点校验了此区块为有效，也同样写入它们自己存储的区块链中，这样，你的这笔交易就算真正写入到区块链中了。那如果你同时向 B 和 C 地址分别转 0.1 个 BTC，但你的地址 A 的未消费 BTC 余额只有 0.1 个的情况下，假设有些节点可能只接收到转给 B 的交易，而有些节点则只接收到转到 C 的交易，这些节点分别校验通过并写入了它们的 pending 池，但最终只有其中一笔交易能被写入区块链，取决于哪个节点先获得记账权并被其他大部分节点所接受，而另一笔交易就算已经被那些将其写入了 pending 池的节点所接受，其他节点再次校验后也不会通过。所以，一笔交易是否合法，以及一个新增区块是否有效，不是由某一个节点说了算，而是需要经过多数节点的最终一致共识。</p>
<p>根据区块链的这几个基本特征，明显可以看出，区块链的确是<strong>分布式</strong>的：<strong>分布式存储、分布式网络、分布式共识</strong>。分布式的确是一个重要的特征，但分布式只是一种手段，而不是目的。区块链之所以能被称为革命性的技术，是因为它改变了传统的信任机制。传统的信任机制是怎样的呢？其实就是有一个中间机构为信任背书，比如银行、淘宝、滴滴等，我们通过信任这些中间机构和其他人进行交易。而区块链则没有中间机构这一层了，用户之间直接点对点交易，区块链的数据结构、分布式存储特性和共识机制结合在一起，保证了数据是可靠且不可篡改的，从而实现了一个不需要中间机构的<strong>自信任系统</strong>。也由于没有了中间机构，所以也可以说区块链是<strong>去中心化</strong>的，但这里更准确的说法可能是<strong>去中介化</strong>。但<strong>去中介化</strong>和<strong>分布式</strong>一样，只是手段，而不是目的，核心目的还是构建一个<strong>自信任系统</strong>。</p>
<p>那自信任系统相比有中间机构的信任机制有什么好处呢？我们就举个跨境支付的栗子就明白了。传统的交易支付都要经过银行体系，要经过开户行、对手行、清算组织、境外银行等多个机构和非常繁冗的处理流程。而且，整个过程中每一个机构都有自己的账务系统，彼此之间需要建立代理关系，每笔交易都需要在本银行记账，与交易对手进行清算和对账等，导致整个过程花费时间较长、使用成本较高。而有了区块链，交易双方就可以实现点对点支付，而无需这么多中间机构，从而<strong>简化流程、提高效率</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，总结一下，我分别从微观和宏观两个层面简单聊了下区块链，微观上，其实就是区块链最底层的数据结构，本质就是一种<strong>不可篡改且可追踪溯源的哈希链条</strong>；宏观上，区块链还具备了另外三个基本特征：<strong>分布式存储、P2P 网络和共识机制</strong>，从这几个基本特征可以看出，区块链是<strong>分布式</strong>的，但分布式只是手段，而不是目的，区块链的核心目的是构建一个<strong>自信任系统</strong>，相比依赖中间机构的信任机制，可以<strong>简化流程、提高效率</strong>，这才是区块链之所以能被称为革命性技术的本质原因。</p>
<h2 id="思考和实践"><a href="#思考和实践" class="headerlink" title="思考和实践"></a>思考和实践</h2><p>智能合约为区块链带来了什么？区块链是否必须有数字代币？公有链、联盟链、私有链本质上有什么区别？</p>
<hr>
<p>扫描以下二维码即可关注订阅号。</p>
<img src="/post/blockchain/20180224/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/reading/20160722/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/reading/20160722/" class="post-title-link" itemprop="url">读《图解密码技术》(三):密钥、随机数和应用技术</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-07-22 12:00:00" itemprop="dateCreated datePublished" datetime="2016-07-22T12:00:00+08:00">2016-07-22</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-02 12:09:31" itemprop="dateModified" datetime="2019-07-02T12:09:31+08:00">2019-07-02</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/reading/" itemprop="url" rel="index"><span itemprop="name">reading</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/reading/20160722"><strong>http://keeganlee.me/post/reading/20160722</strong></a><br>微信订阅号：<strong>keeganlee_me</strong><br>写于2016-07-22</p>
<hr>
<p><a href="http://keeganlee.me/post/reading/20160629">读《图解密码技术》(一):密码</a><br><a href="http://keeganlee.me/post/reading/20160705">读《图解密码技术》(二):认证</a><br><a href="http://keeganlee.me/post/reading/20160722">读《图解密码技术》(三):密钥、随机数和应用技术</a></p>
<hr>
<p>最后一篇了，如果还没看过前两篇的，最好先翻回去看看，因为这最后一篇的内容是建立在前两篇的基础之上的。本篇的内容包括密钥、随机数、PGP、SSL/TLS，最后再讲讲密码技术的现状和局限性，以及简单介绍一下量子密码和量子计算机。</p>
<h2 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h2><p>在使用对称密码、公钥密码、消息认证码、数字签名等密码技术时，都需要密钥。密钥长度一般不能太短，太短意味着密钥空间太小，那么，进行暴力破解就很容易。</p>
<p>DES的密钥长度为56比特(7字节)，密钥空间为2^56，在现有的计算能力下，还是比较容易被暴力破解的。三重DES的DES-EDE3的密钥长度为168比特(21字节)，是DES的密钥长度的三倍多，但是密钥空间可不是三倍这么简单，DES-EDE3的密钥空间为2^168，整整是DES密钥空间的2^112倍，这么大的密钥空间，以现有的计算能力，还无法在现实的时间里被暴力破解。AES的密钥长度则可以从128、192和256比特中进行选择，三者的密钥空间也是不小的。</p>
<p>密钥和明文其实是等价的，因为对攻击者来说，得到密钥就等价于得到明文。</p>
<blockquote>
<h3 id="各种不同的密钥"><a href="#各种不同的密钥" class="headerlink" title="各种不同的密钥"></a>各种不同的密钥</h3></blockquote>
<p>从前两篇文章我们就知道，密钥分很多种类，这里我们做一下整理。</p>
<p>在对称密码中，加密和解密使用的是相同的<strong>共享密钥</strong>。而在公钥密码中，加密用的是<strong>公钥</strong>，解密用的则是<strong>私钥</strong>，相对应的公钥和私钥组为<strong>密钥对</strong>。消息认证码使用的也是共享密钥。而数字签名使用的和公钥密码一样是密钥对，用私钥签名，用公钥验证签名。混合密码系统中还使用了一次性密钥，称为<strong>会话密钥</strong>。而相对于每次通信都更换的会话密钥，一直被重复使用的密码则称为<strong>主密钥</strong>。用于加密内容的密钥称为<strong>CEK</strong>(Contents Encrypting Key，内容加密密钥)；相对地，用于加密密钥的密钥则称为<strong>KEK</strong>(Key Encrypting Key，密钥加密密钥)。CEK 和 KEK 的用法可以如下图所示：</p>
<img src="/post/reading/20160722/12-34-15.jpg">

<p>在很多情况下，会话密钥都是被作为 CEK 使用的，而主密钥则是被作为 KEK 使用的。</p>
<blockquote>
<h3 id="密钥的管理"><a href="#密钥的管理" class="headerlink" title="密钥的管理"></a>密钥的管理</h3></blockquote>
<p>生成密钥最好的方法就是使用真正的随机数，因为密钥需要具备不可预测性。不过，一般我们都是使用伪随机数生成器来生成密钥。另外，密码学用途的伪随机数生成器必须是专门针对密码学用途而设计的。毕竟，生成伪随机数的算法很多，但有些并不具备不可预测性。</p>
<p>有时我们也会使用容易记住的<strong>口令</strong>(password 或 passphrase)来生成密钥。passphrase 指的是一种由多个单词组成的较长的 passwrod，在此将两者统称为口令。严格来说，很少直接用口令来作为密钥使用，一般都是将口令输入单向散列函数，然后将得到的散列值作为密钥使用。而在使用口令生成密钥时，为了防止字典攻击，需要在口令上面附加一串称为<strong>盐</strong>(salt)的随机数，然后再将其输入单向散列函数。这种方法称为“基于口令的密码”(Password Based Encryption, PBE)。关于 PBE 稍后再详细介绍。</p>
<p>对于共享密钥，就会存在密钥配送问题。在<a href="http://keeganlee.me/post/reading/20160629">密码篇</a>就提到几种解决方案：<strong>事先共享密钥</strong>、<strong>使用密钥分配中心</strong>、<strong>使用公钥密码</strong>、<strong>Diffie-Hellman密钥交换</strong>。关于Diffie-Hellman密钥交换的原理，之前的文章没讲，在本篇稍后会详细介绍。</p>
<p>为了提高通信的机密性，还可以采用<strong>密钥更新</strong>(key updating)的方法。这种方法就是在使用共享密钥进行通信的过程中，定期改变密钥。例如，在更新密钥时，发送者和接收者使用单向散列函数计算当前密钥的散列值，并将这个散列值用作新的密钥。简单说，就是<strong>用当前密钥的散列值作为下一个密钥</strong>。</p>
<p>除了只使用一次的会话密钥，其他密钥基本都需要考虑<strong>保存密钥</strong>的问题。尤其对于共享密钥来说，很多应用都需要将密钥保存在客户端，例如移动App，要么将密钥硬编码在代码里，或者保存在文件中，但无论哪种方式，应用一旦被反编译，密钥就存在泄漏的风险。以防密钥被盗，可以使用<strong>将密钥加密后保存</strong>的方法。但要将密钥加密，必然需要另一个密钥，即 KEK。那么，KEK 又如何保存？这问题还真不好解决。不过，对密钥进行加密的方法却可以<strong>减少需要保管的密钥数量</strong>。比如，假设平台系统接入了10万个应用，每个应用都有一个自己的密钥，即系统需要保管10万个密钥。那么，用 KEK 对这10万个密钥进行加密，这样的话只要保管这一个 KEK 就可以了。即是说，不需要确保多个密钥(CEK)的机密性，而只需要确保一个密钥(KEK)的机密性就可以了。这和认证机构的层级化非常相似。在后者中，我们不需要信任多个认证机构，而只需要信任一个根 CA 就可以了。</p>
<blockquote>
<h3 id="Diffie-Hellman密钥交换"><a href="#Diffie-Hellman密钥交换" class="headerlink" title="Diffie-Hellman密钥交换"></a>Diffie-Hellman密钥交换</h3></blockquote>
<p>通过Diffie-Hellman密钥交换算法，通信双方仅通过交换一些可以公开的信息就能够生成出共享的秘密数字，而这一秘密数字就可以被用作对称密码的密钥。虽然这种方法名字叫“密钥交换”，但实际上双方并没有真正交换密钥，而是通过计算生成出了一个相同的共享密钥。因此，这种方法也称为<strong>Diffie-Hellman密钥协商</strong>。</p>
<p>Diffie-Hellman密钥交换的步骤如下：</p>
<img src="/post/reading/20160722/16-19-35.jpg">

<ol>
<li><strong>Alice 向 Bob 发送两个质数 P 和 G</strong><br>P 必须是一个非常大的质数，而 G 则是一个和 P 相关的数，称为<strong>生成元</strong>(generator)。G 可以是一个较小的数字。</li>
<li><strong>Alice 生成一个随机数 A</strong><br>A 是一个 1 ~ P-2 之间的整数。这个数是一个只有 Alice 知道的秘密数字。</li>
<li><strong>Bob 生成一个随机数 B</strong><br>B 也是一个 1 ~ P-2 之间的整数。这个数是一个只有 Bob 才知道的秘密数字。</li>
<li><strong>Alice 将 G^A mod P 计算结果的数发送给 Bob</strong></li>
<li><strong>Bob 将  G^B mod P 计算结果的数发送给 Alice</strong></li>
<li><strong>Alice 用 Bob 发过来的数计算 A 次方并求 mod P</strong><br>这个数就是共享密钥。Alice 计算的密钥 = (G^B mod P)^A mod P = G^(A*B) mod P</li>
<li><strong>Bob 用 Alice 发过来的数计算 B 次方并求 mod P</strong><br>Bob 计算的密钥 = (G^A mod P)^B mod P = G^(A*B) mod P = Alice 计算的密钥。可见两方计算的密钥是相等的。</li>
</ol>
<p>关于第1步提到的生成元是什么呢？先来看一张表，假设 P = 13：</p>
<img src="/post/reading/20160722/16-45-42.jpg">

<p>其中，2、6、7、11都是13的生成元。这几个数有什么性质呢？从上表可以发现，这几个数的乘方结果中都出现了1~12的全部整数。也就是说，P 的生成元的乘方结果与 1 ~ P-1 中的数字是一一对应的。正是因为具有这样一一对应的关系，Alice 才能够从 1 ~ P-2 的范围中随机选择一个数字(之所以不能选择 P-1，是因为 G^(P-1) mod P 的值一定是等于1的)。</p>
<p>最后，需要清楚，针对Diffie-Hellman密钥交换是可以发动中间人攻击的。而为了防止中间人攻击，可以使用数字签名、证书等方法来应对。</p>
<blockquote>
<h3 id="基于口令的密码-PBE"><a href="#基于口令的密码-PBE" class="headerlink" title="基于口令的密码(PBE)"></a>基于口令的密码(PBE)</h3></blockquote>
<p><strong>基于口令的密码</strong>(Password Based Encryption，PBE)就是一种根据口令生成密钥并用该密钥进行加密的方法。</p>
<p>PBE 的加密可以用下图来表示：</p>
<img src="/post/reading/20160722/17-02-17.jpg">

<p>主要有三个步骤：</p>
<ol>
<li><strong>生成 KEK</strong><br>首先，通过伪随机数生成器生成一个被称为<strong>盐</strong>(salt)的随机数。然后，将盐和口令一起输入单向散列函数，输出的结果就是 KEK。盐是一种用于防御字典攻击的机制。</li>
<li><strong>生成会话密钥并加密</strong><br>会话密钥 CEK 也是通过伪随机数生成器来生成，生成之后使用 KEK 对其进行加密，然后将加密后的会话密钥和盐一起保存在安全的地方。</li>
<li><strong>加密消息</strong><br>最后，使用 CEK 对消息进行加密。</li>
</ol>
<p>而 PBE 解密的过程则如下图：</p>
<img src="/post/reading/20160722/17-10-23.jpg">

<p>解密主要也是有三个步骤：</p>
<ol>
<li><strong>重建KEK</strong><br>将之前保存下来的盐和口令一起输入单向散列函数，得到的散列值就是 KEK 了。</li>
<li><strong>解密会话密钥</strong><br>再将之前保存下来的已加密的会话密钥用 KEK 进行解密，就能得到会话密钥 CEK 了。</li>
<li><strong>解密消息</strong><br>最后，用已解密的 CEK 对密文进行解密即可。</li>
</ol>
<p>另外，在生成 KEK 时，通过多次使用单向散列函数可以提高安全性。</p>
<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>有哪些场景使用到随机数呢？主要可能有以下这些：</p>
<ul>
<li><strong>生成密钥</strong></li>
<li><strong>生成密钥对</strong></li>
<li><strong>生成初始化向量(IV)</strong></li>
<li><strong>生成nonce</strong></li>
<li><strong>生成盐</strong></li>
</ul>
<p>随机数的性质主要分为三类：</p>
<ul>
<li><strong>随机性</strong>：不存在统计学偏差，是完全杂乱的数列。</li>
<li><strong>不可预测性</strong>：不能从过去的数列推测出下一个出现的数。</li>
<li><strong>不可重现性</strong>：除非将数列本身保存下来，否则不能重现相同的数列。</li>
</ul>
<p>上面三个性质中，越往下就越严格。具备随机性，不代表一定具备不可预测性。具备不可预测性的数列，则一定具备随机性。具备不可重现性的数列，也一定具备不可预测性和随机性。在书中，将这三个性质的随机数按顺序分别命名为“弱伪随机数”、“强伪随机数”和“真随机数”。</p>
<blockquote>
<h3 id="伪随机数生成器"><a href="#伪随机数生成器" class="headerlink" title="伪随机数生成器"></a>伪随机数生成器</h3></blockquote>
<p>随机数可以通过硬件来生成，也可以通过软件来生成。通过硬件生成的随机数列一般都是真随机数，是从不可重现的物理现象中获取信息而生成数列的，比如周围的温度和声音的变化、用户移动鼠标的位置信息、键盘输入的时间间隔、放射线测量仪的输出值等。像这样的硬件设备称为<strong>随机数生成器</strong>(Random Number Generator，RNG)。而生成随机数的软件则称为<strong>伪随机数生成器</strong>(Pseudo Random Number Generator，PRNG)。因为仅靠软件无法生成真随机数，因为要加上一个“伪”字。</p>
<p>伪随机数生成器具有“内部状态”，并根据外部输入的“种子”来生成伪随机数列，如下图：</p>
<img src="/post/reading/20160722/22-08-13.jpg">

<p>伪随机数生成器的<strong>内部状态</strong>，是指伪随机数生成器所管理的内存中的数值。这个数值在每次生成随机数后都会改变。而<strong>种子</strong>是用来初始化内部状态的。伪随机数生成器是公开的，但种子是需要保密的，这就好像密码算法是公开的，但密钥是保密的。</p>
<blockquote>
<h3 id="具体的伪随机数生成器"><a href="#具体的伪随机数生成器" class="headerlink" title="具体的伪随机数生成器"></a>具体的伪随机数生成器</h3></blockquote>
<p>具体的伪随机数生成器有很多，书中介绍了五种：杂乱的方法、线性同余法、单向散列函数法、密码法、ANSI X9.17。</p>
<ul>
<li><p><strong>杂乱的方法</strong><br>杂乱的方法就是使用杂乱无章的算法来生成随机数，但这种方法其实并不可取。一是因为复杂算法所生成的数列大多数具有很短的周期(即短数列的不断重复)；二是因为如果程序员不能够理解算法的详细内容，那么就无法判断所生成的随机数是否具备不可预测性。</p>
</li>
<li><p><strong>线性同余法</strong><br>线性同余法就是将当前的伪随机数值乘以 A 再加上 C，然后将除以 M 得到的余数作为下一个伪随机数。其中，A、C、M都是常量，且 A 和 C 需要小于 M。C 语言的库函数 rand，以及Java 的 Random 类，都采用了线性同余法。线性同余法并不具备不可预测性，因此不可以用于密码技术。</p>
<img src="/post/reading/20160722/23-08-18.jpg">
</li>
<li><p><strong>单向散列函数法</strong><br>使用单向散列函数可以编写出具备不可预测性的伪随机数列(即强伪随机数)的伪随机数生成器。单向散列函数的单向性是支撑伪随机数生成器不可预测性的基础。</p>
<img src="/post/reading/20160722/23-16-58.jpg">
</li>
<li><p><strong>密码法</strong><br>也可以使用密码来编写能够生成强伪随机数的伪随机数生成器。既可以使用 AES 等对称密码，也可以使用 RSA 等公钥密码。密码的机密性是支撑伪随机数生成器不可预测性的基础。</p>
<img src="/post/reading/20160722/23-21-49.jpg">
</li>
<li><p><strong>ANSI X9.17</strong><br>ANSI X9.17 伪随机数生成器的结构则有点复杂，PGP 密码软件就使用了这种方法。</p>
<img src="/post/reading/20160722/23-26-50.jpg">

</li>
</ul>
<h2 id="PGP"><a href="#PGP" class="headerlink" title="PGP"></a>PGP</h2><p>PGP 将多种密码技术进行了完美的组合，其具备了现代密码软件所必需的几乎全部功能，包括但不限于：对称密码、公钥密码、数字签名、单向散列函数、证书、压缩、大文件的拆分和拼合、钥匙串管理等。</p>
<blockquote>
<h3 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h3></blockquote>
<p>要在 PGP 中进行加密和数字签名，需要先生成自己的密钥对。下图展示了从命令行生成密钥的过程，其中，粗体为用户输入的内容：</p>
<img src="/post/reading/20160722/12-32-19.jpg">

<blockquote>
<h3 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h3></blockquote>
<p>使用 PGP 进行加密的过程如下图所示：</p>
<img src="/post/reading/20160722/12-24-53.jpg">

<p>而解密的过程则如下：</p>
<img src="/post/reading/20160722/12-25-15.jpg">

<p>PGP 的私钥是保存在用户的钥匙串中的。另外，私钥都是以加密状态保存的，并在保存时使用了基于口令的密码(PBE)。</p>
<blockquote>
<h3 id="生成和验证数字签名"><a href="#生成和验证数字签名" class="headerlink" title="生成和验证数字签名"></a>生成和验证数字签名</h3></blockquote>
<p>生成数字签名的过程如下图：</p>
<img src="/post/reading/20160722/12-40-27.jpg">

<p>而验证签名的过程则如下图：</p>
<img src="/post/reading/20160722/12-41-39.jpg">

<blockquote>
<h3 id="生成数字签名并加密以及解密并验证数字签名"><a href="#生成数字签名并加密以及解密并验证数字签名" class="headerlink" title="生成数字签名并加密以及解密并验证数字签名"></a>生成数字签名并加密以及解密并验证数字签名</h3></blockquote>
<p>如何将密码和数字签名进行组合，下面两张图是整本书最复杂的，但它只不过是将之前讲解的内容组合起来了而已。<br>下图是生成数字签名并加密的过程：</p>
<img src="/post/reading/20160722/12-44-34.jpg">

<p>而下图则是解密并验证数字签名的过程：</p>
<img src="/post/reading/20160722/12-45-00.jpg">

<blockquote>
<h3 id="信任网"><a href="#信任网" class="headerlink" title="信任网"></a>信任网</h3></blockquote>
<p>如何确认公钥的合法性？前面介绍的证书是一种方法。对公钥的信任是建立在对认证机构的信任的基础之上的。不过，PGP 却没有使用认证机构，而是采用了一种叫做<strong>信任网</strong>(也称为<strong>信任圈</strong>或<strong>好友圈</strong>)的方法。信任网的要点是“不依赖认证机构，而是建立每个人之间的信任关系”。换言之，就是能够自己决定要信任哪些公钥。</p>
<p>PGP 当初的设计目的是在连国家都不可信的情况下依然能够使用，因此它并不关心有没有可信的认证机构，而是采用了“由用户自己来决定信任谁”这样的设计。</p>
<p>需要注意，“公钥是否合法”与“所有者是否可信”是两个不同的问题，因为尽管公钥合法，其所有者也可以是不可信的。例如，Alice认为从Bob那获得的公钥是合法的，因为这个公钥是Bob当面交给Alice的。但是Alice不信任Bob在数字签名上的判断能力，即便Bob对其他的公钥进行了数字签名，Alice也会怀疑Bob是否真的进行了本人确认。</p>
<p>在 PGP 中，信任级别可以分为四种：绝对信任、完全信任、有限信任和不信任。</p>
<h2 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h2><p>SSL/TLS也是综合运用了对称密码、公钥密码、消息认证码、数字签名、伪随机数生成器等密码技术。而我们知道SSL/TLS最广泛的应用就是套接在HTTP上，但实际上，SSL/TLS还可以套接在其他网络协议之上的，例如，SMTP 和 POP3 之类的电子邮件协议。因为现在广泛使用的是TLS协议，因此下文只以TLS协议为主。</p>
<p>TLS安全协议可分为两层：<strong>TLS记录协议</strong>和 <strong>TLS握手协议</strong>。TLS记录协议在TLS握手协议的下层，负责数据封装、压缩、加密等功能。而TLS握手协议则用于在实际的数据传输开始前，通信双方进行身份认证、协商加密算法、交换密钥等。TLS握手协议又分为4个子协议：握手协议、密码规格变更协议、警告协议和应用数据协议。TLS协议的层次结构如下图：</p>
<img src="/post/reading/20160722/14-06-27.jpg">

<blockquote>
<h3 id="TLS记录协议"><a href="#TLS记录协议" class="headerlink" title="TLS记录协议"></a>TLS记录协议</h3></blockquote>
<p>TLS记录协议的处理过程如下图：</p>
<img src="/post/reading/20160722/12-43-27.jpg">

<p>首先，消息被分割成多个片段，然后分别对每个片段进行压缩。压缩算法需要与通信对象协商决定。接下来，经过压缩的片段会被加上消息认证码，这就可以保证完整性，并进行数据的认证。同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编号。单向散列函数的算法，以及消息认证码所使用的密钥都需要与通信对象协商决定。再接下来，就是加密了。加密使用CBC模式，CBC模式的初始化向量(IV)通过主密码生成，而对称密码的算法和共享密钥也是需要与通信对象协商决定。最后，密文再加上数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。其中，数据类型为TLS握手协议中的4个子协议之一。</p>
<blockquote>
<h3 id="TLS握手协议"><a href="#TLS握手协议" class="headerlink" title="TLS握手协议"></a>TLS握手协议</h3></blockquote>
<p>TLS握手协议可分为4个子协议，其中，<strong>握手协议</strong>是最复杂的一个子协议，其过程如下图：</p>
<img src="/post/reading/20160722/12-58-28.jpg">

<p><strong>1. ClientHello(客户端-&gt;服务器)</strong><br>客户端向服务器发送ClientHello消息，消息内容主要包括：可用的版本号、当前时间、客户端随机数、会话ID、可用的密码套件清单、可用的压缩方式清单。<br><strong>2. ServerHello(服务器-&gt;客户端)</strong><br>对于客户端发送的ClientHello消息，服务器会返回一个ServerHello消息，消息内容主要包括：使用的版本号、当前时间、服务器随机数、会话ID、使用的密码套件、使用的压缩方式。这一步确定了通信中使用的“版本号”、“密码套件”和“压缩方式”。<br><strong>3. Certificate(服务器-&gt;客户端)</strong><br>服务器再向客户端发送Certificate消息，主要是<strong>证书清单</strong>。首先发送的是服务器的证书，然后会按顺序发送对服务器证书签名的认证机构的证书。<br><strong>4. ServerKeyExchange(服务器-&gt;客户端)</strong><br>当Certificate消息不足以满足需求时，服务器会向客户端发送ServerKeyExchange消息。具体所发送的消息内容会根据所使用的密码套件而有所不同。<br><strong>5. CertificateRequest(服务器-&gt;客户端)</strong><br>CertificateRequest消息用于服务器向客户端请求证书，这是为了进行<strong>客户端认证</strong>。消息内容还包括：服务器能够理解的证书类型清单和认证机构名称清单。当不使用客户端认证时，不会发送CertificateRequest消息。<br><strong>6. ServerHelloDone(服务器-&gt;客户端)</strong><br>服务器发送ServerHelloDone消息则表示从ServerHello消息开始的一系列消息的结束。<br><strong>7. Certificate(客户端-&gt;服务器)</strong><br>当服务器发送了CertificateRequest消息时，则客户端会发送Certificate消息，将自己的证书同消息一起发送给服务器。如果服务器没有发送CertificateRequest消息，客户端则不会发送Certificate消息。<br><strong>8. ClientKeyExchange(客户端-&gt;服务器)</strong><br>客户端发送ClientKeyExchange消息。当密码套件中包含RSA时，会随消息一起发送<strong>经过加密的预备主密码</strong>。当密码套件中包含Diffie-Hellman密钥交换时，会随消息一起发送<strong>Diffie-Hellman的公开值</strong>。预备主密码是由客户端生成的随机数，之后会被用作生成主密码的种子。根据预备主密码，服务器和客户端会计算出相同的<strong>主密码</strong>，然后再根据主密码生成：对称密码的密钥、消息认证码的密钥、对称密码的CBC模式中使用的初始化向量(IV)。<br><strong>9. CertificateVerify(客户端-&gt;服务器)</strong><br>客户端只有在服务器发送CertificateRequest消息时才会发送CertificateVerify消息。这个消息的目的是向服务器证明自己的确持有客户端证书的私钥。为了实现这一目的，客户端会计算“主密码”和“握手协议中传送的消息”的散列值，并加上自己的数字签名后发送给服务器。<br><strong>10. ChangeCipherSpec(客户端-&gt;服务器)</strong><br>客户端发送ChangeCipherSpec消息表示要切换密码。实际上，这不是握手协议的消息，而是密码规格变更协议的消息。在ChangeCipherSpec消息之前，客户端和服务器之间以及交换了所有关于密码套件的信息，因此在收到这一消息时，客户端和服务器会同时切换密码。在这一消息之后，TLS记录协议就开始使用双方协商决定的密码通信方式了。<br><strong>11. Finished(客户端-&gt;服务器)</strong><br>客户端发送Finished消息表示握手协议到此结束。这个消息其实是使用切换后的密码套件来发送的。实际负责加密操作的是TLS记录协议。<br><strong>12. ChangeCipherSpec(服务器-&gt;客户端)</strong><br>这次轮到服务器发送ChangeCipherSpec消息了，表明服务器要切换密码了。<br><strong>13. Finished(服务器-&gt;客户端)</strong><br>服务器也同样发送Finished消息表明握手协议到此结束。这个消息同样使用切换后的密码套件来发送。实际负责加密操作的也是TLS记录协议。<br><strong>14. 切换至应用数据协议</strong><br>在此之后，客户端和服务器会使用应用数据协议和TLS记录协议进行密码通信。</p>
<p>从结果来看，握手协议完成了下列操作：</p>
<ul>
<li>客户端获得了服务器的合法公钥，完成了服务器认证。</li>
<li>服务器获得了客户端的合法公钥，完成了客户端认证(当需要客户端认证时)。</li>
<li>客户端和服务器生成了密码通信中使用的共享密钥。</li>
<li>客户端和服务器生成了消息认证码中使用的共享密钥。</li>
</ul>
<p>除了握手协议，其他3个子协议都很简单。<strong>密码规格变更协议</strong>用于密码切换的同步。简单地说，就跟向对方喊“1、2、3！”差不多。当协议中途发生错误时，就会通过警告协议传达给对方。<strong>警告协议</strong>负责在发生错误时将错误传达给对方。如果没有发生错误，则会使用应用数据协议来进行通信。<strong>应用数据协议</strong>用于和通信对象之间传送应用数据。当TLS套接在HTTP时，HTTP的请求和相应就会通过TLS的应用数据协议和TLS记录协议来进行传送。</p>
<h2 id="密码技术与现实社会"><a href="#密码技术与现实社会" class="headerlink" title="密码技术与现实社会"></a>密码技术与现实社会</h2><p>前面讲到的6种基本的密码技术可整理成下图：</p>
<img src="/post/reading/20160722/14-01-39.jpg">

<p>书中多次使用了<strong>框架</strong>这个说法。框架的特点就是能够对其中作为组成元素的技术进行替换，就像更好零件一样。例如，消息认证码算法HMAC的设计就允许对单向散列函数的算法进行替换。在PGP中，对称密码、公钥密码、单向散列函数等都是可以替换的。在SSL/TLS中，客户端和服务器可以通过握手协议进行通信，并当场决定所使用的密码套件。使用框架能够提高密码技术系统的重用性，也能够提高系统的强度。通过将单独的密码技术像零件一样组合起来，并根据需要进行替换，能够实现更长期的、更高的安全性。</p>
<p>另外，所有密码技术其实也可以看成是一种“压缩技术”，如下表所示：</p>
<img src="/post/reading/20160722/14-16-59.jpg">

<blockquote>
<h3 id="量子密码和量子计算机"><a href="#量子密码和量子计算机" class="headerlink" title="量子密码和量子计算机"></a>量子密码和量子计算机</h3></blockquote>
<p><strong>量子密码</strong>是基于量子理论的通信技术，是一种让通信本身不可窃听的技术，也可以理解为是一种利用光子的量子特性来实现通信的方法。最早的量子密码中，利用了两个事实：<br><strong>1. 从原理上说，无法准确测出光子的偏振方向</strong><br>根据这一事实，可以让窃听者得到的内容变得不正确。<br><strong>2. 测量行为本身会导致光子的状态发送改变</strong><br>根据这一事实，接收者可以判断出通信是否被窃听。</p>
<p>而<strong>量子计算机</strong>则有着超强的计算能力。如果有了量子计算机，那现有的所有密码都能够瞬间被暴力破解。根据量子理论，粒子可同时具有多种状态。如果使用具有多种状态的粒子进行计算，则可以同时完成多种状态的计算。如果用1个粒子能够计算0和1两种状态，那么用128个这样的粒子就可以同时计算2^128中状态。换句话说，就是一台超级并行计算机。</p>
<p>如果量子密码比量子计算机先进入实用领域，则可以使用量子密码来实现一次性密码本，从而产生完美的密码技术。由于一次性密码本在原理上是无法破译的，因此即使用量子计算机也无法破译量子密码。然而，如果量子计算机比量子密码先进入实用领域，则实用目前的密码技术所产生的密文将会全部被破译。</p>
<blockquote>
<h3 id="只有完美的密码，没有完美的人"><a href="#只有完美的密码，没有完美的人" class="headerlink" title="只有完美的密码，没有完美的人"></a>只有完美的密码，没有完美的人</h3></blockquote>
<p>就算量子密码进入实用领域，也不能实现完美的安全。因为在安全问题中，密码技术能够覆盖的范围是非常有限的。在确保系统的整体安全方面，人是一个特别巨大的弱点。</p>
<p>为了配送对称密码的密钥，我们需要使用公钥密码，而为了对公钥进行认证，我们又需要认证机构的公钥。以此类推，无穷无尽，我们必须在某个节点上找到一个公钥是自己能够完全信任的，也就是必须要有一个信任的种子。</p>
<p>通过密码技术，我们可以提高机密性，也能够让认证变得更加容易，但是这并不意味着我们可以实现完美的机密性和完美的认证。</p>
<p>就算通过人的指纹、声纹、面容识别等生物识别认证也并不是完美的认证。要进行生物识别认证，就必须在某个时间点上将生物信息转换为比特序列，而实际的认证则是通过转换后的比特序列来完成的。因此，如果这些比特序列被窃取，就会和钥匙被偷产生相同的后果。</p>
<p>另外，“防御必须天衣无缝，攻击只需突破一点”。为了保卫系统安全，我们必须应对各种可能的攻击，而且这种防御必须24小时连续工作。另一方面，要攻击一个系统，则只要找到一种有效的攻击方法，而且只需利用防御方一瞬间的破绽就可以完成了。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>其实，在实际应用中，安全问题所涉及的技术，远比这本书里所讲到的密码技术多得多，也复杂得多。例如，App的加壳保护、OAuth认证等。在实际的应用中，还需要考虑更多，比如，安全性和性能之间需要平衡。虽然，懂得了这些密码技术，并不意味着就能设计出非常安全的系统。但是，如果不懂这些密码技术，那就更难以设计出安全的系统。</p>
<hr>
<p>扫描以下二维码即可关注订阅号。</p>
<img src="/post/reading/20160722/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/reading/20160705/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/reading/20160705/" class="post-title-link" itemprop="url">读《图解密码技术》(二):认证</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-07-05 13:30:00" itemprop="dateCreated datePublished" datetime="2016-07-05T13:30:00+08:00">2016-07-05</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-02 11:59:22" itemprop="dateModified" datetime="2019-07-02T11:59:22+08:00">2019-07-02</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/reading/" itemprop="url" rel="index"><span itemprop="name">reading</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/reading/20160705"><strong>http://keeganlee.me/post/reading/20160705</strong></a><br>微信订阅号：<strong>keeganlee_me</strong><br>写于2016-07-05</p>
<hr>
<p><a href="http://keeganlee.me/post/reading/20160629">读《图解密码技术》(一):密码</a><br><a href="http://keeganlee.me/post/reading/20160705">读《图解密码技术》(二):认证</a><br><a href="http://keeganlee.me/post/reading/20160722">读《图解密码技术》(三):密钥、随机数和应用技术</a></p>
<hr>
<p><a href="http://keeganlee.me/post/reading/20160629">前一篇文章</a>总结了密码部分的内容，包括一次性密码本、对称密码、公钥密码、混合密码系统等。这些密码在一定程度上能够保证消息的机密性，即可以防止被窃听导致秘密泄露。但却无法防御信息被篡改，也无法确定消息的来源是否就是真实的发送者而不是来自伪装者，也防止不了发送者事后否认自己先前做过的行为。关于这些问题，在本文总结的密码技术中就可以找到解决方案。</p>
<p>本文是关于《图解密码技术》第二部分的内容总结，包括单向散列函数、消息认证码、数字签名、证书。</p>
<h2 id="单向散列函数"><a href="#单向散列函数" class="headerlink" title="单向散列函数"></a>单向散列函数</h2><p>使用单向散列函数可以获取消息的“指纹”，通过对比“指纹”，就能够知道两条消息是否一致。这种一致性，也称为完整性，可以识别出消息是否被篡改。</p>
<p><strong>单向散列函数</strong>(one-way hash function)有一个输入和一个输出，其中输入称为<strong>消息</strong>(message)，输出称为<strong>散列值</strong>(hash value)。散列值也称为<strong>消息摘要</strong>(message digest)或者<strong>指纹</strong>(fingerprint)。单向散列函数可以根据消息的内容计算出散列值，而散列值就可以用来检查消息的完整性。</p>
<blockquote>
<h3 id="单向散列函数的性质"><a href="#单向散列函数的性质" class="headerlink" title="单向散列函数的性质"></a>单向散列函数的性质</h3></blockquote>
<ul>
<li><strong>根据任意长度的消息计算出固定长度的散列值</strong><br>首先，单向散列函数的输入必须能够是任意长度的消息。其次，无论输入多长的消息，必须都能够生成很短的散列值。如果消息越长生成的散列值也越长的话就不好用了，而且为了方便使用，散列值的长度最好是短且固定的。不管消息是1比特，还是100M，甚至是100G，单向散列函数都会计算出固定长度的散列值。比如，SHA-1计算出的散列值固定为160比特（20字节）。</li>
<li><strong>能够快速计算出散列值</strong><br>计算散列值所花费的时间必须要短。尽管消息越长，计算散列值的时间也会越长，但如果不能在现实的时间内完成计算就没有意义了。</li>
<li><strong>具备单向性</strong><br>单向散列函数必须具备单向性。单向性是指无法通过散列值反算出消息的性质。就如同将玻璃砸得粉碎很容易，但却无法将碎片还原成完整的玻璃一样，根据消息计算出散列值很容易，但根据散列值却无法反算出消息。</li>
<li><strong>消息不同散列值也不同</strong><br>为了能够确认完整性，消息中哪怕只有 1 比特的改变，也必须有很高的概率产生不同的散列值。为什么说有很高的概率呢？这是因为消息很长，而散列值很短，那就肯定会存在不同消息产生相同散列值的情况，这种情况称为<strong>碰撞</strong>(collision)。因此，单向散列函数没法完全避免碰撞，只能减低碰撞发生的概率。而且，更重要的是，要避免被人为地发现碰撞。难以发现碰撞的性质称为<strong>抗碰撞性</strong>(collision resistance)。单向散列函数必须具备抗碰撞性。另外，抗碰撞性还分为两种：弱抗碰撞性和强抗碰撞性。<strong>弱抗碰撞性</strong>是指要找到和给定的消息具有相同散列值的另外一条消息是非常困难的。<strong>强抗碰撞性</strong>则是指要找到散列值相同的两条不同的消息是非常困难的。单向散列函数必须既具备弱抗碰撞性，也必须具备强抗碰撞性。</li>
</ul>
<blockquote>
<h3 id="单向散列函数的例子"><a href="#单向散列函数的例子" class="headerlink" title="单向散列函数的例子"></a>单向散列函数的例子</h3></blockquote>
<p>单向散列函数有很多种，MD4、MD5、SHA-1、SHA-256、SHA-384、SHA-512、SHA-3等等。</p>
<p>MD4是由Rivest于1990年设计的，MD是消息摘要(message digest)的缩写，两者都能够产生128比特的散列值。不过，第二年，即1991年，就已经有人提出了MD4的漏洞，很容易就寻找到了MD4散列碰撞的方法。因此，Rivest又设计了更为成熟的MD5。MD5到现在依然有着广泛的应用，例如很多网站和应用的登录密码都使用了MD5。但MD5的强抗碰撞性已经被攻破，也就是说，现在已经能够产生具备相同散列值的两条不同的消息。所以，其实MD5已经不安全了。</p>
<p>SHA是NSA(美国国家安全局)设计，NIST(美国国家标准与技术研究院)发布的一系列单向散列函数。SHA是以MD4和MD5类似的原理为基础来设计的。SHA-1能够产生160比特的散列值，不过消息长度是有上限的，上限为2^64比特(准备地说是2^64-1)。当然这个数已经非常巨大，所以在实际应用中没有问题。不过，SHA-1的强抗碰撞性已于2005年被攻破。所以，SHA-1也和MD5一样没那么安全了。不过，貌似SHA-1依然是目前使用最广泛的单向散列函数。</p>
<p>SHA-256、SHA-384和SHA-512的散列值长度分别为256比特、384比特和512比特。它们的消息长度也存在上限，SHA-256的上限和SHA-1一样，而SHA-384和SHA-512的消息上限则为2^128比特(确切值为2^128-1)。这些单向散列函数合起来称为SHA-2。目前，SHA-2还没有被攻破。</p>
<p>在2005年SHA-1被攻破的背景下，促进了SHA-3的产生。SHA-3与AES一样采用了公开竞赛的方式进行标准化，最后胜出的是Keccak算法。</p>
<blockquote>
<h3 id="单向散列函数SHA-1"><a href="#单向散列函数SHA-1" class="headerlink" title="单向散列函数SHA-1"></a>单向散列函数SHA-1</h3></blockquote>
<p>SHA-1作为一个具有代表性的单向散列函数，让我们看看它的算法流程是怎样的。整体流程如下图：</p>
<img src="/post/reading/20160705/17-51-46.jpg">

<p>可以分为四个步骤：</p>
<ol>
<li><p><strong>填充</strong><br>对消息进行填充处理，使其长度为512比特的整数。这里的512比特称为一个输入分组。具体填充的步骤也分为三步：第一步在消息末尾添加一个1比特的数值“1”；第二步在添加了“1”之后的消息末尾不断添加0，直到消息的长度达到512比特的整数倍，但最后一个分组的最后64比特需要空出来；第三步将消息的长度换成二进制后添加到上一步空出来的最后一个分组的最后64比特中。</p>
</li>
<li><p><strong>计算 W0 ~ W79</strong><br>对每一个输入分组分别计算80个32比特的值，这80个值将用于“单步处理“中。计算流程如下图：</p>
<img src="/post/reading/20160705/21-27-07.jpg">

</li>
</ol>
<p>首先，将输入分组的512比特分成16组，每组32比特。然后，剩下的 W16 ~ W79 使用如下的公式进行计算：</p>
<img src="/post/reading/20160705/21-30-51.jpg">

<ol start="3">
<li><strong>分组处理</strong><br>接下来，对输入分组进行80个步骤的处理，目的是根据输入分组的信息来改变内部状态。流程如下图，其中，160比特的内部状态是通过名为A~E的5个32比特的缓冲区来表示的：<img src="/post/reading/20160705/21-39-08.jpg">

</li>
</ol>
<p>将5个缓冲区的值与输入分组的信息进行混合，然后再执行80个步骤的处理。从结果来看，这80个步骤所完成的操作，就是将输入分组的512比特的数据，也SHA-1所保持的160比特的内部状态(5个缓冲区)进行混合。通过80个步骤的反复执行，SHA-1就能够将已经过填充的消息全部混入这160比特的内部状态中，而SHA-1所输出的散列值，就是所有处理结束之后最终的内部状态(160比特)。</p>
<ol start="4">
<li><strong>单步处理</strong><br>单步处理是指上面的80个步骤中的每一步的处理，处理过程如下图：<img src="/post/reading/20160705/21-55-03.jpg">

</li>
</ol>
<p>在一个步骤完成之后，缓冲区A、B、C、D的内容会被分别复制到B、C、D、E中(其中B要循环左移30比特之后再复制)，而缓冲区 E 的内容则会与其他缓冲区的内容以及Wt、Kt相加之后再被复制到缓冲区A中。<br>由于上述处理要循环80个步骤，因此输入分组中 1 比特的变化，就会影响到散列值中几乎所有的比特，通过这样的方式，就能够实现单向散列函数所应具备的性质。</p>
<blockquote>
<h3 id="对单向散列函数的攻击"><a href="#对单向散列函数的攻击" class="headerlink" title="对单向散列函数的攻击"></a>对单向散列函数的攻击</h3></blockquote>
<p>对单向散列函数的攻击主要就是对单向散列函数的”抗碰撞性“的攻击。</p>
<p>对“弱抗碰撞性”的攻击主要是利用消息的冗余性生成具有相同散列值的另一个消息，这种攻击也是<strong>暴力破解</strong>，每次都稍微改变一下消息的值，然后对这些消息求散列值。在这种情况下，暴力破解需要尝试的次数可以根据散列值的长度计算出来。以SHA-1为例，由于它的散列值长度为160比特，因此最多只要尝试2^160次就能够找到目标消息。由于尝试次数纯粹是由散列值长度决定的，因此散列值长度越长的单向散列函数，其抵御暴力破解的能力也就越强。</p>
<p>对“强抗碰撞性”的攻击一般称为<strong>生日攻击</strong>。生日攻击不是寻找生成特定散列值的消息，而是要找到相同散列值的两条消息，而散列值则可以是任何值。生日攻击的原理来自生日悖论，也就是利用了“任意散列值一致的概率比想象中高”这样的特性。相对于暴力破解，生日攻击所需尝试的次数要少得多，一般只需要是暴力破解的一半。</p>
<blockquote>
<h3 id="单向散列函数无法解决的问题"><a href="#单向散列函数无法解决的问题" class="headerlink" title="单向散列函数无法解决的问题"></a>单向散列函数无法解决的问题</h3></blockquote>
<p>单向散列函数可以实现完整性的检查，但却识别不了“伪装”，即无法解决认证问题。认证问题需要使用消息认证码和数字签名来解决。</p>
<p>单向散列函数在实际应用中很少单独使用，而是和其他密码技术结合使用。后面要讲的消息认证码和数字签名都使用了单向散列函数，而下一篇要讲的密钥、伪随机数和应用技术也都使用了单向散列函数。</p>
<h2 id="消息认证码"><a href="#消息认证码" class="headerlink" title="消息认证码"></a>消息认证码</h2><p><strong>消息认证码</strong>(message authentication code)是一种确认完整性并进行认证的技术，简称为 <strong>MAC</strong>。消息认证码的输入包括任意长度的<strong>消息</strong>和一个发送者与接受者之间<strong>共享的密钥</strong>，它可以输出固定长度的数据，这个数据称为 <strong>MAC 值</strong>。</p>
<p>消息认证码与单向散列函数很类似，都是根据任意长度的消息输出固定长度的数据，不同的是，消息认证码比单向散列函数多了一个共享密钥。没有共享密钥的人就无法计算出 MAC 值，消息认证码正是利用这一性质来完成认证的。此外，和单向散列函数一样，哪怕消息中发生 1 比特的变化，MAC 值也会发生变化，消息认证码正是利用这一性质来确认完整性的。</p>
<blockquote>
<h3 id="消息认证码的使用步骤"><a href="#消息认证码的使用步骤" class="headerlink" title="消息认证码的使用步骤"></a>消息认证码的使用步骤</h3></blockquote>
<p>消息认证码的使用步骤如下图：</p>
<img src="/post/reading/20160705/23-48-57.jpg">

<p>发送者与接收者需要事先共享密钥，然后发送者使用共享密钥对消息计算 MAC 值，接着将消息和 MAC值一起发送给接收者。接收者收到消息和 MAC 值后，使用同一个共享密钥对消息计算 MAC 值，当计算出来的 MAC 值和接收到的 MAC 值一致的，就证明认证成功了。</p>
<p>而既然是使用共享密钥，那就和对称密码一样，存在密钥配送问题。要解决密钥配送问题，同样可以使用事先共享密钥、密钥配送中心、Diffie-Hellman密钥交换、公钥密码等方法。具体请看<a href="http://keeganlee.me/post/reading/20160629">前一篇</a>文章的<strong>密钥配送问题</strong>部分。</p>
<blockquote>
<h3 id="消息认证码的实现"><a href="#消息认证码的实现" class="headerlink" title="消息认证码的实现"></a>消息认证码的实现</h3></blockquote>
<p>消息认证码有很多种实现方法。可以使用SHA-1、MD5之类的<strong>单向散列函数</strong>来实现，其中有一种实现方法叫 <strong>HMAC</strong>，后面我们再讲它实现的具体步骤。</p>
<p>也可以使用DES、AES之类的<strong>分组密码</strong>来实现消息认证码，将分组密码的密钥作为消息认证码的共享密钥来使用，并用 CBC 模式将消息全部加密。由于消息认证码不需要解密，因此，可以只保留最后一个分组的密文作为 MAC 值，而其他密文则全部丢弃。由于 CBC 模式的最后一个分组会收到整个消息以及密钥的双重影响，因此可以将它用作消息认证码。</p>
<p>此外，使用流密码和公钥密码等也可以实现消息认证码。</p>
<blockquote>
<h3 id="HMAC"><a href="#HMAC" class="headerlink" title="HMAC"></a>HMAC</h3></blockquote>
<p><strong>HMAC</strong> 是一种使用单向散列函数来构造消息认证码的方法，其中，HMAC 中的 H 就是 Hash 的意思。HMAC 中所使用的单向散列函数并不仅限于一种，任何高强度的单向散列函数都可以被用于 HMAC，也就是说，HMAC 所使用的单向散列函数是可以被替换的。</p>
<p>HMAC 是按照下列步骤来计算 MAC 值的：</p>
<img src="/post/reading/20160705/18-16-52.jpg">

<ol>
<li>密钥填充<br>如果密钥比单向散列函数的分组长度要短，就需要在末尾填充0，直到其长度达到单向散列函数的分组长度为止。如果密钥比分组长度要长，则要用单向散列函数求出密钥的散列值，然后将这个散列值用作 HMAC 的密钥。</li>
<li>填充后的密钥与 ipad 的 XOR<br>将填充后的密钥与被称为 ipad 的比特序列进行 XOR 运算。<strong>ipad</strong> 是将 00110110 这一比特序列(即16进制的36）不断循环反复直到达到分组长度所形成的比特序列，其中 ipad 的 i 是 inner 的意思。XOR 运算后得到的值，就是一个和单向散列函数分组长度相同，且和密钥相关的比特序列。这里将这个比特序列称为 <strong>ipadkey</strong>。</li>
<li>与消息组合<br>随后，将 ipadkey 与消息进行组合，ipadkey 一般附加在消息开头。</li>
<li>计算散列值<br>将上一步组合的结果输入单向散列函数，计算出散列值。</li>
<li>填充后的密钥与 opad 的 XOR<br>将填充后的密钥与被称为 opad 的比特序列进行 XOR 运算。<strong>opad</strong> 是将 01011100 这一比特序列(即16进制的5C）不断循环反复直到达到分组长度所形成的比特序列，其中 opad 的 o 是 outer 的意思。XOR 运算后得到的值，也是一个和单向散列函数分组长度相同，且和密钥相关的比特序列。这里将这个比特序列称为 <strong>opadkey</strong>。 </li>
<li>与散列值组合<br>将第4步计算出来的散列值拼在 opadkey 的后面。</li>
<li>计算散列值<br>将上一步的结果输入单向散列函数，计算出散列值。这个散列值就是 MAC 值。</li>
</ol>
<blockquote>
<h3 id="对消息认证码的攻击"><a href="#对消息认证码的攻击" class="headerlink" title="对消息认证码的攻击"></a>对消息认证码的攻击</h3></blockquote>
<p>对消息认证码可以发起<strong>重放攻击</strong>，即攻击者可以通过将事先拦截保存的正确 MAC 值不断重放来发动攻击。有几种方法可以防御重放攻击：</p>
<ul>
<li>序号<br>每次发送消息时都赋予一个递增的序号，并在计算 MAC 值时将序号也包含在消息中。这样，由于攻击者无法计算序号递增之后的 MAC 值，因此就可以防御重放攻击。这种方法虽然有效，但对每个通信对象都需要记录最后一个消息的序号。</li>
<li>时间戳<br>发送消息时可以包含进当前时间，如果收到以前的消息，即便 MAC 值正确也将其视为错误的消息来处理，这样就可以防御重放攻击。这种方法虽然也有效，但发送者与接收者的时钟必须一致，而且考虑到通信的延迟，必须在时间的判断上留下缓冲，于是多多少少还是会存在可以进行重放攻击的。</li>
<li>nonce<br>在通信之前，接收者先向发送者发送一个一次性的随机数，这个随机数一般称为 <strong>nonce</strong>。发送者在消息中包含这个 nonce 并计算 MAC 值。由于每次通信时 nonce 的值都会发生变化，因此无法进行重放攻击。这种方法虽然有效，但通信的数据量会有所增加。</li>
</ul>
<p>另外，除了重放攻击，对消息认证码也可以进行暴力破解和生日攻击，这和对单向散列函数的攻击一样。对消息认证码来说，应保证不能根据 MAC 值推测出通信双方所使用的密钥。例如 HMAC 就是利用单向散列函数的单向性和抗碰撞性来保证无法根据 MAC 值推测出密钥的。</p>
<blockquote>
<h3 id="消息认证码无法解决的问题"><a href="#消息认证码无法解决的问题" class="headerlink" title="消息认证码无法解决的问题"></a>消息认证码无法解决的问题</h3></blockquote>
<p>使用消息认证码可以对消息进行认证并确认完整性，即能够识别出消息的篡改和伪装。但却解决不了“对第三方证明”和“防止否认”。</p>
<p>假如接收者在收到发送者的消息之后，想要向第三方证明这条消息的确是发送者发送的，但是用消息认证码无法进行这样的证明，为什么呢？首先，第三方要校验 MAC 值，就需要知道发送者与接收者之间共享的密钥。但知道密钥后，也校验出 MAC 值是正确的，依然无法证明消息就是发送者发的，因为也有可能是接收者发的。</p>
<p>既然第三方无法做出证明，那么，如果发送者事后否认自己发送过消息，而谎称是接收者自己发送给自己的消息，对于这种情况也是无法证明，即无法防止否认。</p>
<p>后面要讲的数字签名就可以解决这两个问题。</p>
<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>消息认证码之所以无法对第三方证明和防止否认，就是因为发送者和接收者使用了同一个共享密钥。那么，如果发送者和接收者不使用共享密钥，而各自使用不同密钥呢？假如发送者使用的密钥是一个只有自己知道的私钥，在这里可称为“签名密钥”，当发送者发送消息时，用她的签名密钥生成一个“签名”。相对地，接收者使用另一个密钥，称为“验证密钥”，可对签名进行验证。但是，使用验证密钥是无法生成签名的。也就是说，只有签名密钥可以生成签名，而用相应的验证密钥可以对该签名进行验证。这种技术就是<strong>数字签名</strong>(digital signature)，也称为<strong>电子签名</strong>，或简称为<strong>签名</strong>。另外，签名密钥只能由签名的人持有，而验证密钥则是任何需要验证签名的人都可以持有。</p>
<p>上面讲的内容，和公钥密码很像吧？其实，数字签名就是通过将公钥密码反过来用而实现的。</p>
<blockquote>
<h3 id="公钥密码与数字签名"><a href="#公钥密码与数字签名" class="headerlink" title="公钥密码与数字签名"></a>公钥密码与数字签名</h3></blockquote>
<p>下图是使用公钥加密(即公钥密码)的简单流程图：</p>
<img src="/post/reading/20160705/22-31-41.jpg">
<p>而下图则是使用私钥加密(即数字签名)的简单流程图：</p>
<img src="/post/reading/20160705/22-29-08.jpg">

<p>那么，为什么用私钥加密就相当于生成签名，而用公钥解密就相当于验证签名呢？这是因为组成密钥对的两个密钥之间存在严密的数学关系，使用公钥加密的密文，只能用与该公钥配对的私钥才能解密；同样地，使用私钥加密的密文，也只能用与该私钥配对的公钥才能解密。也就是说，如果用某个公钥成功解密了密文，那么就能够证明这段密文是用与该公钥配对的私钥进行加密所得到的。用私钥进行加密这一行为只能由持有私钥的人完成，正是基于这一事实，才可以将用私钥加密的密文作为签名来对待。而由于公钥是对外公开的，因此任何人都可以用公钥进行解密，即任何人都能够对签名进行验证。</p>
<blockquote>
<h3 id="数字签名的方法"><a href="#数字签名的方法" class="headerlink" title="数字签名的方法"></a>数字签名的方法</h3></blockquote>
<p>有两种生成和验证数字签名的方法：</p>
<ul>
<li><strong>直接对消息签名的方法</strong><br>直接对消息签名的方法很容易理解，但实际上很少使用。签名和验证的过程如下图：<img src="/post/reading/20160705/12-28-14.jpg">

</li>
</ul>
<p>我们知道，公钥密码算法本来就非常慢。用这种方法需要对整个消息进行加密，就会非常耗时。因此，在实际应用中，基本不会使用直接对消息签名的方法。</p>
<ul>
<li><strong>对消息的散列值签名的方法</strong><br>对消息先使用单向散列函数计算出散列值，再对散列值进行签名，这种方法的过程如下图：<img src="/post/reading/20160705/12-34-17.jpg">

</li>
</ul>
<p>因为散列值比较短，因此对其进行加密签名就会快很多。</p>
<blockquote>
<h3 id="数字签名的实现"><a href="#数字签名的实现" class="headerlink" title="数字签名的实现"></a>数字签名的实现</h3></blockquote>
<p>数字签名的实现也有很多种，基本也是使用单向散列函数和公钥密码技术相结合。而公钥密码部分常用的就是使用RSA，另外也有使用EIGamal、Rabin。还有一种数字签名算法叫DSA(Digital Signature Algorithm)。而使用最广泛的应该就是使用RSA的数字签名了。</p>
<p>使用RSA实现数字签名很简单。而为了更加简单起见，这里不使用单向散列函数，而是直接对消息进行签名。首先，需要将文本的消息先编码为数字，因为在RSA中，被签名的消息、密钥以及最终生成的签名都是以数字形式表示的。接着，使用下列公式生成签名：</p>
<ul>
<li>签名 = 消息^D mod N  (用RSA生成签名)</li>
</ul>
<p>D 和 N 就是签名者的私钥。生成签名后，发送者就可以将消息和签名一起发送给接收者了。</p>
<p>而验证签名时则使用下列公式：</p>
<ul>
<li>由签名求得的消息 = 签名^E mod N  (用RSA验证签名)</li>
</ul>
<p>E 和 N 就是签名者的公钥。接收者计算出“由签名求得的消息”后，与发送者直接发送过来的“消息”内容进行对比(如果使用了单向散列函数那就是对比消息的散列值)。如果两者一致则签名验证成功，否则签名验证失败。</p>
<blockquote>
<h3 id="对数字签名的攻击"><a href="#对数字签名的攻击" class="headerlink" title="对数字签名的攻击"></a>对数字签名的攻击</h3></blockquote>
<p>因为数字签名结合了单向散列函数和公钥密码，因此，对单向散列函数和公钥密码的攻击也同样对数字签名有效。比如，针对公钥密码的中间人攻击对数字签名来说就颇具威胁。要防止中间人攻击，就需要确认自己所得到的公钥是否真的属于自己的通信对象。而解决此问题的方案也和公钥密码一样，一般可以使用公钥证书。</p>
<p>对单向散列函数的攻击也是对“抗碰撞性”的攻击，使用高强度的单向散列函数就可以增大被破解的难度。</p>
<p>另外，还可以利用数字签名攻击公钥密码。因为对消息签名，从另一方面来说，也是对消息解密。利用这一点，攻击者就可以发动一种巧妙的攻击，即利用数字签名来破译密文。</p>
<p>假设攻击者拦截到发送者发给接收者的密文后将其保存了下来，并给接收者写了一封邮件，谎称自己是密码学研究者，正在进行关于数字签名的实验，请求接收者对附件中的数据进行签名并回复，说附件中的数据只是随机数据，不会造成任何问题。而实际上，附件的数据就是刚才保存下来的密文。如果接收者中计而对附近进行了签名并回复给了攻击者，那攻击者不费吹灰之力就可以破译密文了。</p>
<p>对于这种攻击，应该采取怎样的对策呢？首先，不要直接对消息进行签名，对散列值进行签名比较安全；其次，公钥密码和数字签名最好分别使用不同的密钥对。然而，最重要的就是绝对不要对意思不清楚的消息进行签名，尤其是不要对看起来只是随机数据的消息进行签名。</p>
<blockquote>
<h3 id="数字签名无法解决的问题"><a href="#数字签名无法解决的问题" class="headerlink" title="数字签名无法解决的问题"></a>数字签名无法解决的问题</h3></blockquote>
<p>用数字签名既可以识别出篡改和伪装，还可以防止否认。即是说，数字签名同时实现了确认消息的完整性、进行认证以及否认防止。</p>
<p>然而，数字签名存在和公钥密码一样的问题，那就是公钥问题。公钥必须属于真正的发送者，要确认公钥是否合法，就需要使用证书。这就是后面要讲到的内容了。</p>
<h2 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h2><p>无论是公钥密码还是数字签名，都存在需要验证公钥是否合法的问题。而证书，就是用来对公钥合法性提供证明的技术。</p>
<p><strong>公钥证书</strong>(Public-Key Certificate，PKC)和驾照类似，一般会记有姓名、组织、邮箱地址等个人信息，以及属于本人的公钥，并由<strong>认证机构</strong>(Certification Authority、Certifying Authority，CA)施加数字签名。</p>
<p>认证机构就是能够认定“公钥确实属于此人”并能够生成数字签名的个人或组织。认证机构中有国际性组织和政府所设立的组织，也有通过提供认证服务来盈利的一般企业，此外个人也可以成立认证机构哦。世界上最有名的认证机构当属VeriSign公司。</p>
<blockquote>
<h3 id="证书的应用场景"><a href="#证书的应用场景" class="headerlink" title="证书的应用场景"></a>证书的应用场景</h3></blockquote>
<p>通过认证机构使用证书的过程如下图所示：</p>
<img src="/post/reading/20160705/10-22-29.jpg">

<ol>
<li>接收者生成密钥对；</li>
<li>接收者在认证机构注册自己的公钥；</li>
<li>认证机构用自己的私钥对接收者的公钥施加数字签名并生成证书；</li>
<li>发送者得到带有认证机构数字签名的属于接收者的公钥证书；</li>
<li>发送者使用认证机构的公钥验证数字签名，验证通过则证明证书中包含的公钥的确属于接收者的；</li>
<li>发送者用接收者的公钥加密消息并发送给接收者；</li>
<li>接收者用自己的私钥解密密文得到消息。</li>
</ol>
<blockquote>
<h3 id="公钥基础设施-PKI"><a href="#公钥基础设施-PKI" class="headerlink" title="公钥基础设施(PKI)"></a>公钥基础设施(PKI)</h3></blockquote>
<p><strong>公钥基础设施</strong>(Public-Key Infrastructure)是为了能够更有效地运用公钥而制定的一系列规范和规格的总称。公钥基础设施一般根据其英语缩写而简称为PKI。PKI只是一个总称，而并非指某一个单独的规范或规格。比如，使用最广泛的 X.509 规范也是PKI的一种。</p>
<p>PKI的组成要素主要有3个：</p>
<ul>
<li><strong>用户</strong>：使用PKI的人</li>
<li><strong>认证机构</strong>：颁发证书的人</li>
<li><strong>仓库</strong>：保存证书的数据库</li>
</ul>
<p>这三者的关系如下图：</p>
<img src="/post/reading/20160705/10-54-39.jpg">

<p>另外，认证机构会有层级的关系，处于最顶层的认证机构一般就称为<strong>根CA</strong>(Root CA)。上层认证机构可以验证下层认证机构的证书，即是说，下层认证机构的证书是经过上层认证机构签名的。而根CA则会对自己的证书进行签名，这叫<strong>自签名</strong>。认证机构的层级关系如下图：</p>
<img src="/post/reading/20160705/10-59-23.jpg">

<p>当发送者需要对最底层的Bob的数字签名进行验证时，首先从最顶层的根CA开始，然后获得下层的公钥证书，这个证书上面会带有上层的数字签名，因此需要用上层的公钥对数字签名进行验证。这样逐层向下验证，一直验证到最底层的Bob。</p>
<blockquote>
<h3 id="对证书的攻击"><a href="#对证书的攻击" class="headerlink" title="对证书的攻击"></a>对证书的攻击</h3></blockquote>
<p>由于证书使用的就是数字签名技术，因此针对数字签名的所有攻击方法对证书都有效。</p>
<p>另外，在公钥注册之前也可以进行攻击。用户准备在认证机构注册自己的公钥时，攻击者可以把消息拦截，然后将公钥替换成自己的。这样一来，认证机构就会对“接收者的个人信息”和“攻击者的公钥”这个组合进行数字签名。要防止这种攻击，接收者可以在将自己的公钥发送给认证机构进行注册时，使用认证机构的公钥对自己的公钥进行加密。此外，认证机构在确认接收者的身份时，也可以将公钥的指纹(即散列值)一并发送给接收者请他进行确认。</p>
<p>攻击者还可以利用注册相似人名进行攻击。证书是认证机构对公钥及其持有者的信息加上数字签名的产物，对于一些相似的身份信息，计算机可以进行区别，但人类往往很容易认错，而这就可以被用来进行攻击。比如，假设用户信息中名字的部分是：</p>
<ul>
<li>Name = Bob  (首字母大写)</li>
</ul>
<p>而攻击者用另一个类似的用户信息注册了另一个不同的公钥：</p>
<ul>
<li>Name = BOB (所有字母大写)</li>
</ul>
<p>随后，攻击者伪装成Bob，将 Name = BOB 的公钥发送给通信对象Alice，Alice看到证书中的用户信息，很可能会将BOB误认为是自己要发送消息的对象Bob。</p>
<p>要防止这种攻击，认证机构必须确认证书中所包含的信息是否真的是其持有者的个人信息，当本人身份确认失败时则不向其颁发证书。</p>
<p>攻击者也可以窃取认证机构的私钥，不过认证机构对私钥的保护是非常严密的，所以一般比较难窃取。如果认证机构的私钥泄露了，认证机构就需要将私钥泄露一事通过 CRL 通知用户。CRL(Certificate Revocation List)为证书作废清单，是认证机构宣布作废的证书一览表，具体来说，是一张已作废的证书序列号的清单，并由认证机构加上了数字签名。</p>
<p>利用钻上面提到的 CRL 的空子也可以进行攻击。因为从公钥失效到发送者收到 CRL 需要经过一段时间，攻击者就可以利用这段时间差来发动攻击。</p>
<blockquote>
<h3 id="关于证书的-Q-amp-A"><a href="#关于证书的-Q-amp-A" class="headerlink" title="关于证书的 Q&amp;A"></a>关于证书的 Q&amp;A</h3></blockquote>
<ul>
<li><strong>为什么需要证书</strong><br>如果从认证机构获取公钥，就可以降低遭到中间人攻击的风险。因为带有证书的公钥是经过认证机构进行数字签名的，事实上无法被篡改。</li>
</ul>
<p>其实，如果能够取得可信的公钥，比如通信双方在同一个办公室，很容易取得可信的公钥，这种情况下则不需要认证机构。否则，认证机构和证书的存在就有意义了。当持有可信的认证机构公钥，并相信认证机构所进行的身份确认的情况下，则可以信任该认证机构颁发的证书以及通过该途径取得的公钥。</p>
<ul>
<li><strong>通过自己的方法进行认证是不是更安全</strong><br>有些人对使用公开的技术总觉得不放心，使用公开的技术等于为攻击者提供了用于攻击的信息，相比之下，还是使用公司自己开发的保密的认证方法更安全吧？</li>
</ul>
<p>其实这是错误的。自己开发保密的方法是犯了典型的<strong>隐蔽式安全</strong>(security by obscurity)错误。私下开发安全相关的技术其实是危险的，仅靠一家公司的力量无法开发出足以抵御攻击的安全技术。这也是为什么 AES 和 RSA 算法要采用公开竞赛的方式，让全世界的安全专家一起来验证这些技术的安全性。</p>
<ul>
<li><strong>为什么要相信认证机构</strong></li>
</ul>
<p>其实，这个问题关系到“信任是如何产生的”这一本质性问题。为什么我们要把钱存进银行呢？认证机构是否让人感到可信，和银行是一样的。</p>
<p>也有不依赖于认证机构的，PGP 软件就是。PGP 是通过<strong>信任网</strong>的方法来建立每个人之间的信任关系的。下一篇文章再具体讲 PGP。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>本篇文章总结了四部分内容：单向散列函数、消息认证码、数字签名和证书。数字签名的安全性最高，既能确保完整性，也能进行认证和防止否认。另外，数字签名也是将单向散列函数和公钥密码技术相结合在了一起。<a href="http://keeganlee.me/post/reading/20160629">前一篇</a>文章所讲的混合密码系统也是结合了多种技术。其实，实用性的安全产品，都是多种密码技术组合在一起实用的。例如，PGP、SSL\TLS等。下一篇就会讲如何将多种密码技术组合在一起。</p>
<hr>
<p>扫描以下二维码即可关注订阅号。</p>
<img src="/post/reading/20160705/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/reading/20160629/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/reading/20160629/" class="post-title-link" itemprop="url">读《图解密码技术》(一):密码</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-06-29 10:50:00" itemprop="dateCreated datePublished" datetime="2016-06-29T10:50:00+08:00">2016-06-29</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-02 12:15:18" itemprop="dateModified" datetime="2019-07-02T12:15:18+08:00">2019-07-02</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/reading/" itemprop="url" rel="index"><span itemprop="name">reading</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/reading/20160629"><strong>http://keeganlee.me/post/reading/20160629</strong></a><br>微信订阅号：<strong>keeganlee_me</strong><br>写于2016-06-29</p>
<hr>
<p><a href="http://keeganlee.me/post/reading/20160629">读《图解密码技术》(一):密码</a><br><a href="http://keeganlee.me/post/reading/20160705">读《图解密码技术》(二):认证</a><br><a href="http://keeganlee.me/post/reading/20160722">读《图解密码技术》(三):密钥、随机数和应用技术</a></p>
<hr>
<p>以前，对一些密码技术，虽然懂得怎么用，但对其原理却一直不甚了解，比如，用公钥加密后，为什么用私钥就可以解密？DES和AES加密时为什么需要一个初始化向量？想要了解这些密码技术的基本原理，而最近买书时看到了《图解密码技术》这本书，刚好可以解答到我的这些问题，于是，就买回来看了。</p>
<p>而从现在开始，每读一本书，我都会尽量分享我的读书笔记，有两个目的：一是为自己做总结整理，加强记忆和理解；二是可以给还没看过该书的读者提供摘要和指引。好了，接下来进入正文。</p>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>《图解密码技术》的目标读者主要包括以下人群：</p>
<ul>
<li>对密码相关知识感兴趣的人</li>
<li>希望理解公钥密码、数字签名等密码技术原理的人（我就属于此类）</li>
<li>对信息安全感兴趣的人</li>
</ul>
<p>本书的结构分为三部分：</p>
<ul>
<li>密码：内容主要包括对密码技术整体性的讲解，以及历史密码、对称密码、公钥密码等保证机密性的密码技术。</li>
<li>认证：内容包括单向散列函数、消息认证码、数字签名、证书等密码技术。</li>
<li>密钥、随机数和应用技术：内容包括密钥、随机数相关的知识，以及PGP、SSL/TLS等应用技术。</li>
</ul>
<p>本篇文章是关于第一部分的笔记。</p>
<h2 id="密码技术"><a href="#密码技术" class="headerlink" title="密码技术"></a>密码技术</h2><p>密码技术的目的很明确，就是为了解决信息安全问题。信息安全可分为四类特性：</p>
<ul>
<li><strong>机密性</strong>：为了防止信息被窃听，对应的密码技术有<strong>对称密码</strong>和 <strong>公钥密码</strong>。</li>
<li><strong>完整性</strong>：为了防止信息被篡改，对应的密码技术有<strong>单向散列函数</strong>、 <strong>消息认证码</strong>、 <strong>数字签名</strong>。</li>
<li><strong>认证</strong>：为了防止攻击者伪装成真正的发送者，对应的密码技术有<strong>消息认证码</strong>和 <strong>数字签名</strong>。</li>
<li><strong>不可否认性</strong>：为了防止发送者事后否认自己没有做过，对应的密码技术为<strong>数字签名</strong>。</li>
</ul>
<p>信息安全和密码技术之间的关系可以用下图来表示：</p>
<img src="/post/reading/20160629/09-38-10.jpg">

<p>接下来就简单了解下这些密码技术：</p>
<ul>
<li><strong>对称密码</strong>：也称为共享密钥密码、私钥密码等，是指在加密和解密时使用同一密钥的方式。</li>
<li><strong>公钥密码</strong>：也称为非对称密码，是指在加密和解密时使用不同密钥的方式。对称密码和公钥密码可以保证数据的机密性。</li>
<li><strong>单向散列函数</strong>：MD5、SHA-1，就是单向散列函数的例子，使用单向散列函数可以计算出散列值，散列值也称为哈希值、密码校验和、指纹、消息摘要。使用单向散列函数可以保证数据的完整性。</li>
<li><strong>消息认证码</strong>：消息认证码是一种确认完整性并进行认证的技术，英文名称为message authentication code，简称为MAC。</li>
<li><strong>数字签名</strong>：数字签名相当于现实世界中的盖章、签字的功能，使用数字签名可以识别篡改和伪装，还可以防止否认。</li>
<li><strong>伪随机数生成器</strong>：伪随机数生成器并不直接解决信息安全问题，但它承担了密钥生成的重要职责。而密钥的重要性就不用多说了。</li>
</ul>
<h2 id="一次性密码本"><a href="#一次性密码本" class="headerlink" title="一次性密码本"></a>一次性密码本</h2><p>曾经以为，理论上应该没有任何密码是无法破译的。只要通过暴力破解法，无论任何密文总有一天都能够被破译。如今才知道，特例是存在的。这个特例就是<strong>一次性密码本</strong>。即使用暴力破解法，就算破解到世界末日，也破译不了一次性密码本。</p>
<p>一次性密码本其实非常简单，它的原理就是：<strong>将明文与一串随机的比特序列进行XOR运算，即异或运算</strong>。随机的比特序列也称为<strong>密钥</strong>，密钥的长度需与明文等长。而解密时，则将密文与密钥再进行一次XOR运算，就可以得到明文了。</p>
<p>举例，现在要对midnight这个字符串进行加密，对其进行ASCII编码后得到一串比特序号：</p>
<img src="/post/reading/20160629/11-09-16.jpg">

<p>以上为64比特，然后，随机生成一个同样64比特长的密钥：</p>
<img src="/post/reading/20160629/11-10-14.jpg">

<p>接着，将明文和密钥进行XOR运算：</p>
<img src="/post/reading/20160629/11-11-45.jpg">

<p>这样，密文就产生了。而解密则是反向运算，即将密文与密钥进行XOR运算：</p>
<img src="/post/reading/20160629/11-13-39.jpg">

<p>一次性密码本，就是这么简单。那么，为什么它不可破译呢？用暴力破解，尝试所有可能的密钥组合，总能得到midnight啊。问题就在于，即使解密出了midnight这个字符串，也无法判断它是否是正确的明文。因为，所有64比特的排列组合都会出现，那么，解密出来的，除了midnight，还会有onenight、lastnight，以及aaaaaaaa、abcdefgh、ZZZZZZZZ等各种字符串，根本无法判断哪个才是正确的明文。</p>
<p>虽然一次性密码本无法被破译，但它并不实用。最大的缺点就在于每一次通信都需要使用不同的密钥，所以密钥就无法重用了，“一次性”也正是由此而来。而且，每次密钥的生成都必须是无重现性的真正随机数，而不是伪随机数。其他的，密钥的配送、保存、同步也都是比较麻烦。所以，能够使用一次性密码本的，只有机密性重于一切，且可以花费大量财力和人力来生成并配送密钥的场合。据说，大国之间的热线就用了一次性密码本，密钥应该是通过特工直接送到对方手上的。</p>
<h2 id="对称密码"><a href="#对称密码" class="headerlink" title="对称密码"></a>对称密码</h2><p>对称密码使用相同的密钥进行加密和解密，作为标准的对称密码主要有<strong>DES</strong>、 <strong>三重DES</strong>和 <strong>AES</strong>，它们都属于<strong>分组密码</strong>，即以分组为单位进行处理的密码算法。DES和三重DES的分组长度都是64比特，而AES的分组长度可以为128比特、192比特和256比特中的一种。那么，如果要加密的明文比较长，就需要对密码算法进行迭代，而迭代的方法就称为分组密码的<strong>模式</strong>。具体有哪些模式，后面再说。</p>
<blockquote>
<h3 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h3></blockquote>
<p>DES(Data Encryption Standard)是一种将64比特的明文加密成64比特的密文的对称密码算法，它的密钥长度是56比特，即7个字节。DES的结构采用的是<strong>Feistel网络</strong>。Feistel网络中，加密的各个步骤称为<strong>轮</strong>(round)，整个加密过程就是进行若干次轮的循环。下图是Feistel网络中一轮的计算流程。DES是一种16轮循环的Feistel网络。</p>
<img src="/post/reading/20160629/21-44-33.jpg">

<p>一轮的具体计算步骤如下：</p>
<ol>
<li>将输入的数据等分为左右两部分；</li>
<li>将输入的右侧直接发送到输出的右侧；</li>
<li>将输入的右侧发送到轮函数；</li>
<li>轮函数根据右侧数据和子密钥，计算出一串看上去是随机的比特序列；</li>
<li>将上一步得到的比特序列与左侧数据进行XOR运算，并将结果作为加密后的左侧。</li>
</ol>
<p>其中，<strong>子密钥</strong>指的是本轮加密使用的密钥。每一轮的子密钥都是不同的。<strong>轮函数</strong>的作用则是根据“右侧”和子密钥生成对“左侧”进行加密的比特序列，它是密码系统的核心。</p>
<p>但是，这样一来“右侧”根据没有被加密，因此需要用不同子密钥对一轮的处理重复若干次，并在没两轮之间将左侧和右侧的数据对调。下图展示了一个3轮的Feistel网络：</p>
<img src="/post/reading/20160629/22-01-06.jpg">

<p>那么，Feistel如何解密呢？很简单，只要按照相同的顺序来使用子密钥就可以完成解密了。即将上图中的子密钥1换成了子密钥3，而子密钥3则换成子密钥1，输入的为密文，输出的则为明文了。</p>
<p>无论是任何轮数、任何轮函数，Feistel网络都可以用相同的结构实现加密和解密，且加密的结果必定能够正确解密。因为Feistel网络具有如此方便的特性，因此，被许多分组密码算法使用，包括5个AES最终候选算法中的其中3个算法：MARS、RC6、Twofish。</p>
<blockquote>
<h3 id="三重DES"><a href="#三重DES" class="headerlink" title="三重DES"></a>三重DES</h3></blockquote>
<p>现在DES已经可以在短时间内被暴力破解，因此，其强度大不如前了。为了增强DES的强度，因此出现了三重DES(triple-DES)，将DES重复3次所得到的一种密码算法，通常缩写为3DES，其机制如下图所示：</p>
<img src="/post/reading/20160629/22-28-53.jpg">

<p>明文经过三次DES处理才能变成最后的密文，而由于DES的密钥长度为56比特，因此三重DES的密钥长度则为56<em>3=128比特。另外，从图中也可以发现，三重DES并不是进行3次DES加密，而是加密-&gt;*</em>解密**-&gt;加密的过程。这是为了向下兼容，即使用DES加密的密文，也可以通过三重DES进行解密。</p>
<p>三重DES的解密过程和加密相反，是以密钥3、密钥2、密钥1的顺序执行解密-&gt;加密-&gt;解密的操作。即将上图从明文到密文的箭头反过来就是解密的流程了。</p>
<blockquote>
<h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3></blockquote>
<p>AES(Advanced Encryption Standard)是取代其前任标准(DES)而成为新标准的一种对称密码算法。AES最终候选算法名单中，总共有5种算法，分为为：MARS、RC6、Rijndael、Serpent、Twofish。但最终被选定为AES的是<strong>Rijndael</strong>算法。</p>
<p>Rijndael使用的并不是Feistel网络，而是<strong>SPN结构</strong>。Rijndael加密中的一轮如下图所示，其分组为128比特，即16字节，加密过程经过4个步骤：SubBytes、ShiftRows、MixColumns、AddRoundKey。</p>
<img src="/post/reading/20160629/22-48-28.jpg">

<p><strong>SubBytes</strong>就是根据一张替换表(S-Box)，将输入中每个字节的值替换成另一个字节的值。<strong>ShiftRows</strong>即将SubBytes的输出以字节为单位进行打乱出路，当然，这种打乱处理也是有规律的。<strong>MixColumns</strong>即对一个4字节的值进行比特运算，将其变成另外一个4字节的值。<strong>AddRoundKey</strong>就是将MixColumns的输出与轮密钥进行XOR处理。至此，一轮就结束了。实际上，在Rijndael中需要重复进行10~14轮计算。</p>
<p>而下图则是一轮解密的流程图，基本也是反向操作，加密时的SubBytes、ShiftRows、MixColumns，解密时分别为反向运算的InvSubBytes、InvShiftRows、InvMixColumns。这是因为Rijndael不像Feistel网络一样能够用同一种结构实现加密和解密。</p>
<img src="/post/reading/20160629/23-30-28.jpg">

<p>对于三种对称密码，DES因为已经很容易被暴力破解，因此不建议再使用；三重DES目前还被银行等机构使用，但其处理速度不高，而且在安全性方面也逐渐显现出了一些问题；AES作为最新标准，安全、快速，而且可以在各种平台上工作，可以算是目前最佳的选择。另外，其他AES最终候选算法也可以作为AES的备份。和Rijndael一样，这些密码算法也都经过了严格的测试，且没有发现任何弱点。</p>
<h2 id="分组模式"><a href="#分组模式" class="headerlink" title="分组模式"></a>分组模式</h2><p>DES、AES都属于分组密码，它们只能加密固定长度的明文。如果需要加密任意长度的明文，就需要对分组密码进行迭代，而迭代方法就称为分组密码的“模式”。分组密码有很多种模式，主要有：ECB、CBC、CFB、OFB、CTR。如果模式选择不恰当，就无法保证机密性。</p>
<blockquote>
<h3 id="ECB模式"><a href="#ECB模式" class="headerlink" title="ECB模式"></a>ECB模式</h3></blockquote>
<p><strong>ECB</strong>全称为Electronic CodeBook，<strong>电子密码本模式</strong>，是最简单的一种模式，它直接将明文分割成多个分组并逐个加密，如下图，其中，加密和解密是指用分组密码算法加密和解密，其中也省略了密钥的描述。</p>
<img src="/post/reading/20160629/21-42-05.jpg">

<p>当最后一个明文分组的内容小于分组长度时，需要用一些特定的数据进行填充。</p>
<p>这种模式的优点就是简单、快速，加密和解密都支持并行计算。而缺点也比较明显，因为每个明文分组都各自独立地进行加密和解密，如果明文中存在多个相同的明文分组，则这些分组最终会被转换为相同的密文分组。这样一来，只要观察一下密文，就可以知道明文中存在怎样的重复组合，并可以以此为线索来破译密码。另外，攻击者可以通过改变密文分组的顺序，或删除密文分组，或替换掉密文分组，就可以达到对明文操纵的目的，而无需破译密码。</p>
<blockquote>
<h3 id="CBC模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h3></blockquote>
<p><strong>CBC</strong>全称为Cipher Block Channing，<strong>密文分组链接模式</strong>，是将前一个密文分组与当前明文分组的内容混合起来进行加密的。在CBC模式中，首先将明文分组与前一个密文分组进行XOR运算，然后再进行加密。加密第一个明文分组时，由于不存在“前一个密文分组”，因此需要事先准备一个长度为一个分组的比特序列来代替“前一个密文分组”，这个比特序列称为<strong>初始化向量</strong>(initialization vector)，通常缩写为IV。一般来说，每次加密时都会随机产生一个不同的比特序列来作为初始化向量。CBC模式的加解密流程如下图：</p>
<img src="/post/reading/20160629/21-43-28.jpg">

<p>CBC模式避免了ECB模式的弱点，明文的重复排列不会反映在密文中。这是推荐使用的一种模式。</p>
<blockquote>
<h3 id="CFB模式"><a href="#CFB模式" class="headerlink" title="CFB模式"></a>CFB模式</h3></blockquote>
<p><strong>CFB</strong>全称为Cipher FeedBack，<strong>密文反馈模式</strong>，前一个密文分组会被送回到密码算法的输入端，如下图：</p>
<img src="/post/reading/20160629/13-13-14.jpg">

<p>CFB模式中，由密码算法所生成的比特序列称为<strong>密钥流</strong>(key stream)。需要注意的是，CFB模式解密时，密码算法执行的是加密操作，因为密钥流是通过加密操作来生成的。</p>
<p>CFB模式无法抵御重放攻击。因此，一般不建议使用了，推荐用CTR模式代替。</p>
<blockquote>
<h3 id="OFB模式"><a href="#OFB模式" class="headerlink" title="OFB模式"></a>OFB模式</h3></blockquote>
<p><strong>OFB</strong>全称为Output-FeedBack，<strong>输出反馈模式</strong>，密码算法的输出会反馈到密码算法的输入中，如下图：</p>
<img src="/post/reading/20160629/13-24-29.jpg">

<p>OFB模式有个缺陷，如果对密钥流的一个分组进行加密后其结果碰巧和加密前是相同的，那么这一分组之后的密钥流就会变成同一值的不断反复。因此，一般不建议使用了，推荐用CTR模式代替。</p>
<blockquote>
<h3 id="CTR模式"><a href="#CTR模式" class="headerlink" title="CTR模式"></a>CTR模式</h3></blockquote>
<p><strong>CTR</strong>全称为CountTeR，<strong>计数器模式</strong>，是一种通过逐次累加的计数器进行加密来生成密钥流的流密码，如下图：</p>
<img src="/post/reading/20160629/13-28-45.jpg">

<p>CTR模式中，每个分组对应一个逐次累加的计数器，并通过对计数器进行加密来生成密钥流。计数器分为两部分，前部分为<strong>nonce</strong>，这和初始化向量一样，也是一个随机比特序列；后部分为分组序号。</p>
<p>从图中还可以知道，CTR模式对每个分组的处理是相对独立的，这就意味着加密和解密都能够实现并行计算。</p>
<p>CTR模式在错误和机密性方面都具有不错的性质，也没有上面提到的CFB和OFB的弱点，因此，现在都推荐使用CTR了。</p>
<blockquote>
<h3 id="关于初始化向量问题"><a href="#关于初始化向量问题" class="headerlink" title="关于初始化向量问题"></a>关于初始化向量问题</h3></blockquote>
<p>前面讲到的几种模式中，CBC、CFB、OFB都用到了初始化向量IV，而CTR则使用了计数器，计数器的<strong>nonce</strong>部分和初始化向量IV是一样的，只是叫法不同而已。关于初始化向量IV，是一个随机比特序列，为了提高安全性，建议每次加密时都使用不同的值，这样的话，即使有两条相同的明文信息，加密后的密文也是不同的。但是，每一次发送端使用IV对明文加密后，接收端也需要使用同样的IV才能够解密，那么，发送端和接收端如何同步这个IV呢？关于这个问题，书中没有提到。于是，只好自己寻找解决方案。</p>
<p>最简单的方式可能就是，发送端每次发送信息时，将IV和加密后的密文一起发送给接收端。接收端收到信息后，就可以将收到的IV用于解密收到的密文了。而这种方式最明显的缺陷就是IV直接暴露给攻击者了，攻击者就可以利用IV发起攻击，比如使用CBC模式时，攻击者将IV进行比特反转，就可达到操纵明文的目的。攻击者将IV中的任意比特进行反转(1变0，0变1)，则解密后的明文分组中相应的比特也会被反转。</p>
<p>为了避免将IV直接暴露，那将IV进行加密后再发送呢？因为IV的长度和一个分组的长度是等长的，这就不需要考虑分组迭代的问题，即不需要考虑使用什么模式了，直接用密码算法进行加密即可。加密后，攻击者再想通过比特反转IV来操纵明文就困难多了。</p>
<h2 id="密钥配送问题"><a href="#密钥配送问题" class="headerlink" title="密钥配送问题"></a>密钥配送问题</h2><p>对称密码中，由于加密和解密都使用同一个密钥，因此就必须向接收者配送密钥，这个问题就称为密钥配送问题。而解决密钥配送问题的方法有几种：</p>
<ul>
<li>通过事先共享密钥来解决</li>
<li>通过密钥分配中心来解决</li>
<li>通过Diffie-Hellman密钥交换来解决</li>
<li>通过公钥密码来解决</li>
</ul>
<blockquote>
<h3 id="通过事先共享密钥来解决"><a href="#通过事先共享密钥来解决" class="headerlink" title="通过事先共享密钥来解决"></a>通过事先共享密钥来解决</h3></blockquote>
<p>事先用安全的方式将密钥交给对方，就称为密钥的事先共享。这是密钥配送问题最简单的一种解决方法，但有其局限性。公司内部开发的应用产品，客户端和服务端都是自己开发的，事先共享密钥就很简单，服务端人员生成密钥后直接给到客户端的开发人员就可以了。但这种情况又会带来其他问题，比如密钥在客户端如何才能安全的保存。一般，密钥都是通过硬编码或存为文件的形式保存在客户端的，那么客户端应用一旦被反编译，就很容易窃取到密钥了。</p>
<p>而如果是开放性平台，像微博开放平台、微信开放平台等，要做到事先共享密钥就很有难度了。开发者在开放平台注册的应用，其密钥都是通过平台的管理端给到开发者的，也就是通过了网络，那就存在被窃听的风险了。</p>
<blockquote>
<h3 id="通过密钥分配中心来解决"><a href="#通过密钥分配中心来解决" class="headerlink" title="通过密钥分配中心来解决"></a>通过密钥分配中心来解决</h3></blockquote>
<p>当使用密钥分配中心时，需要通信的双方可以事先在密钥分配中心注册，然后密钥分配中心给每个注册方发送一个密钥，不同注册方的密钥是不同的。那么，当某个发送端需要向某个接收端发送消息时，通信流程如下：</p>
<ol>
<li>发送端向密钥分配中心发起希望与接收端通信的请求；</li>
<li>密钥分配中心随机生成一个会话密钥，该会话密钥是供发送端和接收端在本次通信中使用的临时密钥，我们简称为<strong>TempKey</strong>；</li>
<li>密钥分配中心查询出发送端的密钥，即发送端注册时分配的密钥，我们简称为<strong>SenderKey</strong>；</li>
<li>密钥分配中心使用<strong>SenderKey</strong>对<strong>TempKey</strong>进行加密，加密后的密文称为<strong>CipherTempKeyToSender</strong>，并发送给发送端；</li>
<li>密钥分配中心用同样的方式查询出接收端的密钥，简称为<strong>ReceiverKey</strong>；</li>
<li>密钥分配中心再用<strong>ReceiverKey</strong>对<strong>TempKey</strong>进行加密，加密后的密文称为<strong>CipherTempKeyToReceiver</strong>，并发送给接收端；</li>
<li>发送端对来自密钥分配中心的<strong>CipherTempKeyToSender</strong>，用自己的密钥即<strong>SenderKey</strong>进行解密，得到<strong>TempKey</strong>；</li>
<li>发送端将要发送给接收端的消息用<strong>TempKey</strong>进行加密，然后发送给接收端；</li>
<li>接收端对来自密钥分配中心的<strong>CipherTempKeyToReceiver</strong>，用自己的密钥即<strong>ReceiverKey</strong>进行解密，也得到<strong>TempKey</strong>；</li>
<li>接收端收到发送端的密文后，用<strong>TempKey</strong>对密文进行解密；</li>
<li>通信完毕，发送端和接收端都删除<strong>TempKey</strong>。</li>
</ol>
<p>这个通信过程还挺复杂的，总的来说就是，发送端和接收端通信时是使用密钥分配中心分配的临时密钥进行加密和解密的。这种方案，密钥分配中心的安全性就显得非常重要了。如果攻击者入侵了密钥分配中心，盗取到所有密钥，则后果很严重。</p>
<blockquote>
<h3 id="通过Diffie-Hellman密钥交换来解决"><a href="#通过Diffie-Hellman密钥交换来解决" class="headerlink" title="通过Diffie-Hellman密钥交换来解决"></a>通过Diffie-Hellman密钥交换来解决</h3></blockquote>
<p>在Diffie-Hellman密钥交换中，进行加密通信的双方需要交换一些信息，而这些信息即便被窃听者窃听到也没有问题。根据所交换的信息，双方可以各自生成相同的密钥，而窃听者却无法生成相同的密钥。</p>
<p>虽然这种方法叫“密钥交换”，但实际上双方并没有真正交换密钥，而是通过计算生成出了一个相同的共享密钥。因此，这种方法也称为<strong>Diffie-Hellman密钥协商</strong>。支撑Diffie-Hellman密钥交换算法的是有限群的离散对数问题的复杂度。</p>
<blockquote>
<h3 id="通过公钥密码来解决"><a href="#通过公钥密码来解决" class="headerlink" title="通过公钥密码来解决"></a>通过公钥密码来解决</h3></blockquote>
<p>公钥密码类似于投币寄物柜。首先，将物品放入寄物柜中。然后，投入硬币并拔出钥匙，就可以将寄物柜关闭了。关闭后的寄物柜，没有钥匙是无法打开的。只要有硬币，任何人都可以关闭寄物柜，但寄物柜一旦被关闭，再怎么投币也无法打开。要打开寄物柜只能使用钥匙，而不是硬币。因此可以说，硬币是<strong>关闭寄物柜的密钥</strong>，而钥匙是<strong>打开寄物柜的密钥</strong>。</p>
<p>在公钥密码中，加密和解密的密钥是不同的。只要拥有加密密钥，任何人都可以进行加密，但没有解密密钥是无法解密的。接收者事先将加密密钥发送给发送者，这个加密密钥即便被窃听者获取也没有问题。发送者使用加密密钥对通信内容进行加密并发送给接收者，而只有拥有解密密钥的人（即接收者本人）才能够进行解密。这样一来，就用不着将解密密钥配送给接收者了，也就是说，不存在密钥配送问题了。</p>
<h2 id="公钥密码"><a href="#公钥密码" class="headerlink" title="公钥密码"></a>公钥密码</h2><p>公钥密码中，密钥分为加密密钥和解密密钥两种。加密密钥一般是公开的，因此也被称为<strong>公钥</strong>(public key)。解密密钥则绝对不能公开，因此也称为<strong>私钥</strong>(private key)。公钥和私钥是一一对应的，一对公钥和私钥统称为<strong>密钥对</strong>(key pair)。由公钥加密的密文，只有配对的私钥才能够解密。</p>
<p>使用公钥密码通信时，流程如下：</p>
<img src="/post/reading/20160629/14-53-35.jpg">

<p>那么，密钥对是如何生成的呢？为什么用公钥加密的密文能用私钥解密呢？要理解公钥密码的原理，需要先理解一些数学上的问题，mod运算是基础。</p>
<p>公钥密码是基于数学上困难的问题来保证机密性的，比如利用质因数分解的困难度、mod运算下求离散对数的困难度、mod运算下求平方根的困难度，等等。现在使用最广泛的公钥密码算法RSA就是利用了大整数质因数分解问题的困难度。</p>
<blockquote>
<h3 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h3></blockquote>
<p>要理解RSA算法的原理，就要先理解一些mod运算方面的知识。mod运算，其实就是“除法求余数的运算”，比如：</p>
<ul>
<li>27 mod 12 = 3  表示27除以12的余数等于3</li>
</ul>
<p>加法和乘法都非常简单，比如：</p>
<ul>
<li>(6 + 7) mod 12 = 13 mod 12 = 1</li>
<li>7 * 7 mod 12 = 49 mod 12 = 1 </li>
</ul>
<p>减法和除法则可以看成加法和乘法的逆运算，比如：</p>
<ul>
<li>(7 + N) mod 12 = 0  7加上几除以12的余数为0？</li>
<li>7 * M mode 12 = 1  7乘以几除以12的余数为1？</li>
</ul>
<p>这里，N 和 M 都要求大于等于 0 小于 12。N 还是很容易算出来的，答案是5。而 M 一下子就比较难算出来，可以用暴力破解把0~11都代入 M 计算一下结果，最终可以得到 M = 7。接着，看另一个算式：</p>
<ul>
<li>N * M mod 12 = 1</li>
</ul>
<p>如果没有 mod 12，那 N 和 M 就是互为倒数。此处的话，我们还要加上“在以12为模的世界中”这个条件。在一般的算术中，互为倒数可以写成：</p>
<ul>
<li>N * 1/N = 1</li>
</ul>
<p>那么，在以12为模的世界中，在0到11的数字中，是不是每一个数都存在相应的倒数呢？实际上，mod运算中“某个数是否存在倒数”这个问题，与RSA中“一个公钥是否存在相对应的私钥”这个问题是直接相关的。下表列出了结果：</p>
<img src="/post/reading/20160629/21-54-45.jpg">

<p>存在倒数的只有1、5、7、11，这些数有怎样的性质呢？其实，在 mod 12 的世界中，存在倒数的数，它们和12之间的最大公约数都是1，也可以说是和12互质的数。那么，如果是在 mod 14 的世界中，存在倒数的则有1、3、5、9、11、13。</p>
<p>接着，看看乘方的mod运算又是怎样的。比如，现在要求 7^4 mod 12，最笨的方法就是将7^4直接算出结果，然后除以12求余。而快速的计算方法则是在计算的中间步骤求mod，如下：</p>
<ul>
<li>7^4 mod 12 = 7<em>7</em>7<em>7 mod 12 = ((7*7 mod 12)</em>(7<em>7 mod 12)) mod 12 = ((49 mod 12)</em>(49 mod 12)) mod 12 = 1*1 mod 12 = 1</li>
</ul>
<p>在中间步骤求mod，可以避免计算大整数的乘积。这种在计算过程中求mod来计算乘方的方法，也是RSA的加密和解密算法中所使用的方法。</p>
<p>接着，再看看对数，即乘方的逆运算。mod运算中的对数称为离散对数，比如：</p>
<ul>
<li>7^N mod 13 = 8</li>
</ul>
<p>这里N应该等于几呢？像下面这样依次尝试一遍，可以得到 N = 9：</p>
<img src="/post/reading/20160629/22-17-21.jpg">

<p>当数字很大时，求离散对数就会非常困难，而且非常耗时。到现在也还没有发现能够快速求出离散对数的算法。也因此，有很多公钥算法都运用了离散对数。</p>
<blockquote>
<h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3></blockquote>
<p>RSA是现在使用最广泛的公钥密码算法，但RSA不只用于公钥密码，也用于数字签名。关于数字签名下一篇文章再讲。</p>
<p>在RSA中，明文、密钥和密文都是数字。RSA的加密过程可以用下列公式来表达，其中，Plaintext 指明文，Cipher 指密文：</p>
<ul>
<li><strong>Cipher = Plaintext^E mod N （RSA加密）</strong></li>
</ul>
<p>RSA的密文是对明文的数字的 E 次方求 mod N 的结果。换句话说，就是将明文和自己做 E 次乘法，然后将其结果除以 N 求余数，这个余数就是密文。因此，只要知道 E 和 N 这两个数，任何人都可以完成加密的运算。所以说，E 和 N 是RSA加密的密钥，也就是说，E 和 N 的组合就是密钥。另外，E 是加密(Encryption)的首字母，N 是数字(Number)的首字母。</p>
<p>RSA的解密和加密一样简单，可以用下面的公式来表达，其中，Plaintext 指明文，Cipher 指密文：</p>
<ul>
<li><strong>Plaintext = Cipher^D mod N （RSA解密）</strong></li>
</ul>
<p>对表示密文的数字的 D 次方求 mod N 就可以得到明文。换句话说，将密文和自己做 D 次乘法，再对其结果除以 N 求余数，就可以得到明文。这里的数字 N 和加密时的 N 是相同的。D 和 N 组合起来就是RSA的解密密钥，因此，D 和 N 的组合就是私钥。另外，D 是解密(Decryption)的首字母。</p>
<p>整理一下，RSA的加密和解密如下图：</p>
<img src="/post/reading/20160629/17-04-34.jpg">

<p>由于 E 和 N 是公钥，D 和 N 是私钥，因此求 E、D 和 N 这三个数就是生成密钥对。密钥对的生成步骤如下：</p>
<ol>
<li>求N：N = p * q<br>其中，p、q 是需要事先准备的两个很大的质数。p 和 q 太小的话，密码会变得容易破译，但太大的话计算时间又会变得很长。一般来说，p 和 q 的长度都是512比特以上，N 的长度为1024以上。</li>
<li>求L：L = lcm(p-1, q-1)<br>L 是仅在生成密钥对的过程中使用的数，它是 p-1 和 q-1 的最小公倍数。</li>
<li>求E：1 &lt; E &lt; L &amp;&amp; gcd(E, L) = 1<br>E 是一个比 1 大、比 L 小的数。此外，E 和 L 的最大公约数必须为 1，即 E 和 L 互质，这样可以保证一定存在解密时需要使用的数 D。</li>
<li>求D：1 &lt; D &lt; L &amp;&amp; E * D mod L = 1<br>D 也是是一个比 1 大、比 L 小的数，而且是由数 E 计算得到的。从 E * D mod L = 1 这条公式得知，要保证存在满足条件的 D，就需要保证 E 和 L 的最大公约数为 1。简单来说，E * D mod L = 1 保证了对密文进行解密时能够得到原来的明文。</li>
</ol>
<blockquote>
<h3 id="公钥密码的问题"><a href="#公钥密码的问题" class="headerlink" title="公钥密码的问题"></a>公钥密码的问题</h3></blockquote>
<p>公钥密码虽然可以避免密钥配送问题，但也存在两个很大的问题：</p>
<ol>
<li>公钥密码的处理速度远远低于对称密码；</li>
<li>公钥密码难以抵御中间人攻击。</li>
</ol>
<p>如果用公钥密码去处理很长的消息，那么，公钥密码速度慢的缺点就会显露无疑。所以，一般，不会用公钥密码直接处理消息。而是和对称密码相结合，采用混合密码系统。关于混合密码系统，下面再说。</p>
<p>对于第二个问题，是因为公钥是公开的，任何人都可以获取，也包括攻击者。所谓中间人攻击，就是攻击者混入发送者和接收者中间，对发送者伪装成接收者，对接收者伪装成发送者的攻击方式。如下图所示：</p>
<img src="/post/reading/20160629/09-55-25.jpg">

<p>在这种情况下，就没有机密性可言了，因为发送者用来加密的其实是攻击者的公钥，攻击者拦截到信息后就可以用自己的私钥解密出来，再用之前拦截到的接收者的公钥对伪造的消息加密后发给接收者。</p>
<p>仅靠公钥密码本身，是无法防御中间人攻击的。要防御中间人攻击，还需要一种手段来确认所收到的公钥是否真的属于接收者，这种手段称为认证。针对上面的情况，我们可以使用公钥的证书。关于认证和证书，下一篇文章再讲。</p>
<h2 id="混合密码系统"><a href="#混合密码系统" class="headerlink" title="混合密码系统"></a>混合密码系统</h2><p>混合密码系统是将对称密码和公钥密码的优势相结合的方法，加密消息使用快速的对称密码，而用公钥密码来加密对称密码的密钥。因为对称密码的密钥一般比消息本身要短，因此公钥密码速度慢的问题就可以忽略了。另外，对称密码使用的密钥是临时生成的会话密钥。混合密码系统的加密过程如下图：</p>
<img src="/post/reading/20160629/10-18-43.jpg">

<p>从图中就可得知：</p>
<ol>
<li>会话密钥是随机生成的，因此，每次加密的会话密钥都会不同；</li>
<li>混合密码系统的明文是用对称密码加密的，而加密使用的密钥就是上一步生成的会话密钥；</li>
<li>用公钥密码对会话密钥进行加密，形成了加密后的会话密钥；</li>
<li>将加密后的会话密钥和加密后的消息组合在一起，就是混合密码系统的密文。</li>
</ol>
<p>而解密过程则如下图所示：</p>
<img src="/post/reading/20160629/10-25-49.jpg">

<p>从图中也可得知：</p>
<ol>
<li>将已加密的会话密钥和消息进行分离；</li>
<li>用公钥密码对已加密的会话密钥进行解密，得到会话密钥明文；</li>
<li>用对称密码对已加密的消息进行解密，而解密密钥就是上一步解密出来的会话密钥。</li>
</ol>
<p>那么，怎样才算是一个高强度的混合密码系统呢？混合密码系统运用了伪随机数生成器、对称密码和公钥密码，因此其中每一种技术要素的强度都必须很高，而且，这些技术要素之间的强度平衡也非常重要。</p>
<p>如果伪随机数生成器的算法很差，生成的会话密钥就有可能被攻击者推测出来。会话密钥中哪怕只有部分比特被推测出来也是很危险的，因为会话密钥的密钥空间不大，很容易通过暴力破解来发动攻击。</p>
<p>对称密码被用于加密消息，我们需要使用高强度的对称密码算法，并确保密钥具有足够的长度。此外，还要选择使用合适的分组密码模式。</p>
<p>公钥密码被用于加密会话密钥，同样需要使用高强度的公钥密码算法，并确保密钥具有足够的长度。</p>
<p>另外，公钥密码的强度应该要高于对称密码，因为对称密码的会话密钥被破译只会影响本次通信的内容，而公钥密码一旦被破译，从过去到未来的（用相同公钥加密的）所以通信内容就都能够被破译了。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>本篇文章只是本书第一部分的读书笔记，虽然也有加入了一点自己的看法。第一部分的内容主要是关于保证机密性的密码技术。但信息安全还包括消息完整性、进行认证以及防止否认的技术，这些下面的文章再做总结。</p>
<hr>
<p>扫描以下二维码即可关注订阅号。</p>
<img src="/post/reading/20160629/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/architecture/20160621/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/architecture/20160621/" class="post-title-link" itemprop="url">小钢的架构思考:架构设计</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-06-21 13:30:00" itemprop="dateCreated datePublished" datetime="2016-06-21T13:30:00+08:00">2016-06-21</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-02 11:18:32" itemprop="dateModified" datetime="2019-07-02T11:18:32+08:00">2019-07-02</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/architecture/" itemprop="url" rel="index"><span itemprop="name">architecture</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/architecture/20160621"><strong>http://keeganlee.me/post/architecture/20160621</strong></a><br>微信订阅号：<strong>keeganlee_me</strong><br>写于2016-06-21</p>
<hr>
<p><a href="http://keeganlee.me/post/architecture/20160425">小钢的架构思考:什么是架构</a><br><a href="http://keeganlee.me/post/architecture/20160509">小钢的架构思考:架构规划</a><br><a href="http://keeganlee.me/post/architecture/20160621">小钢的架构思考:架构设计</a></p>
<hr>
<p>最近一个多月因为忙于工作上的项目重构，所以文章一直没能更新。现在，重构终于暂时告一段落，于是，赶紧抽时间把文章写完更新发布。下面进入正文。</p>
<hr>
<p>当<a href="http://keeganlee.me/post/architecture/20160509">架构规划</a>的结果，整理出一堆不同优先级的需求，尤其是质量需求之后，接下来就要思考如何才能最大限度地实现这些需求，这就是架构设计要解决的问题。那么，如何进行架构设计呢？设计到什么程度才合适呢？我从架构思维和架构原则方面来思考架构设计的问题。</p>
<h2 id="架构思维"><a href="#架构思维" class="headerlink" title="架构思维"></a>架构思维</h2><p>这里说的架构思维是指进行架构设计时最高层级的思考方式，比如：面向过程、面向对象、面向切面、面向服务等。</p>
<blockquote>
<h3 id="面向过程-Procedure-Oriented"><a href="#面向过程-Procedure-Oriented" class="headerlink" title="面向过程(Procedure Oriented)"></a>面向过程(Procedure Oriented)</h3></blockquote>
<p>面向过程的设计思路就是将问题分解成一个个步骤，按照步骤一步步执行之后，问题就解决了。每一个步骤就是一个子过程，也可以称为一个模块，子过程还可以继续拆分成更多更细的子过程。因此，面向过程的设计核心就是过程分析、功能分解，一般采用自顶向下、逐步求精的分解方式。一个大的程序可以分解成多个子程序，子程序再分解成多个大模块，大模块再分解成多个小模块，最终分解成一个个函数。</p>
<p>在此我想借用一个象棋对战的例子，例子来源于一篇很老的文章：<a href="http://blog.csdn.net/wanghao72214/article/details/3961250" target="_blank" rel="noopener">架构师之路(4)—详解面向对象</a>。以下是采用面向过程的设计思路分解的对战流程图：</p>
<img src="/post/architecture/20160621/13-46-54.jpg">
<p>将以上每个流程分别用函数实现，问题就解决了。</p>
<p>面向过程的优点主要有两个：一是流程清晰简单；二是性能比较高。尤其是性能，这也是为什么至今很多单片机开发、驱动程序开发、或其他与硬件相关的系统开发等对性能要求很高的软硬件程序依然在用面向过程的方式进行设计和开发。</p>
<p>面向过程的缺点也很明显：一是主程序太重，主程序与模块承担的任务不均衡；二是函数不易扩展，导致其可扩展性、可复用性、可维护性相对都比较差；三是上下层级模块之间的联系太紧密，耦合高，所以模块也难以复用。</p>
<blockquote>
<h3 id="面向对象-Object-Oriented"><a href="#面向对象-Object-Oriented" class="headerlink" title="面向对象(Object Oriented)"></a>面向对象(Object Oriented)</h3></blockquote>
<p>面向过程的思路是“怎么做”，关注于实现细节；而面向对象的思路是“谁来做”，关注于抽象的对象。对象的封装、继承和多态等特性，让我们以更接近现实世界的方式来思考程序设计。面向对象相比面向过程容易实现更好的分离，相应地可扩展性、可复用性、可维护性也会比较高，但同时会牺牲掉一些性能。不过，也因为硬件发展迅猛，所以牺牲的那点性能也不算什么了。</p>
<p>面向对象设计的难点在于抽象，从问题域中抽象出一个个对象，并找出它们之间的关系。好在有SOLID原则和一大堆设计模式指导我们如何更好地设计。也有领域驱动设计的方法论指导我们怎么进行领域建模。</p>
<p>还是象棋对战的例子，用面向对象的设计思路，可以抽象出以下三种对象：</p>
<ol>
<li>棋手：负责行棋，红黑两方行为一致。</li>
<li>棋盘：负责绘制棋盘画面。</li>
<li>裁判：负责判定吃子、犯规和输赢等。</li>
</ol>
<p>三者关系如下图：</p>
<img src="/post/architecture/20160621/13-56-53.jpg">
<p>棋手对象行棋后，棋盘对象根据棋子布局的变化刷新棋盘画面，裁判对象则对棋局进行判定。</p>
<blockquote>
<h3 id="面向切面-Aspect-Oriented"><a href="#面向切面-Aspect-Oriented" class="headerlink" title="面向切面(Aspect Oriented)"></a>面向切面(Aspect Oriented)</h3></blockquote>
<p>面向切面，也就是AOP，是对面向对象的一种扩展，为了弥补面向对象的局限性。面向对象设计主要是对业务领域进行抽象封装，但对于业务领域之外的内容，比如日志记录、权限检查、事务支持等，在没有AOP之前，只能将实现这些功能的代码散布在所有对象层次中，但这些代码与所散布的对象的核心业务功能是没任何关系的。这种做法也导致了大量重复的代码，而且难以复用。AOP就是为了解决这种问题而产生的，将这些与业务领域无关的部分分离出来，以横切面的方式注入系统，从而减少重复代码、减低耦合度、增强扩展性和维护性。</p>
<p>将日志记录、权限检查、事务支持等等使用横切技术分别独立成一个个服务模块，这些模块也称为“横切面”，这样就可以将这些与业务无关的服务从业务核心中解耦出来，就可以将系统划分为两部分：业务核心和通用服务。业务核心依然采用面向对象的思路去设计，而通用服务则可以采用面向切面的思想来实现。</p>
<p>Spring就大量使用了AOP技术，OkHttp的Interceptor也是AOP设计的一种实现。很多场景都可以使用AOP的思想去设计，比如添加统一的Http Request Header，添加统一的登录验证，添加统一的缓存，添加统一的错误处理，等等，只要是通用的功能点基本都可以使用AOP的思想去设计和实现。</p>
<blockquote>
<h3 id="面向服务-Service-Oriented"><a href="#面向服务-Service-Oriented" class="headerlink" title="面向服务(Service Oriented)"></a>面向服务(Service Oriented)</h3></blockquote>
<p>不管是SOA还是现在流行的微服务架构，都是采用面向服务的思维方式。说到面向服务，需要先了解一个概念：<strong>Monolith</strong>，也称为单体架构。在没有SOA思想之前，软件系统将所有功能整合成一个独立的软件包，然后部署在单一的平台上。比如，在J2EE平台，一个软件系统最终会打成一个包含所有功能的WAR包，然后部署到Web容器中。若要扩展的话，则通过复制这个WAR包部署到多个Web容器来实现。这种方式，如果程序需要改动，不管多么微小的改动，都需要重新打包个新的WAR包，并替换掉所有Web容器的旧WAR包。</p>
<p>面向服务的架构思想则是，将系统的不同功能分离成一个个单独的应用程序或组件，统称为服务，不同服务部署在不同容器中，不同服务之间通过一些轻量级的交互机制来通信，如HTTP，RPC等。这样，相比单体架构，功能服务之间明显是松耦合的，扩展也会灵活很多。而且，不同服务还可以用不同编程语言实现，部署到不同平台。</p>
<p>不管是面向过程，面向对象，面向切面，还是面向服务，最本质的区别还是在于看问题的角度不同。而在实际应用中，也不会只使用一种架构思维，而是综合考虑的，系统的不同方面或不同层级可能会用不同的架构思维去思考。比如，一个庞大的复杂系统，整体上可能用面向服务的架构思维去拆解各种服务，业务核心方面的服务可能再用面向对象的架构思维进行建模，通用功能服务还是用面向切面的架构思维来设计，事务流程当然是采用面向过程的架构思维最直观。</p>
<h2 id="架构原则"><a href="#架构原则" class="headerlink" title="架构原则"></a>架构原则</h2><p>架构思维从面向过程，到现在的面向服务，以后也不知道还会出现什么新的思维方式。但无论是何种思维方式，都存在一些共通性的架构原则，可以指导我们如何设计出一个合适的架构。从另一方面来说，架构设计，不管是面向过程、面向对象、面向切面，还是面向服务，无一例外，主要都是在对复杂的系统进行分解。那么，相应地，就需要思考三个问题：分解为哪些？如何分解？分解到什么程度？相对应地，有三个重要原则可以分别为解答这三个问题提供指引。</p>
<blockquote>
<h3 id="关注点分离原则"><a href="#关注点分离原则" class="headerlink" title="关注点分离原则"></a>关注点分离原则</h3></blockquote>
<p>关注点分离原则主要就是为了解决将复杂系统分解为哪些部分的问题，分解出来的部分就是关注点。过程、对象、切面、服务，只是分解的角度（也是关注点）不同而已。将复杂的问题根据不同的关注点分解为多个相对简单的问题，再对每个简单的问题进行分别处理，这就是关注点分离。分离之后，各个关注点相对独立，每个关注点的变化基本不会影响到其他的关注点，即使需要改变，改变的部分也很小。需要扩展时，影响也将会最小化。</p>
<p>关注点分离，最难的在于如何识别出有哪些关注点。要识别出有哪些关注点，需要将复杂系统不同的方方面面抽象成一个个具有清晰明确的边界的概念模型，或为“对象”，或为“组件”，或“切面”，或“服务”，以将复杂问题分解为一个个相对简单的问题。</p>
<p>从不同维度，可以有不同的分离方案。除了上面提到的面向过程、面向对象、面向切面、面向服务等思维角度之外，还有如下图所示的其他几种不同维度，该图引自《软件架构设计》一书中的【<strong>2.1.1 关注点分离之道</strong>】一节：</p>
<img src="/post/architecture/20160621/23-09-11.jpg">
<p>上图分别从功能职责、通用性、大小粒度的不同维度进行分离。从职责维度进行分离，就可以分为三层架构：展现层、业务层、数据层，相应的关注点就是：数据展示、数据加工、数据管理。另外，数据层还可以再分离为网络层和缓存层。从通用性维度来看，就可以分离出技术通用部分、领域通用部分、特定应用部分。一般，使用框架技术就可以用于分离各种不同的通用部分。从大小粒度的维度考虑，无非就是将复杂系统分离为各个子系统，再分离为不同模块，再细分到不同类。</p>
<p>在实际应用中，并不会只采用一种维度，而是多种维度综合考虑，不同部分采用不同维度的分离方案。比如，也许，整体上按职责分离为多层架构，然后，在某些层级根据大小粒度再进行分离，例如将业务层按照不同业务模块进行分离。另外，也会将不同的通用部分进行分离，例如可将技术通用部分的日志记录、领域通用部分的权限检查分别分离出来。</p>
<p><a href="http://www.educity.cn/blog/user2/51639/archives/2009/41580.html" target="_blank" rel="noopener">《架构就是关注点分离》</a>这篇文章则描述了更多关注点分离的例子。</p>
<blockquote>
<h3 id="高内聚低耦合原则"><a href="#高内聚低耦合原则" class="headerlink" title="高内聚低耦合原则"></a>高内聚低耦合原则</h3></blockquote>
<p>系统应该如何分解？或者说关注点应该如何分离？高内聚低耦合原则就可以为该问题提供设计指引。</p>
<p>内聚是指模块内部的功能和元素之间的紧密程度，而耦合则是指模块与模块之间的关联程度。</p>
<p>内聚可分为好多种：功能内聚、顺序内聚、通信内聚、过程内聚、时间内聚、逻辑内聚、偶然内聚。功能内聚是最强最好的内聚，模块内各元素共同协作完成一个单一的功能，这些元素紧密联系、缺一不可。顺序内聚则是指，模块中各个处理元素和同一个功能密切相关，而且这些处理必须顺序执行，通常前一个处理元素的输出时后一个处理元素的输入。顺序内聚的内聚度也比较高，但相比功能内聚，缺点就是可维护性相对差些。偶然内聚则是最弱的内聚，模块内的各元素之间没有任何联系，只是偶然地被凑到一起。</p>
<p>耦合也分为好多种：非直接耦合、数据耦合、标记耦合、控制耦合、外部耦合、公共耦合、内容耦合。非直接耦合表示两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的，其耦合度是最弱的，模块独立性最强。数据耦合表示调用模块和被调用模块之间只传递简单的数据项参数，相当于高级语言中的值传递。标记耦合也称为特征耦合，表示调用模块和被调用模块之间传递的不是简单数据，而是数据结构，像高级语言中的数据名、记录名和文件名等数据结果，这些名字即为标记，其实传递的是地址。控制耦合则表示模块之间传递的不是数据信息，而是控制信息例如标志、开关等，一个模块控制了另一个模块的功能。外部耦合则是指一组模块都访问同一全局简单变量，而且不通过参数表传递该全局变量的信息。内容耦合则是一个模块直接访问另一模块的内容，这是最强的耦合。</p>
<p>高内聚的设计原则是说：一个模块只完成一个单一的功能，尽可能使模块达到功能内聚。<br>低耦合的设计原则是说：若模块间必须存在耦合，应尽量使用数据耦合，少用控制耦合，慎用或有控制地使用公共耦合，并限制公共耦合的范围，尽量避免内容耦合。</p>
<blockquote>
<h3 id="适度设计"><a href="#适度设计" class="headerlink" title="适度设计"></a>适度设计</h3></blockquote>
<p>适度设计原则关注的就是系统分解到什么程度的问题。适度设计就是指设计不要过度，也不要不足。那么，怎样才算设计过度？怎样才算设计不足？一句话，设计过度就是想太多，设计不足就是想太少。感觉好虚，是吧？我也这么觉得。因为，如何判断一个设计是否过度或不足，并没有标准的可量化指标。因此，设计是否适度，更多在于主观的判断。而如何避免设计过度或不足，更多的也在于个人经验积累所形成的直觉。</p>
<p>设计不足相对还比较容易判断，导致设计不足的原因主要有两个：一是因为新手的设计经验不足而导致；二是因为一味追求快速实现产品功能而跳过或大幅度减少了设计而导致。</p>
<p>也有些设计过度比较明显的例子，比如Uncle Bob提出的Clean架构，每个关注点都有着清晰明确的边界，架构真的很清晰，可维护性、可测试性都非常不错，高内聚低耦合。但是，如果将其应用到一个只有两三个开发人员的小团队的小项目中，就会明显发现代码量大而且复杂，每需要添加一个小功能，却需要编写大量代码。这对一个小团队小项目来说，明显不适合。Clean架构比较适用于人员较多的团队，和中大型项目。</p>
<p>因此，判断设计是否适度，不能脱离团队和项目的现状。另外，还有其他现状因素，包括各种商业需求、功能需求和质量需求。大部分情况下，形成过度设计的原因在于：一是过多地考虑了未来可能发生的变化；二是为了追求设计而设计。适度设计，首先应该着眼于当下，当下的需求、当下的开发成本、当下的人员和项目现状；其次才是适当考虑如何应对未来的变化。对于未来的变化，也不是任何可能都要考虑，只需考虑在可预见的未来里有非常大的几率会发生的变化即可，这个非常大的几率可以达到90%以上。比如，已经确定要实现的需求，只是因为优先级问题而稍微延后；比如，已经确定的人员扩充计划；比如，双11要搞活动，交易量将会激增；等等。</p>
<p>也就是说，适度设计的原则，可以总结为：设计应该优先满足当前确定的需求，再满足可预见未来里几乎可以确定会发生的需求。只满足当前需求而不考虑未来，就容易导致设计不足；而过多地考虑未来可能发生的需求，就容易导致设计过度。因此，适度设计需要在当前需求和未来需求之间做好平衡，而我觉得只考虑当前需求和未来几乎确定会发生的需求是最好的平衡点。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>本来计划还想再谈谈架构风格，比如分层架构、MVC\MVP\MVVM、RESTFul、Clean架构等等。但因为这篇文章的进度已经拖了一个多月，不能再拖了。因此，决定本文就此收手，那些架构风格以后有机会再讲吧。</p>
<hr>
<p>扫描以下二维码即可关注订阅号。</p>
<img src="/post/architecture/20160621/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/architecture/20160509/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/architecture/20160509/" class="post-title-link" itemprop="url">小钢的架构思考:架构规划</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-05-09 14:15:00" itemprop="dateCreated datePublished" datetime="2016-05-09T14:15:00+08:00">2016-05-09</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-02 11:18:31" itemprop="dateModified" datetime="2019-07-02T11:18:31+08:00">2019-07-02</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/architecture/" itemprop="url" rel="index"><span itemprop="name">architecture</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/architecture/20160509"><strong>http://keeganlee.me/post/architecture/20160509</strong></a><br>微信订阅号：<strong>keeganlee_me</strong><br>写于2016-05-09</p>
<hr>
<p><a href="http://keeganlee.me/post/architecture/20160425">小钢的架构思考:什么是架构</a><br><a href="http://keeganlee.me/post/architecture/20160509">小钢的架构思考:架构规划</a><br><a href="http://keeganlee.me/post/architecture/20160621">小钢的架构思考:架构设计</a></p>
<hr>
<p><a href="http://keeganlee.me/post/architecture/20160425">上一篇</a>简单聊了下什么是架构，还将架构划分为三个阶段：规划阶段、设计阶段和构建阶段，构建阶段其实也是架构实现的阶段。其实，三个阶段的界限并不明显，而占比最多的是设计阶段；而且，规划和构建阶段其实也会有设计。也可能因此，当我们谈到架构的时候，更多是在谈架构设计。但仔细想想，三个阶段的划分确是合理的。本文先聊聊架构规划。</p>
<h2 id="架构规划"><a href="#架构规划" class="headerlink" title="架构规划"></a>架构规划</h2><p>架构规划做什么呢？我觉得主要是规划好下个阶段架构设计的边界。而影响架构边界的，其实就是需求。需求形成了对架构的约束条件，从而也对架构设计形成了边界。那么，有哪些需求呢？可以分为三大类：商业需求、功能需求和质量需求。</p>
<blockquote>
<h3 id="商业需求"><a href="#商业需求" class="headerlink" title="商业需求"></a>商业需求</h3></blockquote>
<p>商业需求是最高层次的需求，对其含义，我比较赞同温昱在《软件架构设计》中提到的解释：它关注从客户群、企业现状、未来发展、预算、立项、开发、运营、维护在内的整个软件生命周期涉及的商业因素，包括了商业层面的目标、期望和限制等。商业需求一般对架构的影响比较大，对架构产生限制的商业因素也比较多，在此列举一些比较常见的：</p>
<ol>
<li><strong>上市时间</strong>：上市时间限定了系统从设计、开发、测试到上市的时间边界。之前我跟进过一个垂直于大学生市场的应用，上市时间就要求在新生入学前，不然就会错过推广的最佳时期，预留给开发的时间只有两个月。因此，我们只好大部分重用前个项目的元素，包括重用服务端的一些模块，还包括客户端的架构和界面。当然，一般情况下，预留给开发的时间不会这么短，但也不会特别长。架构师需要根据时间长短，平衡各方面需求，做好架构选型。</li>
<li><strong>成本预算</strong>：成本预算就限定了能使用的资源边界。不同架构的开发成本肯定不同，要满足更多功能需求和更多质量需求的架构成本也更高，在预算有限的情况下，只能权衡各种需求，优先满足重要程度高的需求。</li>
<li><strong>人力现状</strong>：100人的开发团队和10人的开发团队，软件的架构会有很大不同。另外，开发团队人员所掌握的技术也会对架构选型有影响。例如，团队里还没有人会用React Native，那现阶段就不适合选择React Native作为App架构的技术基础。</li>
<li><strong>与外围系统的集成</strong>：当需要与外围系统集成时，需要认真考虑集成方法，尤其是外围系统比较老的时候，集成难度可能更高。另外，外围系统的不可控因素一般也比较多，因此，对架构处理这些不可控风险的要求相对也高。</li>
<li><strong>开放性</strong>：封闭的私有系统和开放式系统对架构的要求也不同，一个系统如果选择了开放，那对架构的质量要求更高，对安全性、扩展性、性能等质量属性都应该比封闭时高。</li>
<li><strong>目标市场</strong>：目标用户10万、100万、1000万，不同级别的目标市场，架构也是大有不同。另外，大众市场和垂直的专门市场，架构也同样有区别，较大的专门市场一般都采用产品线的规划方案。</li>
<li><strong>多端支持</strong>：现在移动端普遍支持Android、iOS、Wechat，管理端通常则支持PC Web，如果管理端也要支持Android、iOS、Wechat，或者移动端和管理端还要再支持WindowsPhone、黑莓，甚至再支持VR，则需要投入更多时间和人力，架构上相应也需要做出调整。</li>
<li><strong>期望的系统生存期</strong>：从主观上说，谁都希望自己的系统可以生存很久，但生存期越长，意味着系统的可修改性、可扩展性、可移植性等需要更高。但是，受上市时间、成本预算等因素的制约，再加上软件本身的变化快，所以，客观上，一般也不会期望其生存期太长。当系统不能满足渐增的需求时，基本通过重构来解决。</li>
<li><strong>阶段性计划</strong>：每一个大平台系统普遍都是分阶段完成的，因此，前期阶段的架构设计时就需要考虑好重用性、扩展性、伸缩性、移植性等特性。但因为每个阶段经过市场验证后，需求有可能会变化，所以又不能过度设计，否则就会造成设计浪费，还可能加大了后续阶段架构调整的难度。</li>
<li><strong>国际化</strong>：如果走国际化路线，那架构上就要考虑好对多国语言的支持。</li>
<li><strong>竞争对手</strong>：产品要比竞争对手优秀，那就要在一些关键的功能或质量上超越对方，也意味着在这些方面的架构需要投入更多。</li>
<li><strong>法律法规</strong>：比如，对某些关键字要进行过滤屏蔽，这是天朝独有的，大家懂的。</li>
</ol>
<p>商业需求多种多样，有些需求还可能会相互矛盾，比如，上市时间和成本预算就会和期望的系统生存期可能产生矛盾，期望的生存期越长其成本就会越高，需要投入的时间就会越多，那么，就有可能拖延上市时间。因此，做架构规划时，必须梳理清楚哪些需求是能够被满足的，能被满足的程度如何，需要在各个需求间权衡利弊。另外，商业需求因为是最高层次的需求，因此，相对于功能需求和质量需求，其优先级一般也比较高。</p>
<blockquote>
<h3 id="功能需求"><a href="#功能需求" class="headerlink" title="功能需求"></a>功能需求</h3></blockquote>
<p>功能需求描述了系统应该提供的服务，包括为用户提供的服务，也包括为其他系统提供的服务。而架构主要就是为功能服务的，而功能需求基本与具体的业务相关。因此，要做好功能需求这块的架构，就必须对该业务领域足够了解，这样才能更好地抽象建模。对功能需求的架构规划，主要就是建立业务领域模型。领域模型定下来后，下个阶段的设计必须与领域模型保持一致。</p>
<p>而对功能需求进行领域建模之前，还需先梳理下需求的优先级。因为受商业需求的影响，功能需求也需要权衡。比如，上市时间紧、成本预算低、人力资源也不是很充足的情况下，功能需求只能少不能多。而需要与外围系统集成的时候，也意味着这部分功能不需要自己实现了；但是，如果外围系统无法完全满足需求时，则还需要自己再实现缺失的需求。因此，现阶段需要满足哪些功能需求？需要满足到什么程度？这两个问题确定了之后才能更有效地进行领域建模。</p>
<p>领域建模主要就是要分析清楚每个领域模型和模型之间的关系。还是直接用一个例子来说明吧。假设现在要做一个支持O2O(Online To Offline)的电商平台，以下是经过梳理后的几个关键的功能需求：</p>
<ol>
<li>商家可以在平台发布商品，可以是实体类商品，也可以是服务类商品。</li>
<li>实体类商品支持快递，服务类商品只能到商家门店兑换消费。</li>
<li>用户购买实体类商品时需提供收货信息。</li>
<li>用户购买每个商品时对应生成一个订单。</li>
<li>用户购买的是实体类商品时，可以查看商品的物流信息。</li>
<li>用户购买的是服务类商品时，可以用订单的兑换码到商家门店兑换消费。</li>
</ol>
<p>根据以上需求，可以初步得到相关的领域概念有：商家、商品、实体类商品、服务类商品、物流信息、门店、用户、收货信息、订单、兑换信息。理清这些领域概念之间的关系之后，可以得到类似于下面的领域模型视图：</p>
<img src="/post/architecture/20160509/13-36-06.jpg">
<p>当然，这只是一个很小的例子，实际上的领域模型会比这个例子复杂得多。领域模型确定之后，系统中有多少业务领域、各领域概念之间的关系如何就一清二楚了。</p>
<blockquote>
<h3 id="质量需求"><a href="#质量需求" class="headerlink" title="质量需求"></a>质量需求</h3></blockquote>
<p>质量需求是三类需求中，需求层次最低的，但却是大部分架构师最关注的。纵览那么多架构技术，就会发现，大部分都是为了解决某个或某些质量属性优化的问题。</p>
<p>质量属性常见的有以下这些：</p>
<ul>
<li>性能(Performance)：性能无疑是一个非常重要的特性，尤其在计算资源有限的情况下。但也无需过分追求高性能，从而牺牲其他更重要的特性。关于过度关注性能的问题，这篇文章说得很好：<a href="http://www.cnblogs.com/freeflying/p/4788494.html" target="_blank" rel="noopener">架构之路（二）：性能</a>。</li>
<li>安全性(Security)：安全性一般会和性能相互制约，最明显的例子就是HTTPS，使用HTTPS提高了安全性，但性能就会有所牺牲。很难做到既满足高安全又高性能，因此需要根据具体需求平衡两方面的特性。</li>
<li>可用性(Availability)：也有人称为有效性，一般定义为：可用性 = 系统正常工作时间 / (系统正常工作时间 + 故障维修时间）。此定义就说明了可用性与系统故障有关，故障率高，可用性就低，故障率低，可用性才高。另外，高可用性还说明了系统对故障维修的时间也很短。</li>
<li>易用性(Usability)：易用性很容易和可用性混淆，可用性关注的是系统长时间无故障运行的能力，而易用性关注的则是系统易于使用的能力。</li>
<li>鲁棒性(Robustness)：也称为健壮性、容错性，是指系统在出现了用户非法操作、或软硬件的缺陷导致的异常情况下，系统依然能够正常运行的能力。比如说，系统在输入错误、磁盘故障、网络过载或有意攻击情况下，能否不死机、不崩溃，就是该软件的鲁棒性。</li>
<li>可伸缩性(Scalability)：可伸缩性是指当用户量和数据量增加时，系统维持高服务质量的能力。比如，当并发量为1W时，系统响应时间为1秒，那如果并发量增加到100W时，只要通过增加服务器数量，而无需对代码进行修改即可达到系统响应时间依然为1秒，就说明该系统的可伸缩性高。</li>
<li>互操作性(Interoperability)：互操作性反映了本系统与其他系统交换数据和服务的难易程度。</li>
<li>可扩展性(Extensibility)：也称为灵活性，反映了系统应对变化的能力。在软件开发过程中，需求变更是常有的事，尤其在移动互联网时代，变化是非常频繁的，也因此，可扩展性是移动互联网产品重点考虑的质量需求。</li>
<li>可理解性(Understandability)：可理解性是指开发人员通过源代码和相关文档，了解程序功能、结构和运行方式的难易程度。遵从好的开发规范一般都可以提高可理解性。另外，单一职责原则运用得好，也能大大提高可理解性，所谓“简单就是美”，简单才容易理解。</li>
<li>可测试性(Testability)：简单点说，可测试性就是测试和诊断软件错误的难易程度。比如进行单元测试的难易程度。如果程序包含了复杂的处理逻辑、数据结构、模块关系，可测试性的设计更显得尤为重要。</li>
<li>可复用性(Reusability)：可重用性表明了一个软件组件可以在其他程序中使用的难易程度。一般需要将一个组件抽离成通用性的组件时，对可复用性的要求就会比较高。</li>
<li>可移植性(Portability)：可移植性表明了将软件系统从一个运行环境转移到另一个不同的运行环境的难易程度。</li>
<li>可维护性(Maintainability)：可维护性是指理解、改正、改动、改进软件的难易程度。我觉得，可维护性是保证一个软件系统能够长期生存的最重要的特性，没有之一。对一个可维护性差的系统，久而久之，不断变得牵一发而动全身，变得不可维护，慢慢只能宣布灭亡。</li>
</ul>
<p>理想情况下，谁都希望所有属性都是高质量的，但谁都清楚这是不可能的事。要提高更多质量属性，实现的难度更大，需要付出的成本更高。而且，不同质量属性之间还存在制约关系，比如，提高安全性，一般就会减低性能；提高了性能，还可能减低了可维护性。因此，在实际做架构规划时，必须根据具体需求在各质量属性间权衡优先级。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>现在有不少公司，尤其是创业型的公司，为了快，直接从需求跳到开发，没有架构规划，也没有架构设计。这样的系统，就等于一栋没有打地基的建筑物，其风险自不用说。架构就是软件系统的地基。有一句话说得好，“基础不牢，地动山摇”。</p>
<hr>
<p>扫描以下二维码即可关注订阅号。</p>
<img src="/post/architecture/20160509/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/architecture/20160425/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/architecture/20160425/" class="post-title-link" itemprop="url">小钢的架构思考:什么是架构</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-04-25 17:30:00" itemprop="dateCreated datePublished" datetime="2016-04-25T17:30:00+08:00">2016-04-25</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-02 11:18:34" itemprop="dateModified" datetime="2019-07-02T11:18:34+08:00">2019-07-02</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/architecture/" itemprop="url" rel="index"><span itemprop="name">architecture</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/architecture/20160425"><strong>http://keeganlee.me/post/architecture/20160425</strong></a><br>微信订阅号：<strong>keeganlee_me</strong><br>写于2016-04-25</p>
<hr>
<p><a href="http://keeganlee.me/post/architecture/20160425">小钢的架构思考:什么是架构</a><br><a href="http://keeganlee.me/post/architecture/20160509">小钢的架构思考:架构规划</a><br><a href="http://keeganlee.me/post/architecture/20160621">小钢的架构思考:架构设计</a></p>
<hr>
<p>最近在思考架构方面一些最基本的问题，比如什么是架构？如何评价一个架构的好坏？是否有一些通用的基本原则指引架构设计？在面向对象设计方面，有单一职责、里氏替换、依赖倒置、接口隔离、迪米特、开闭原则等等基本原则；那么，在架构设计方面是否也有类似的基本原则呢？本文就先聊聊第一个问题。</p>
<h2 id="什么是架构"><a href="#什么是架构" class="headerlink" title="什么是架构"></a>什么是架构</h2><p>关于什么是架构，业界从来没有一个统一的定义。Martin Fowler在《企业应用架构模式》中也没有对其给出定义，只是提到能够统一的内容有两点：</p>
<ol>
<li>最高层次的系统分解；</li>
<li>系统中不易改变的决定。</li>
</ol>
<p>《软件架构设计》一书则将架构定义总结为组成派和决策派：</p>
<ul>
<li>组成派：架构=组件+交互：软件系统的架构将系统描述为计算组件及组件之间的交互。</li>
<li>决策派：架构=重要决策集：软件架构是在一些重要方面所作出的决策的集合。</li>
</ul>
<p>而架构的概念最初来源于建筑，因此，我想从建筑的角度去思考这个问题。Wikipedia中，对架构，即Architecture的定义如下：</p>
<blockquote>
<p>Architecture is both the process and the product of planning, designing, and constructing buildings and other physical structures.</p>
</blockquote>
<p>简单翻译就是：架构是规划、设计和构建建筑物或其他物理构筑物的过程和结果。</p>
<p>从上面的定义中可知，首先，架构的最终目标是为了产出建筑物或其他物理构筑物，构筑物可以只是一套房子，也可以是一栋楼盘，抑或是一个小区、商业区，甚至是一个城市。构筑物越大，其架构必然也越复杂。</p>
<p>其次，产出建筑物之前需要经过三个阶段：规划(planning)、设计(designing)和构建(constructing)。这三个阶段其实也是架构的核心了。比如，开发商要建一个住宅小区，首先肯定要对该小区有一个整体的规划吧：小区的建设选址、建设的规模、建设的内容、投资估算、建设周期等等。接着，就要对小区的各方面进行设计了，最高层次的应该是小区的总体布局设计，拆分开的话就是各楼盘的设计、绿化的设计、各种配套设施的设计等等，再细化下去就是各种户型的设计、楼盘内和小区内各种走道的设计等等。最后，构建阶段也就是施工阶段了，是将之前所有的想法转为实际的建筑物的阶段。</p>
<p>最后，架构包含了以上的过程和结果。也就是说，对小区总体规划的过程是架构，规划的结果方案也是架构，小区总体布局的设计、楼盘的设计、户型的设计等等的每个过程也都是架构，每个过程产出的设计方案也是架构，构建阶段的施工图也是架构，可以说，产出建筑物期间的每个过程和结果都是架构。</p>
<p>那么，如果将建筑物换成了软件，那就变成对软件架构的定义了：软件架构是规划、设计和构建软件的过程和结果。</p>
<p>相应地，软件架构的最终目标就是为了产出软件，可以是一个App，也可以是一个平台，如SaaS、PaaS、BaaS等等，甚至还可以是智慧城市这样庞大的生态系统，地球人都知道，越庞大复杂的系统，架构越难。规划阶段更多考虑的是软件的需求，包括业务上的功能性需求和技术上的非功能性需求，如可靠性、可扩展性、可维护性等；此阶段的架构一般为系统架构。设计阶段的工作更多的就是拆分细化，以满足各种需求；此阶段的架构一般为逻辑架构。构建阶段主要就是对软件的实现和部署了；此阶段的架构一般为物理架构。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>其实，对架构的每种定义都没有错，就像《软件架构设计》一书也说过的，只是每个人所看的角度不同而已。从上面的定义中也可知，架构涵盖了软件研发的方方面面，很难有人能够全部都懂，大部分架构师懂得的只是其中的某些方面。一栋高楼大厦也不是一个人完成的。</p>
<p>思考完什么是架构之后，那接下来，就要思考架构怎么做了？这个问题留待后文继续思考。</p>
<hr>
<p>扫描以下二维码即可关注订阅号。</p>
<img src="/post/architecture/20160425/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/architecture/20160404/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/architecture/20160404/" class="post-title-link" itemprop="url">App环境分离的实现:iOS篇</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-04-04 09:00:00" itemprop="dateCreated datePublished" datetime="2016-04-04T09:00:00+08:00">2016-04-04</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-02 11:18:37" itemprop="dateModified" datetime="2019-07-02T11:18:37+08:00">2019-07-02</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/architecture/" itemprop="url" rel="index"><span itemprop="name">architecture</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/architecture/20160404"><strong>http://keeganlee.me/post/architecture/20160404</strong></a><br>微信订阅号：<strong>keeganlee_me</strong><br>写于2016-04-04</p>
<hr>
<p><a href="http://keeganlee.me/post/architecture/20160329">App环境分离的实现:Android篇</a><br><a href="http://keeganlee.me/post/architecture/20160404">App环境分离的实现:iOS篇</a></p>
<hr>
<p>说到App环境分离在iOS的实现，我曾在iOS技术群里问过：如何实现在同一台手机能同时安装同个应用的测试和生产版本？应用名称要有区分，图标也要有所区别。不要手动修改Bundle id和应用名称，也不要手动替换图标，更不要维护两个项目。如何才能简单地实现？</p>
<p>结果发现很多人都不知道该怎么实现。其实，实现方案很简单，只要建立多个Target即可。当然，有些细节问题要注意，不然会出错。接下来，看如何一步步地实现环境分离。</p>
<h2 id="复制Target"><a href="#复制Target" class="headerlink" title="复制Target"></a>复制Target</h2><p>关于Xcode中Target的概念，文档中有这么一段说明：</p>
<blockquote>
<p>A target specifies a product to build and contains the instructions for building the product from a set of files in a project or workspace. A target defines a single product; it organizes the inputs into the build system—the source files and instructions for processing those source files—required to build that product. Projects can contain one or more targets, each of which produces one product.</p>
</blockquote>
<p>即是说，每个Target代表一个编译的产品。每个Target，可以有不同的编译源文件和资源文件。那么，实现环境分离的方案，就是分别建立测试环境和生产环境的两个Target。默认的Target作为生产环境的Target，在此基础上复制多一个Target作为测试环境的Target。</p>
<p>如下图，选择默认的Target，从右键菜单中选择Duplicate，就可以复制出一个新的Target了。</p>
<img src="/post/architecture/20160404/21-33-15.jpg">

<p>新Target默认名称为<strong>productname copy</strong>。复制完成后，不只是TARGETS列表中多出了名为<strong>productname copy</strong>的新Target，同时也会为该新Target生成名为<strong>productname copy</strong>的新的scheme，以及在项目的根目录下生成<strong>productname copy-Info.plist</strong>文件。</p>
<h2 id="更名Target"><a href="#更名Target" class="headerlink" title="更名Target"></a>更名Target</h2><p>不喜欢<strong>productname copy</strong>这样的名字，<strong>productnameBeta</strong>这样的名字才是测试版本该有的名字。那么，需要改名的地方有三处：target名称、scheme名称、plist文件名称。</p>
<p>修改target名称很简单，只要在TARGETS列表中选中后，再点击一下即可编辑修改名称。修改scheme则可以在Xcode左上角的Run\Stop按钮右边的scheme列表菜单中选择Manage Schemes，打开弹出框，如下图，则可将<strong>productname copy</strong>修改为<strong>productnameBeta</strong></p>
<img src="/post/architecture/20160404/21-40-10.jpg">
<img src="/post/architecture/20160404/21-38-25.jpg">
<p>plist文件则修改为<strong>productnameBeta-Info.plist</strong>，同时，我还将其移到与默认的Info.plist文件在同个目录下。不只是在同一个分组下，也是在同一个物理目录下。改完plist文件后，还需要修改<strong>productnameBeta</strong>的Target的<strong>Info.plist File</strong>设置，该属性设置了相应Target绑定的plist文件是哪个。该属性值本来为<strong>productname copy-Info.plist</strong>，现需要更改为<strong>productname/productnameBeta-Info.plist</strong>。</p>
<h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>接下来，就要修改Target的配置，实现真正的环境分离了。默认的<strong>productname</strong>的Target，作为生产版本，基本不需要改动，需要改的是作为测试版的<strong>productnameBeta</strong>。</p>
<p>首先，修改<strong>productnameBeta</strong>的Bundle id，在原有的基础上添加后缀“.beta”，以实现能和生产版同时安装在同一台设备上。</p>
<p>接着，修改<strong>Bundle display name</strong>，可在原有名称的基础上添加后缀“Beta”，以实现和生产版应用名称上的区分。</p>
<p>然后，需要更换图标了。默认会使用<strong>AppIcon</strong>这一项Assets，但AppIcon是给生产版设置的图标，既然测试版要使用不同图标，那就需要新建一套新的App Icon，如下图：</p>
<img src="/post/architecture/20160404/22-32-51.jpg">
<p>新建的App Icon将其命名为<strong>AppIcon-Beta</strong>，放置测试版的图标。并将<strong>productnameBeta</strong>的App Icons Source指定为新建的<strong>AppIcon-Beta</strong>。至此，图标也与生产版的有所区别了。</p>
<h2 id="判别Target"><a href="#判别Target" class="headerlink" title="判别Target"></a>判别Target</h2><p>那么，设置了不同Target后，代码上可能需要根据不同Target做不同处理，因此，需要在代码上能判断当前编译的是哪个Target。这可以通过预编译宏来区分。例如，我们在<strong>productnameBeta</strong>的Build Settings中，将<strong>Preprocessor Macros</strong>属性值设置为BETA，也就是为<strong>productnameBeta</strong>定义了一个预编译宏，宏名称为BETA。</p>
<img src="/post/architecture/20160404/08-42-13.jpg">

<p>然后，在代码中可以通过如下预编译指令判断当前是在哪个Target下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef BETA</span><br><span class="line">    // 测试版需要执行的代码</span><br><span class="line">#else</span><br><span class="line">    // 默认生产版需要执行的代码</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>通过多个Target可以实现环境的分离，本文的实现很简单。而关于Target的用法也不只限于此，若想了解Target更多高级用法，可查询相关资料，在此就不展开了。</p>
<hr>
<p>扫描以下二维码即可关注订阅号。</p>
<img src="/post/architecture/20160404/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Keegan小钢</p>
              <div class="site-description motion-element" itemprop="description">分享钢哥人生路上的点点滴滴</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Keegan小钢</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.1.2</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/affix.js?v=7.1.2"></script>

  <script src="/js/schemes/pisces.js?v=7.1.2"></script>




  

  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
