<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="分享钢哥人生路上的点点滴滴">
<meta name="keywords" content="个人成长 全栈 区块链">
<meta property="og:type" content="website">
<meta property="og:title" content="Keegan小钢">
<meta property="og:url" content="https://keeganlee.me/index.html">
<meta property="og:site_name" content="Keegan小钢">
<meta property="og:description" content="分享钢哥人生路上的点点滴滴">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Keegan小钢">
<meta name="twitter:description" content="分享钢哥人生路上的点点滴滴">





  
  
  <link rel="canonical" href="https://keeganlee.me/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Keegan小钢</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Keegan小钢</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">钢哥的个人博客</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/default/20200106/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/default/20200106/" class="post-title-link" itemprop="url">2020年第一篇，聊聊钱从哪里来？</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-01-06 16:58:26 / 修改时间：21:06:31" itemprop="dateCreated datePublished" datetime="2020-01-06T16:58:26+08:00">2020-01-06</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/default/" itemprop="url" rel="index"><span itemprop="name">default</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/default/20200106"><strong>http://keeganlee.me/post/default/20200106</strong></a><br>微信公众号：名称：Keegan小钢；微信号：keeganlee_me<br>写于2020-01-06</p>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>每年我都会观看罗胖（罗振宇）的跨年演讲<strong>《时间的朋友》</strong>，今年也不例外。看完演讲后，第二天就在京东买了首发的三本新书：<strong>《变量2》《钱从哪里来》《中国优势》</strong>。这几天，抽空先读完了香帅老师的《钱从哪里来》，提高了一些认知，打算再结合自己的一些观察和思考，聊聊一些观点。</p>
<p>钱从哪里来？这应该是我们每个普通人都关心的问题。香帅老师的书主要是通过大量的数据、案例和调研，做了汇总和整理，最终梳理出一份 2020 年适合普通人的财富解决方案，一个财富逻辑的“罗盘”。书的内容主要从<strong>职业方向、城市选择、资产配置</strong>这些大方向的决策上给我们提供了指引，而我接下来也将从这几个维度去展开，聊聊我的一些思考。</p>
<h2 id="职业方向"><a href="#职业方向" class="headerlink" title="职业方向"></a>职业方向</h2><p>我们都知道，2019 年的经济形势不太好，拖欠工资、裁员、倒闭的公司比比皆是。其中，除了小创业公司之外，也包括一些经营了多年的独角兽企业，比如经营了 7 年的团贷网，还有经营了 11 年之久的尚品网，都在 2019 年死亡了。还有熊猫直播、麦子金服、乐蜂网等，都在死亡名单中。裁员的公司就更多了，就说年底爆出的华为裁 7000 人，其中大部分是 35 岁以上员工。话说，今年我也将要迈进 35 岁大门了。</p>
<p>2019 年，猪肉上涨、物价上涨、房价上涨，唯独工资没涨，不少人还因为被裁反而降薪了。毕业几年的害怕被裁，毕业十几年的也害怕被裁。2020年，在职业方向上该如何选择，才不会有被裁的风险或能减低被裁的风险呢？我觉得可以同时发展两条路，<strong>主业</strong>和<strong>副业</strong>。</p>
<p>首先，不管是主业还是副业，从大的方向来说，都应该选择<strong>低危职业</strong>。这里所说的低危职业，主要是指难以被<strong>人工智能</strong>取代的职业，包括职业理疗师、小学教师、软件工程师、保姆、美容师等。没错，保姆也属于低危职业，而且保姆收入一般还不低。能被人工智能取代的职业则属于<strong>高危职业</strong>，比如电话销售员、收银员、出纳员、服务员、股票交易员等。</p>
<p>难以被人工智能取代的技能主要有三类：社交智慧、创造力、感知和操作能力。</p>
<ul>
<li><strong>社交智慧</strong>：包括社交洞察力、谈判能力、同情心等社交和情感能力</li>
<li><strong>创造力</strong>：包括原创力和艺术审美能力</li>
<li><strong>感知和操作能力</strong>：主要指手指灵敏度、协调操作能力和应付复杂工作环境的能力</li>
</ul>
<p>因此，我们要选择发展的主业和副业，都应该要具备这三类技能中至少一类。</p>
<p>接着，选定大方向之后，还要进一步规划好自己的职业发展路径，不能安逸、不能停止进步，否则，不管是初出茅庐的新人还是具有多年经验的老人，只要是平庸之辈，就难以立足。优胜劣汰虽然残酷，但却是事实。就说程序猿们，如果过了 35 岁，依然还只是基层写代码的，那公司不裁你还裁谁呢。我自己平时招聘开发人员，年龄过大的都直接不考虑的。</p>
<p>最后，需要注意，副业只是辅助，切记不要因为发展副业而荒废了主业。理想情况是，副业能为主业助力，能带动主业的提升。不过，也有些人的副业发展迅速，当副业收入超越主业之后，可能会将副业升级为主业。另外，副业一开始是很难赚到钱的，发展副业需要坚持。</p>
<p>关于如何发展副业，我推荐一本书，安晓辉的《副业赚钱之道》，年底刚出版的新书，我看过了，挺不错，尤其适合技术人员。</p>
<h2 id="城市选择"><a href="#城市选择" class="headerlink" title="城市选择"></a>城市选择</h2><p>除了职业，选择在哪座城市打拼和生活，也会决定我们不同的人生方向。北上广深这样的一线大城市，薪资高、机会多、资源多，不管是工作还是创业，都是大部分人的首选之地。</p>
<p>但这些地方的房价高、消费高、加班多、压力大，因此，近些年也不断有人逃离这些一线城市，而去往二线城市，甚至漂往远方出国。不过，根据京东近期发布的<strong>《2019基于京东大数据的中国人口迁移和城镇化发展研究报告》</strong>显示，相当一部分人只是从一个一线城市去往另一个一线城市，上海、广州、深圳人口迁入来源最多的城市均是北京。另外，杭州、成都、重庆、长沙等二线城市人口净流入强劲，而哈尔滨、大连、沈阳等城市人口流出却非常严重。净流入强劲的城市具有收入增速快、产业升级加速、人才政策力度大等特征。因此，杭州、成都、重庆、长沙等这些强二线城市也被称为了<strong>新一线</strong>。</p>
<p>对于刚毕业或工作几年但还没有家室的人来说，选择一个城市更多考虑的还是机会和财富增长的速度。但对于有家室有小孩的人来说，要考虑的因素就更多了，比如户口问题、小孩读书问题等。对于逃离大城市的人，有各种各样的理由，比如空气质量太差、房价太高、996 太变态、离家太远、小孩上不起学等等。</p>
<p>选择哪个城市无所谓对错，关键在于是否适合自己。不说别人，就说我自己。我 2009 年毕业后就长期在广州，在广州上大学、工作、成家，本来觉得应该会在广州定居了。2017 年下旬开始计划进军区块链，但发现，在广州，区块链方面的机会其实并不多，找了几次，没找到适合自己的机会。相比之下，深圳的机会则多得多。刚好，2018 年年初，有朋友给我引荐了一个深圳的机会，做去中心化交易所，正是适合我的机会，于是接了下来，年后就举家搬到深圳来了。这两年在深圳兜兜转转，虽然过得有些艰难，但发现深圳这边的机会明显比广州多很多，而且，资源也多，这两年结识了不少优质的人脉资源。至于房价高的问题，以后有钱就买，没钱就继续租房呗。另外，我也不想当房奴，所以我不会为了买房把全部身家都填进去。至于孩子教育问题，深圳那么多学校，不是都需要有户口有学区房才能上的，如果为了一个破旧的学区房花几百上千万，我还不如送小孩去读国际学校，甚至送出国，比如送去新加坡，新加坡的幼儿教育比国内好太多了。</p>
<p>其实，核心在于，我有我的梦想、目标，而目前留在深圳是有助于我去实现我的追求的，所以我不会因为各种困难而选择逃离。</p>
<h2 id="资产配置"><a href="#资产配置" class="headerlink" title="资产配置"></a>资产配置</h2><p>说到资产，第一个要聊的就是房地产。2019 年的房地产其实产生了分化，我就直接举两个案例。第一个案例，深圳市南山区深圳湾翡翠海岸一套 89 平方米的房子从 1650 万元的高位下跌至 270 万元成交。第二个案例，也是在深圳的，百花片区国城花园，43.5 平方米的 1 居室总价 1000 万元，单价达到 23 万元/平方米，而 103 平方米的 3 居室总价 1500 万元，单价为 14.6 万元/平方米，比 1 居室的单价还低了将近 10 万。</p>
<p>一个是靠海的海景房，一个是在市区的学区房，我们就只思考一个问题：哪个价值大？注意，我说的是「<strong>价值</strong>」，而不是「<strong>价格</strong>」。如果想不通这个问题，就无法理解上面的结果。</p>
<p>这也明显意味着房地产普涨的时代已经结束了，以后买房要看真实价值。</p>
<p>房地产之后再来聊聊资本市场，包括股票、债券、数字资产等。香帅老师是看多 2020 年中国的资本市场的，我也同样看多。</p>
<p>另外，我还看好区块链以及一些数字资产。2019 年，我因为玩合约，亏空了手上所有的币。2020 年，我将会再配置一些数字资产，如比特币、ATOM，但不会再玩合约了，只会囤现货。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>2020 年，我要打造多个收入渠道，除了继续提高主业收入，再发展副业应对未知的风险，以及屯点优质的数字资产等待升值。</p>
<hr>
<p>扫描以下二维码即可关注公众号（公众号名称：Keegan小钢）</p>
<img src="/post/default/20200106/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/matching/20191204/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/matching/20191204/" class="post-title-link" itemprop="url">撮合引擎开发:完结篇</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-04 12:23:09" itemprop="dateCreated datePublished" datetime="2019-12-04T12:23:09+08:00">2019-12-04</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-16 09:52:21" itemprop="dateModified" datetime="2019-12-16T09:52:21+08:00">2019-12-16</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/matching/" itemprop="url" rel="index"><span itemprop="name">matching</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/matching/20191204"><strong>http://keeganlee.me/post/matching/20191204</strong></a><br>微信公众号：名称：Keegan小钢；微信号：keeganlee_me<br>写于2019-12-04</p>
<hr>
<p><a href="http://keeganlee.me/post/matching/20191117">撮合引擎开发：开篇</a><br><a href="http://keeganlee.me/post/matching/20191118">撮合引擎开发：MVP版本</a><br><a href="http://keeganlee.me/post/matching/20191119">撮合引擎开发：数据结构设计</a><br><a href="http://keeganlee.me/post/matching/20191121">撮合引擎开发：对接黑箱</a><br><a href="http://keeganlee.me/post/matching/20191127">撮合引擎开发：解密黑箱流程</a><br><a href="http://keeganlee.me/post/matching/20191130">撮合引擎开发：流程的代码实现</a><br><a href="http://keeganlee.me/post/matching/20191202">撮合引擎开发：缓存和MQ</a><br><a href="http://keeganlee.me/post/matching/20191203">撮合引擎开发：日志输出</a><br><a href="http://keeganlee.me/post/matching/20191204">撮合引擎开发：完结篇</a></p>
<hr>
<p>本小节是该系列文章的最后一篇了，将讲解剩下的一些东西，包括交易委托账本中订单队列的实现逻辑、更多订单类型的实现逻辑。另外，不少朋友在问，完结后所有代码是否会开源放上 Github？我只能说，长期大概率会开源，但短期内还没打算开源。</p>
<h2 id="订单队列"><a href="#订单队列" class="headerlink" title="订单队列"></a>订单队列</h2><p>交易委托账本其实就是由两个订单队列组成的，一个买单队列，一个卖单队列。任何对交易委托账本的查询和操作，实际上都是查询和操作这两个队列。订单队列的设计也直接影响了撮合的性能，前面文章讲数据结构设计时也有简单聊了订单队列的设计，我们主要是用二维链接结合 Map 来保存所有订单的，依赖的是 <strong>container/list</strong> 包。</p>
<p>订单队列的结构体如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> orderQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">	sortBy     enum.SortDirection</span><br><span class="line">	parentList *list.List</span><br><span class="line">	elementMap <span class="keyword">map</span>[<span class="keyword">string</span>]*list.Element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>sortBy</strong> 指定价格排序的方向，买单队列是降序的，而卖单队列则是升序的。<strong>parentList</strong> 保存整个二维链表的所有订单，第一维以价格排序，第二维以时间排序。<strong>elementMap</strong> 则是 Key 为价格、Value 为第二维订单链表的键值对。</p>
<p>初始化函数就比较简单了，对几个字段赋值而已，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *orderQueue)</span> <span class="title">init</span><span class="params">(sortBy enum.SortDirection)</span></span> &#123;</span><br><span class="line">	q.sortBy = sortBy</span><br><span class="line">	q.parentList = list.New()</span><br><span class="line">	q.elementMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*list.Element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了初始化函数，还提供了另外五个函数：</p>
<ul>
<li><strong>addOrder(order)</strong>：添加订单</li>
<li><strong>getHeadOrder()</strong>：读取头部订单</li>
<li><strong>popHeadOrder()</strong>：读取并删除头部订单</li>
<li><strong>removeOrder(order)</strong>：移除订单</li>
<li><strong>getDepthPrice(depth)</strong>：读取深度价格</li>
</ul>
<p>以上五个函数就只有第一个函数会比较复杂，为了让处理流程更容易理解，我就不贴代码了，画一个完整的流程图给大家看看：</p>
<img src="/post/matching/20191204/orderQueue-addOrder.png">

<p>这个流程确实有一点复杂，可以多看几遍好好消化，最好自己动手将其转为代码实现。</p>
<p>其他几个函数就简单了，关于最后一个函数需要补充说明一下。读取深度价格是为了方便处理 market-opponent、market-top5、market-top10 等类型的订单时判断上限价格。请看该函数的代码以理解该函数的逻辑和用法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *orderQueue)</span> <span class="title">getDepthPrice</span><span class="params">(depth <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> q.parentList.Len() == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	p := q.parentList.Front()</span><br><span class="line">	i := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> ; i &lt; depth; i++ &#123;</span><br><span class="line">		t := p.Next()</span><br><span class="line">		<span class="keyword">if</span> t != <span class="literal">nil</span> &#123;</span><br><span class="line">			p = t</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	o := p.Value.(*list.List).Front().Value.(*Order)</span><br><span class="line">	<span class="keyword">return</span> o.Price.String(), i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多种订单类型"><a href="#多种订单类型" class="headerlink" title="多种订单类型"></a>多种订单类型</h2><p>我们引擎总共支持了六种订单类型，之前的文章有简单介绍过，但没有深入讲解这几种不同类型的具体业务逻辑应该是怎样的，因此，在此将这部分内容补充上。</p>
<h3 id="1-limit"><a href="#1-limit" class="headerlink" title="1. limit"></a>1. limit</h3><p>普通限价是最简单的，前文也已经展示过代码实现，为了加深理解，我再给大家画一张图：</p>
<img src="/post/matching/20191204/limit.png">

<p>处理逻辑就是：</p>
<ol>
<li>判断新订单是买单还是卖单。</li>
<li>如果是买单，那从 OrderBook 中读取出头部卖单，即卖单队列中的头部订单；如果是卖单，那从 OrderBook 中读取出头部买单，即买单队列中的头部订单。</li>
<li>新订单为买单时，如果头部订单为空，或者新订单小于头部订单，即无法成交，那就把新订单添加到买单队列中，处理结束；新订单为卖单时，如果头部订单为空，或者新订单大于头部订单，即无法成交，那就把新订单添加到卖单队列中，处理结束。</li>
<li>否则，符合匹配条件，新订单和头部订单进行撮合成交。</li>
<li>撮合完成后，如果新订单剩余数量为零则结束，如果还大于零，则回到第2步继续取下一个头部订单，如此循环。</li>
</ol>
<h3 id="2-limit-ioc"><a href="#2-limit-ioc" class="headerlink" title="2. limit-ioc"></a>2. limit-ioc</h3><p>IOC 限价与普通限价不同的地方只有一个，如果新订单和头部订单不匹配时，普通限价单会被添加到订单队列中，而 IOC 限价则是作撤单处理，请看下图：</p>
<img src="/post/matching/20191204/limit-ioc.png">

<h3 id="3-market"><a href="#3-market" class="headerlink" title="3. market"></a>3. market</h3><p>默认市价单的逻辑也比较简单，它不需要判断价格，只要头部订单不为空，就直接和头部订单匹配成交，其处理逻辑如下图：</p>
<img src="/post/matching/20191204/market.png">

<h3 id="4-market-top5-market-top10"><a href="#4-market-top5-market-top10" class="headerlink" title="4. market-top5/market-top10"></a>4. market-top5/market-top10</h3><p>最优五档/十档市价单与默认市价单的逻辑也是类似的，不同点在于：默认市价的成交价格没有上限或下限，但最优五档/十档市价则存在价格上限或下限，超过上下限的委托单不会成交。画图太累，还是直接贴代码吧，以下是处理买单的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dealBuyMarketTop</span><span class="params">(order *Order, book *orderBook, lastTradePrice *decimal.Decimal, depth <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	priceStr, _ := book.getSellDepthPrice(depth)</span><br><span class="line">	<span class="keyword">if</span> priceStr == <span class="string">""</span> &#123;</span><br><span class="line">		cancelOrder(order)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	limitPrice, _ := decimal.NewFromString(priceStr)</span><br><span class="line">LOOP:</span><br><span class="line">	headOrder := book.getHeadSellOrder()</span><br><span class="line">	<span class="keyword">if</span> headOrder != <span class="literal">nil</span> &amp;&amp; limitPrice.GreaterThanOrEqual(headOrder.Price) &#123;</span><br><span class="line">		matchTrade(headOrder, order, book, lastTradePrice)</span><br><span class="line">		<span class="keyword">if</span> order.Amount.IsPositive() &#123;</span><br><span class="line">			<span class="keyword">goto</span> LOOP</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		cancelOrder(order)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-market-opponent"><a href="#5-market-opponent" class="headerlink" title="5. market-opponent"></a>5. market-opponent</h3><p>最后一种类型，对手方最优价，该类型只与对手方一档的价位成交，但与最优五档/十档还有一点不一样：最优五档/十档未成交的部分是作撤单处理的，而对手方最优价最后未成交的部分则是转为限价单。请看代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dealBuyMarketOpponent</span><span class="params">(order *Order, book *orderBook, lastTradePrice *decimal.Decimal)</span></span> &#123;</span><br><span class="line">	priceStr, _ := book.getSellDepthPrice(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">if</span> priceStr == <span class="string">""</span> &#123;</span><br><span class="line">		cancelOrder(order)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	limitPrice, _ := decimal.NewFromString(priceStr)</span><br><span class="line">LOOP:</span><br><span class="line">	headOrder := book.getHeadSellOrder()</span><br><span class="line">	<span class="keyword">if</span> headOrder != <span class="literal">nil</span> &amp;&amp; limitPrice.GreaterThanOrEqual(headOrder.Price) &#123;</span><br><span class="line">		matchTrade(headOrder, order, book, lastTradePrice)</span><br><span class="line">		<span class="keyword">if</span> order.Amount.IsPositive() &#123;</span><br><span class="line">			<span class="keyword">goto</span> LOOP</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		order.Price = limitPrice</span><br><span class="line">		order.Type = enum.TypeLimit</span><br><span class="line">		book.addBuyOrder(order)</span><br><span class="line">		cache.UpdateOrder(order.ToMap())</span><br><span class="line">		log.Info(<span class="string">"engine %s, a order has added to the orderbook: %s"</span>, order.Symbol, order.ToJson())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2><p>至此，整个系列就此完结。不过，我的撮合程序依然会继续迭代升级，另外，也将开始开发其他组件，将会和当前这个撮合引擎结合来用。欢迎关注后续动态。</p>
<hr>
<p>扫描以下二维码即可关注公众号（公众号名称：Keegan小钢）</p>
<img src="/post/matching/20191204/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/matching/20191203/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/matching/20191203/" class="post-title-link" itemprop="url">撮合引擎开发:日志输出</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-03 10:32:34" itemprop="dateCreated datePublished" datetime="2019-12-03T10:32:34+08:00">2019-12-03</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-16 09:44:59" itemprop="dateModified" datetime="2019-12-16T09:44:59+08:00">2019-12-16</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/matching/" itemprop="url" rel="index"><span itemprop="name">matching</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/matching/20191203"><strong>http://keeganlee.me/post/matching/20191203</strong></a><br>微信公众号：名称：Keegan小钢；微信号：keeganlee_me<br>写于2019-12-03</p>
<hr>
<p><a href="http://keeganlee.me/post/matching/20191117">撮合引擎开发：开篇</a><br><a href="http://keeganlee.me/post/matching/20191118">撮合引擎开发：MVP版本</a><br><a href="http://keeganlee.me/post/matching/20191119">撮合引擎开发：数据结构设计</a><br><a href="http://keeganlee.me/post/matching/20191121">撮合引擎开发：对接黑箱</a><br><a href="http://keeganlee.me/post/matching/20191127">撮合引擎开发：解密黑箱流程</a><br><a href="http://keeganlee.me/post/matching/20191130">撮合引擎开发：流程的代码实现</a><br><a href="http://keeganlee.me/post/matching/20191202">撮合引擎开发：缓存和MQ</a><br><a href="http://keeganlee.me/post/matching/20191203">撮合引擎开发：日志输出</a><br><a href="http://keeganlee.me/post/matching/20191204">撮合引擎开发：完结篇</a></p>
<hr>
<h2 id="日志需求"><a href="#日志需求" class="headerlink" title="日志需求"></a>日志需求</h2><p>我们都知道日志在一个程序中有着重要的作用，撮合引擎也同样需要一个完善的日志输出功能，以方便调试和查询数据。</p>
<p>对一个撮合引擎来说，需要输出的日志主要有以下几类：</p>
<ol>
<li>程序启动的日志，包括连接 Redis 成功的日志、Web 服务启动成功的日志；</li>
<li>接口请求和响应数据的日志；</li>
<li>启动了某引擎的日志；</li>
<li>关闭了某引擎的日志；</li>
<li>订单被添加到 orderBook 的日志；</li>
<li>成交记录的日志；</li>
<li>撤单结果的日志。</li>
</ol>
<p>另外，撮合引擎产生的日志会非常多，所以还应该做日志分割，按日期分割是最常用的日志分割方式，所以我们也同样将不同日期的日志分割到不同日志文件保存。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>首先，我们都知道日志是有分级别的，多的比如 log4j 定义了 8 种级别的日志。不过，最常用的就 4 种级别，优先级从低到高分别为：<strong>DEBUG、INFO、WARN、ERROR</strong>。一般，不同环境会设置不同的日志级别，如 DEBUG 级别一般只在开发和测试环境才设置，生产环境则会设置为 INFO 或更高级别。当设置为高级别时，低级别的日志消息是不会打印出来的。那为了打印不同级别的日志消息，可以提供不同级别的打印函数，比如提供 <strong>log.Debug()、log.Info()</strong> 等函数。</p>
<p>其次，日志需要输出到文件保存，因此，就需要指定文件保存的目录、文件名和文件对象。一般，保存的文件目录和运行程序应该放在一起，所以，指定的文件目录最好是相对路径。</p>
<p>另外，文件还要根据日期做分割，即不同日期的日志消息要保存到不同的日志文件，那么，自然要记录下当前日志的日期。以及需要定时监控，当检测到最新日期跟当前日志的日期相比已经跨日了，说明需要进行日志分割了，那就将当前的日志文件进行备份，并创建新文件用来保存新日期的日志消息。</p>
<p>最后，日志消息写入文件的话，那就少不了耗时的 I/O 操作，如果用同步方式写日志，无疑会减低撮合性能，因此，最好选用异步方式写日志，可以用带缓冲的通道实现。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>我重新自定义了一个 log 包，并创建了 log.go 文件，所有代码都写在该文件中。</p>
<p>第一步，先定义几种日志等级，直接定义成枚举类型，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LEVEL <span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	DEBUG LEVEL = <span class="literal">iota</span></span><br><span class="line">	INFO</span><br><span class="line">	WARN</span><br><span class="line">	ERROR</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>第二步，定义日志的结构体，其包含的字段比较多，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FileLogger <span class="keyword">struct</span> &#123;</span><br><span class="line">	fileDir        <span class="keyword">string</span>         <span class="comment">// 日志文件保存的目录</span></span><br><span class="line">	fileName       <span class="keyword">string</span>         <span class="comment">// 日志文件名（无需包含日期和扩展名）</span></span><br><span class="line">	prefix         <span class="keyword">string</span>         <span class="comment">// 日志消息的前缀</span></span><br><span class="line">	logLevel       LEVEL          <span class="comment">// 日志等级</span></span><br><span class="line">	logFile        *os.File       <span class="comment">// 日志文件</span></span><br><span class="line">	date           *time.Time     <span class="comment">// 日志当前日期</span></span><br><span class="line">	lg             *log.Logger    <span class="comment">// 系统日志对象</span></span><br><span class="line">	mu             *sync.RWMutex  <span class="comment">// 读写锁，在进行日志分割和日志写入时需要锁住</span></span><br><span class="line">	logChan        <span class="keyword">chan</span> <span class="keyword">string</span>    <span class="comment">// 日志消息通道，以实现异步写日志</span></span><br><span class="line">	stopTickerChan <span class="keyword">chan</span> <span class="keyword">bool</span>      <span class="comment">// 停止定时器的通道</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步，为了能将日志应用到程序中任何地方，就需要定义一个全局的日志对象，并要对该日志对象进行初始化。初始化操作有一点复杂，我们先来看代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> DATE_FORMAT = <span class="string">"2006-01-02"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fileLog *FileLogger</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">(fileDir, fileName, prefix, level <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	CloseLogger()</span><br><span class="line"></span><br><span class="line">	f := &amp;FileLogger&#123;</span><br><span class="line">		fileDir:       fileDir,</span><br><span class="line">		fileName:      fileName,</span><br><span class="line">		prefix:        prefix,</span><br><span class="line">		mu:            <span class="built_in">new</span>(sync.RWMutex),</span><br><span class="line">		logChan:       <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">5000</span>),</span><br><span class="line">		stopTikerChan: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> strings.ToUpper(level) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"DEBUG"</span>:</span><br><span class="line">		f.logLevel = DEBUG</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"WARN"</span>:</span><br><span class="line">		f.logLevel = WARN</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"ERROR"</span>:</span><br><span class="line">		f.logLevel = ERROR</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		f.logLevel = INFO</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	t, _ := time.Parse(DATE_FORMAT, time.Now().Format(DATE_FORMAT))</span><br><span class="line">	f.date = &amp;t</span><br><span class="line"></span><br><span class="line">	f.isExistOrCreateFileDir()</span><br><span class="line"></span><br><span class="line">	fullFileName := filepath.Join(f.fileDir, f.fileName+<span class="string">".log"</span>)</span><br><span class="line">	file, err := os.OpenFile(fullFileName, os.O_RDWR|os.O_APPEND|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	f.logFile = file</span><br><span class="line"></span><br><span class="line">	f.lg = log.New(f.logFile, prefix, log.LstdFlags|log.Lmicroseconds)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> f.logWriter()</span><br><span class="line">	<span class="keyword">go</span> f.fileMonitor()</span><br><span class="line"></span><br><span class="line">	fileLogger = f</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个初始化的逻辑有点多，我来进行拆分讲解。首先，第一步，调用了 <strong>CloseLogger()</strong> 函数，该函数主要是关闭文件、关闭通道等操作。为了停止一个不断循环的 goroutine，关闭通道是一个常用的方案，这在之前的文章也有说过。那么，由于初始化函数可以会被调用多次，以实现配置的变更，那如果不先结束旧的 goroutine ，那同样功能的 goroutine 将不止一个在同时运行，这无疑将会出问题。因此，需要先关闭 Logger，关闭 Logger 的代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CloseLogger</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> fileLogger != <span class="literal">nil</span> &#123;</span><br><span class="line">		fileLogger.stopTikerChan &lt;- <span class="literal">true</span></span><br><span class="line">		<span class="built_in">close</span>(fileLogger.stopTikerChan)</span><br><span class="line">		<span class="built_in">close</span>(fileLogger.logChan)</span><br><span class="line">		fileLogger.lg = <span class="literal">nil</span></span><br><span class="line">		fileLogger.logFile.Close()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关闭 Logger 之后，就是对一些字段的初始化赋值了，其中，<strong>f.date</strong> 设置为了当前日期，后面判断是否需要分割就以这个日期为条件。<strong>f.isExistOrCreateFileDir()</strong> 则会判断日志目录是否存在，如果不存在则会创建该目录。接着，将目录、设置的文件名和添加的 .log 文件扩展名拼接在一起，拼接出文件的完整名字并打开文件。之后就是用该文件来初始化系统日志对象 <strong>f.lg</strong> 了，将日志消息写入文件时其实就是调用该对象的 <strong>Output()</strong> 函数。后面启动了两个 goroutine：一个用来监听 logChan，实现将日志消息写入文件；一个用来定时监听文件是否需要分割，需要分割时则实现分割。 </p>
<p>接着，我们就来看看这两个 goroutine 的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FileLogger)</span> <span class="title">logWriter</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="built_in">recover</span>() &#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		str, ok := &lt;-f.logChan</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		f.mu.RLock()</span><br><span class="line">		f.lg.Output(<span class="number">2</span>, str)</span><br><span class="line">		f.mu.RUnlock()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FileLogger)</span> <span class="title">fileMonitor</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="built_in">recover</span>() &#125;()</span><br><span class="line">	ticker := time.NewTicker(<span class="number">30</span> * time.Second)</span><br><span class="line">	<span class="keyword">defer</span> ticker.Stop()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">			<span class="keyword">if</span> f.isMustSplit() &#123;</span><br><span class="line">				<span class="keyword">if</span> err := f.split(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					Error(<span class="string">"Log split error: %v\n"</span>, err)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> &lt;-f.stopTikerChan:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <strong>logWriter()</strong> 循环从 logChan 通道读取日志消息，当通道被关闭则退出，否则就调用 <strong>f.lg.Output()</strong> 将日志输出。<strong>fileMonitor()</strong> 里则创建了一个每隔 30 秒发送一次的 <strong>ticker</strong>，当从 <strong>ticker.C</strong> 接收到数据之后，就判断是否需要分割，如果需要则调用分割函数 <strong>f.split()</strong>。而从 <strong>f.stopTikerChan</strong> 收到数据时，说明该定时器也要结束了。</p>
<p>接着，再来看看 <strong>isMustSplit()</strong> 和 <strong>split()</strong> 函数了。isMustSplit() 非常简单，就两行代码，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FileLogger)</span> <span class="title">isMustSplit</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	t, _ := time.Parse(DATE_FORMAT, time.Now().Format(DATE_FORMAT))</span><br><span class="line">	<span class="keyword">return</span> t.After(f.date)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>split() 则复杂些，首先对日志要先加写锁，避免分割时依然有日志写入，接着对当前的日志文件进行重命名备份，然后生成新文件用来记录新的日志消息，并将当前的全局日志对象指向新文件、新日期和新的系统日志对象。实现代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FileLogger)</span> <span class="title">split</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	f.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> f.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	logFile := filepath.Join(f.fileDir, f.fileName)</span><br><span class="line">	logFileBak := logFile + <span class="string">"-"</span> + f.date.Format(DATE_FORMAT) + <span class="string">".log"</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> f.logFile != <span class="literal">nil</span> &#123;</span><br><span class="line">		f.logFile.Close()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err := os.Rename(logFile, logFileBak)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	t, _ := time.Parse(DATE_FORMAT, time.Now().Format(DATE_FORMAT))</span><br><span class="line">	f.date = &amp;t</span><br><span class="line"></span><br><span class="line">	f.logFile, err = os.OpenFile(logFile, os.O_RDWR|os.O_APPEND|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	f.lg = log.New(f.logFile, f.prefix, log.LstdFlags|log.Lmicroseconds)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，就剩下定义一些接收日志消息的函数了，实现都很简单，以 <strong>Info()</strong> 为例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Info</span><span class="params">(format <span class="keyword">string</span>, v ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	_, file, line, _ := runtime.Caller(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">if</span> fileLogger.logLevel &lt;= INFO &#123;</span><br><span class="line">		fileLogger.logChan &lt;- fmt.Sprintf(<span class="string">"[%v:%v]"</span>, filepath.Base(file), line) + fmt.Sprintf(<span class="string">"[INFO]"</span>+format, v...)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Debug()、Warn()、Error() 等函数都类似的，照猫画虎即可。</p>
<p>至此，我们这个能够实现按日期分割日志文件的日志包就完成了，剩下的，就在对应需要添加日志输出的地方调用响应的日志等级函数即可。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本小结的核心其实是增加了一个通用的日志包，该日志包不仅可以用在我们的撮合引擎，也能用于其他项目。如果再将其扩展，还可以改为按其他条件分割，比如按小时分割，或按文件大小分割。有兴趣的小伙伴可以自己去尝试一下。</p>
<p>今日的思考题：要实现接口的请求和响应数据进行统一的日志输出，有哪些方案？</p>
<hr>
<p>扫描以下二维码即可关注公众号（公众号名称：Keegan小钢）</p>
<img src="/post/matching/20191203/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/matching/20191202/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/matching/20191202/" class="post-title-link" itemprop="url">撮合引擎开发:缓存和MQ</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-02 15:06:14" itemprop="dateCreated datePublished" datetime="2019-12-02T15:06:14+08:00">2019-12-02</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-04 16:45:31" itemprop="dateModified" datetime="2019-12-04T16:45:31+08:00">2019-12-04</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/matching/" itemprop="url" rel="index"><span itemprop="name">matching</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/matching/20191202"><strong>http://keeganlee.me/post/matching/20191202</strong></a><br>微信公众号：名称：Keegan小钢；微信号：keeganlee_me<br>写于2019-12-02</p>
<hr>
<p><a href="http://keeganlee.me/post/matching/20191117">撮合引擎开发：开篇</a><br><a href="http://keeganlee.me/post/matching/20191118">撮合引擎开发：MVP版本</a><br><a href="http://keeganlee.me/post/matching/20191119">撮合引擎开发：数据结构设计</a><br><a href="http://keeganlee.me/post/matching/20191121">撮合引擎开发：对接黑箱</a><br><a href="http://keeganlee.me/post/matching/20191127">撮合引擎开发：解密黑箱流程</a><br><a href="http://keeganlee.me/post/matching/20191130">撮合引擎开发：流程的代码实现</a><br><a href="http://keeganlee.me/post/matching/20191202">撮合引擎开发：缓存和MQ</a><br><a href="http://keeganlee.me/post/matching/20191203">撮合引擎开发：日志输出</a><br><a href="http://keeganlee.me/post/matching/20191204">撮合引擎开发：完结篇</a></p>
<hr>
<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>先来回顾下我们撮合程序项目中关于中间件的目录结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├── middleware               # 中间件的包</span><br><span class="line">│   ├── cache                # 缓存包</span><br><span class="line">│   │   └── cache.go         # 缓存操作</span><br><span class="line">│   ├── mq                   # 消息队列包</span><br><span class="line">│   │   └── mq.go            # MQ操作</span><br><span class="line">│   └── redis.go             # 主要做Redis初始化操作</span><br></pre></td></tr></table></figure>

<p>虽然现在只用到了 Redis 一个中间件，但设计个 middleware 包，会方便以后扩展添加其他中间件，如 Kafka 或 RocketMQ 等。</p>
<p>再将缓存和消息队列分包，职责上就很分明，应用时也很明确。</p>
<p><strong>redis.go</strong> 就只是做初始化的连接，我们来看看代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> middleware</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"matching/log"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/go-redis/redis"</span></span><br><span class="line">	<span class="string">"github.com/spf13/viper"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> RedisClient *redis.Client</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	addr := viper.GetString(<span class="string">"redis.addr"</span>)</span><br><span class="line">	RedisClient = redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">		Addr:     addr,</span><br><span class="line">		Password: <span class="string">""</span>, <span class="comment">// no password set</span></span><br><span class="line">		DB:       <span class="number">0</span>,  <span class="comment">// use default DB</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	_, err := RedisClient.Ping().Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">"Connected to redis: %s"</span>, addr)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，viper 是前文说过的第三方配置库，通过 <strong>viper.GetString(“redis.addr”)</strong> 从配置文件读取出要连接的 Redis 的地址，之后就新建一个 Redis 客户端并连接上 Redis 服务器了。</p>
<h2 id="缓存的设计"><a href="#缓存的设计" class="headerlink" title="缓存的设计"></a>缓存的设计</h2><p>讲数据结构设计时，我们已经说过，使用缓存的目的主要有两个：</p>
<ol>
<li><strong>请求去重</strong>，避免重复提交相同订单；</li>
<li><strong>恢复数据</strong>，即程序重启后能恢复所有数据。</li>
</ol>
<p>还记得上一篇文章讲 Dispatch 的实现时，有个判断订单是否存在的逻辑吗？就是读取缓存中是否已经存在该订单，从而判别是否为重复请求或无效请求。以及，还记得 process 包的初始化？就是从缓存中恢复数据的过程。</p>
<p>先了解下，我们总共缓存了哪些数据：</p>
<ul>
<li><p>开启撮合的交易标的 symbol；</p>
</li>
<li><p>这些交易标的的最新价格；</p>
</li>
<li><p>所有有效的订单请求，包括下单和撤单请求。</p>
</li>
</ul>
<h3 id="1-缓存symbol"><a href="#1-缓存symbol" class="headerlink" title="1. 缓存symbol"></a>1. 缓存symbol</h3><p>开启撮合的交易标的 symbol 会有多个，且不能重复，那其实就可以保存为集合 set 类型。我将该 set 的 key 设计为 <strong>matching:symbols</strong>，之后，每有一个 symbol 开启撮合时，就可以用 Redis 的 <strong>sadd</strong> 命令将该 symbol 添加进这个集合里去了。而关闭撮合时，则需用 <strong>srem</strong> 命令将关闭撮合的 symbol 从集合中移除。读取所有 symbol 则可用 <strong>smembers</strong> 命令操作。</p>
<p>程序里对 symbol 的操作提供了三个函数，分别用来保存 symbol、移除 symbol 和获取所有 symbol，以下是实现的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SaveSymbol</span><span class="params">(symbol <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	key := <span class="string">"matching:symbols"</span></span><br><span class="line">	RedisClient.SAdd(key, symbol)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RemoveSymbol</span><span class="params">(symbol <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	key := <span class="string">"matching:symbols"</span></span><br><span class="line">	RedisClient.SRem(key, symbol)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetSymbols</span><span class="params">()</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	key := <span class="string">"matching:symbols"</span></span><br><span class="line">	<span class="keyword">return</span> RedisClient.SMembers(key).Val()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-缓存价格"><a href="#2-缓存价格" class="headerlink" title="2. 缓存价格"></a>2. 缓存价格</h3><p>交易标的的最新价格则是每个 symbol 会有一个价格，且无需缓存历史价格，那我就直接用字符串类型来保存价格，而每个价格的 key 则包含有各自的 symbol，key 的格式设计为 <strong>matching:price:{symbol}</strong>，假如要保存的 symbol = “BTCUSD”，那对应的 key 值就是 <strong>matching:price:BTCUSD</strong>，保存的 value 值就是 BTCUSD 的最新价格。</p>
<p>我们也同样提供了保存价格、获取价格和删除价格的三个函数，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SavePrice</span><span class="params">(symbol <span class="keyword">string</span>, price decimal.Decimal)</span></span> &#123;</span><br><span class="line">	key := <span class="string">"matching:price:"</span> + symbol</span><br><span class="line">	RedisClient.Set(key, price.String(), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetPrice</span><span class="params">(symbol <span class="keyword">string</span>)</span> <span class="title">decimal</span>.<span class="title">Decimal</span></span> &#123;</span><br><span class="line">	key := <span class="string">"matching:price:"</span> + symbol</span><br><span class="line">	priceStr := RedisClient.Get(key).Val()</span><br><span class="line">	result, err := decimal.NewFromString(priceStr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		result = decimal.Zero</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RemovePrice</span><span class="params">(symbol <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	key := <span class="string">"matching:price:"</span> + symbol</span><br><span class="line">	RedisClient.Del(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-缓存订单"><a href="#3-缓存订单" class="headerlink" title="3. 缓存订单"></a>3. 缓存订单</h3><p>对订单的缓存设计则没那么简单了，需要满足两点要求：</p>
<ol>
<li>既能缓存下单请求，也能缓存撤单请求；</li>
<li>订单要符合定序要求。</li>
</ol>
<p>先说下第一点，为什么需要缓存订单？且为什么下单和撤单请求都需要缓存？</p>
<p>先来解答第一个问题，我们是在内存中撮合的，每个交易标的引擎里各自维护了一个交易委托账本，程序运行时，这些账本是直接保存在程序内存里的。那如果程序退出了，这些账本都被清空了。如果没有缓存，那程序重启后就无法恢复账本数据。要满足该需求，就需要缓存账本里的所有委托单。</p>
<p>关于第二个问题，我们来考虑这样一个场景：假如订单通道里有撤单请求在排队，而程序并没有对撤单请求做缓存，这时程序重启了，那么订单通道里的所有订单还没被引擎接收处理之前就被清空了，撤单请求也就无法恢复了。</p>
<p>因此，程序需要缓存好订单，且下单和撤单都需要缓存。</p>
<p>再来看第二个要求，为什么要符合定序？我们知道，订单通道里的订单是定序的，交易委托账本里同价格的订单也是按时间排序的，那缓存时如果不定序，程序重启后就难以保证按原有的顺序恢复订单。</p>
<p>那具体要怎么来设计这个订单的缓存呢？我的方案是分两类缓存，第一类保存每个独立的订单请求，包括下单和撤单；第二类分交易标的保存对应 symbol 所有订单请求的订单 ID 和 action。</p>
<p>第一类，我设计的 Key 格式为 <strong>matching:order:{symbol}:{orderId}:{action}</strong>，symbol、orderId 和 action 则是对应订单的三个变量值。比如，某订单 symbol = “BTCUSD”，orderId = “12345”，action = “cancel”，那该订单保存到 Redis 的 Key 值就是 <strong>matching:order:BTCUSD:12345:cancel</strong>。该 Key 对应的 Value 则是保存整个订单对象，可以用 <strong>hash</strong> 类型存储。</p>
<p>第二类，我设计的 Key 格式为 <strong>matching:orderids:{symbol}</strong>，Value 保存的是 <strong>sorted set</strong> 类型的数据，保存对应 symbol 的所有订单请求，每条记录保存的值为 <strong>{orderId}:{action}</strong>，而 <strong>score</strong> 值设为对应订单的 <strong>{timestamp}</strong>。用订单时间作为 score 就可以保证定序了。还记得之前文章我们将订单时间的单位设为 100 纳秒，保证时间戳长度刚好为 16 位吗？这是因为，如果超过 16 位，那 score 将转为科学计数法表示，那将会导致数字失真。</p>
<p>根据这样的设计，那保存订单时的实现逻辑就如以下代码所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SaveOrder</span><span class="params">(order <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	symbol := order[<span class="string">"symbol"</span>].(<span class="keyword">string</span>)</span><br><span class="line">	orderId := order[<span class="string">"orderId"</span>].(<span class="keyword">string</span>)</span><br><span class="line">	timestamp := order[<span class="string">"timestamp"</span>].(<span class="keyword">float64</span>)</span><br><span class="line">	action := order[<span class="string">"action"</span>].(<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">	key := <span class="string">"matching:order:"</span> + symbol + <span class="string">":"</span> + orderId + <span class="string">":"</span> + action</span><br><span class="line">	RedisClient.HMSet(key, order)</span><br><span class="line"></span><br><span class="line">	key = <span class="string">"matching:orderids:"</span> + symbol</span><br><span class="line">	z := &amp;redis.Z&#123;</span><br><span class="line">		Score:  timestamp,</span><br><span class="line">		Member: orderId + <span class="string">":"</span> + action,</span><br><span class="line">	&#125;</span><br><span class="line">	RedisClient.ZAdd(key, z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，还提供了 GetOrder()、UpdateOrder()、RemoveOrder()、OrderExist()、GetOrderIdsWithAction() 等函数。再给大伙看看 GetOrderIdsWithAction() 函数的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetOrderIdsWithAction</span><span class="params">(symbol <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	key := <span class="string">"matching:orderids:"</span> + symbol</span><br><span class="line">	<span class="keyword">return</span> RedisClient.ZRange(key, <span class="number">0</span>, <span class="number">-1</span>).Val()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数得到的结果是根据 score 值排好序的，这就是我们想要的结果。理解了这个设计之后，再翻回去看看 process 包的初始化，你就会明白那些代码的逻辑了。</p>
<h2 id="MQ的设计"><a href="#MQ的设计" class="headerlink" title="MQ的设计"></a>MQ的设计</h2><p>我们选择了使用 Redis 的 Stream 数据结构来作为 MQ 输出，Stream 数据结构采用了类似 Kafka 的设计，应用起来很方便。但由于 Redis 运行于内存的特性，相比 Kafka 快速很多，这也是我选择它来作为撮合程序的输出 MQ 的主要原因。</p>
<p>我们只有两类 MQ，撤单结果和成交记录，发送消息的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendCancelResult</span><span class="params">(symbol, orderId <span class="keyword">string</span>, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	values := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">"orderId"</span>: orderId, <span class="string">"ok"</span>: ok&#125;</span><br><span class="line">	a := &amp;redis.XAddArgs&#123;</span><br><span class="line">		Stream:       <span class="string">"matching:cancelresults:"</span> + symbol,</span><br><span class="line">		MaxLenApprox: <span class="number">1000</span>,</span><br><span class="line">		Values:       values,</span><br><span class="line">	&#125;</span><br><span class="line">	RedisClient.XAdd(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendTrade</span><span class="params">(symbol <span class="keyword">string</span>, trade <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	a := &amp;redis.XAddArgs&#123;</span><br><span class="line">		Stream:       <span class="string">"matching:trades:"</span> + symbol,</span><br><span class="line">		MaxLenApprox: <span class="number">1000</span>,</span><br><span class="line">		Values:       trade,</span><br><span class="line">	&#125;</span><br><span class="line">	RedisClient.XAdd(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<strong>matching:cancelresults:{symbol}</strong> 就是撤单结果的 MQ 所属的 Key，<strong>matching:trades:{symbol}</strong> 则是成交记录的 MQ 所属的 Key。可以看到，我们还根据不同 symbol 分不同 MQ，这样还方便下游服务可以根据需要实现分布式订阅不同 symbol 的 MQ。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本小节讲解了缓存和 MQ 的设计与实现，理解了这部分的设计之后，对整个撮合引擎的核心设计也基本能理解了。</p>
<p>最后，依然留几个思考题：是否可以不用缓存？如果不用缓存可以如何解决去重和数据恢复的问题？</p>
<hr>
<p>扫描以下二维码即可关注公众号（公众号名称：Keegan小钢）</p>
<img src="/post/matching/20191202/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/matching/20191130/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/matching/20191130/" class="post-title-link" itemprop="url">撮合引擎开发:流程的代码实现</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-30 12:19:26" itemprop="dateCreated datePublished" datetime="2019-11-30T12:19:26+08:00">2019-11-30</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-04 16:46:10" itemprop="dateModified" datetime="2019-12-04T16:46:10+08:00">2019-12-04</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/matching/" itemprop="url" rel="index"><span itemprop="name">matching</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/matching/20191130"><strong>http://keeganlee.me/post/matching/20191130</strong></a><br>微信公众号：名称：Keegan小钢；微信号：keeganlee_me<br>写于2019-11-30</p>
<hr>
<p><a href="http://keeganlee.me/post/matching/20191117">撮合引擎开发：开篇</a><br><a href="http://keeganlee.me/post/matching/20191118">撮合引擎开发：MVP版本</a><br><a href="http://keeganlee.me/post/matching/20191119">撮合引擎开发：数据结构设计</a><br><a href="http://keeganlee.me/post/matching/20191121">撮合引擎开发：对接黑箱</a><br><a href="http://keeganlee.me/post/matching/20191127">撮合引擎开发：解密黑箱流程</a><br><a href="http://keeganlee.me/post/matching/20191130">撮合引擎开发：流程的代码实现</a><br><a href="http://keeganlee.me/post/matching/20191202">撮合引擎开发：缓存和MQ</a><br><a href="http://keeganlee.me/post/matching/20191203">撮合引擎开发：日志输出</a><br><a href="http://keeganlee.me/post/matching/20191204">撮合引擎开发：完结篇</a></p>
<hr>
<h2 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h2><p>我们要开始聊代码实现逻辑了，如果不记得之前讲的目录结构，请回去翻看<a href="http://keeganlee.me/post/matching/20191121">前文</a>。聊代码实现的第一步自然从程序入口开始，核心就两个函数：<strong>init()</strong> 和 <strong>main()</strong>，其代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line">... <span class="comment">//other codes</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	initViper()</span><br><span class="line">	initLog()</span><br><span class="line"></span><br><span class="line">	engine.Init()</span><br><span class="line">	middleware.Init()</span><br><span class="line">	process.Init()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mux := http.NewServeMux()</span><br><span class="line">	mux.HandleFunc(<span class="string">"/openMatching"</span>, handler.OpenMatching)</span><br><span class="line">	mux.HandleFunc(<span class="string">"/closeMatching"</span>, handler.CloseMatching)</span><br><span class="line">	mux.HandleFunc(<span class="string">"/handleOrder"</span>, handler.HandleOrder)</span><br><span class="line"></span><br><span class="line">	log.Printf(<span class="string">"HTTP ListenAndServe at port %s"</span>, viper.GetString(<span class="string">"server.port"</span>))</span><br><span class="line">	<span class="keyword">if</span> err := http.ListenAndServe(viper.GetString(<span class="string">"server.port"</span>), mux); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>init() 函数做了一些初始化的操作，我来简单介绍这几个初始化函数：</p>
<ul>
<li><strong>initViper()</strong>：配置文件初始化，使用了第三方配置库 viper，这是一个被广泛使用的配置库，其 github 地址为 <a href="https://github.com/spf13/viper" target="_blank" rel="noopener">https://github.com/spf13/viper</a>。</li>
<li><strong>initLog()</strong>：日志初始化，程序主要使用自己定义的日志包用来输出日志文件，该日志包的实现后续文章再单独讲。</li>
<li><strong>engine.Init()</strong>：引擎包的初始化，只是初始化了一个 map，用来保存不同交易标的的订单 channel，作为各交易标的的定序队列来用。</li>
<li><strong>middleware.Init()</strong>：中间件的初始化，我们用到的中间件就只有 Redis，所以这里其实就是初始化 Redis 连接。Redis 客户端库方面我选择的是 <a href="https://github.com/go-redis/redis" target="_blank" rel="noopener">go-redis/redis</a>。</li>
<li><strong>process.Init()</strong>：这一步主要是从缓存加载和恢复各交易标的引擎的启动和所有订单数据。</li>
</ul>
<p>viper 和 redis 的初始化都是参照官方 demo 写的，这里就不展开说明了。log 后续再单独讲。engine 包和 process 包的初始化就需要好好讲讲。</p>
<p>其中，引擎包的初始化虽然非常简单，但很关键，其代码写在 <strong>engine/init.go</strong> 文件中，完整代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> engine</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ChanMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">chan</span> Order</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ChanMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">chan</span> Order)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个保存通道的 map，其 Key 是各交易标的的 symbol，即是说每个交易标的各有一个订单通道，这些订单通道将作为每个交易标的的定序队列。</p>
<p>process 包的初始化则如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	symbols := cache.GetSymbols()</span><br><span class="line">	<span class="keyword">for</span> _, symbol := <span class="keyword">range</span> symbols &#123;</span><br><span class="line">		price := cache.GetPrice(symbol)</span><br><span class="line">		NewEngine(symbol, price)</span><br><span class="line"></span><br><span class="line">		orderIds := cache.GetOrderIdsWithAction(symbol)</span><br><span class="line">		<span class="keyword">for</span> _, orderId := <span class="keyword">range</span> orderIds &#123;</span><br><span class="line">			mapOrder := cache.GetOrder(symbol, orderId)</span><br><span class="line">			order := engine.Order&#123;&#125;</span><br><span class="line">			order.FromMap(mapOrder)</span><br><span class="line">			engine.ChanMap[order.Symbol] &lt;- order</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单讲解下实现逻辑：</p>
<ol>
<li>从缓存读取所有 symbol，即程序重启之前，已经开启了撮合的所有交易标的的 symbol；</li>
<li>从缓存读取每个 symbol 对应的价格，这是程序重启前的最新成交价格；</li>
<li>启动每个 symbol 的撮合引擎；</li>
<li>从缓存读取每个 symbol 的所有订单，这些订单都是按时间顺序排列的；</li>
<li>按顺序将这些订单添加到对应 symbol 的订单通道里去。</li>
</ol>
<p>如果对这里面有些设计逻辑还不太明白的话，也没关系，后面讲到对应模块时会再详细说明。</p>
<p>main() 函数里，定义了我们之前所说的三个接口，分别交由对应的 handler 去处理具体的请求，之后就启动 http 服务了。</p>
<h2 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h2><p>因为只有几个接口，而且也很简单，因此，并没有引入第三方 web 框架，handler 都是用原生实现的。先来看看 <strong>OpenMatching</strong> 的完整实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> handler</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"matching/errcode"</span></span><br><span class="line">	<span class="string">"matching/process"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/shopspring/decimal"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> openMatchingParams <span class="keyword">struct</span> &#123;</span><br><span class="line">	Symbol <span class="keyword">string</span>          <span class="string">`json:"symbol"`</span></span><br><span class="line">	Price  decimal.Decimal <span class="string">`json:"price"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenMatching</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">	<span class="keyword">if</span> r.Method != http.MethodPost &#123;</span><br><span class="line">		w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	body, err := ioutil.ReadAll(r.Body)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		w.WriteHeader(http.StatusBadRequest)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> params openMatchingParams</span><br><span class="line">	<span class="keyword">if</span> err := json.Unmarshal(body, &amp;params); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		w.WriteHeader(http.StatusBadRequest)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> strings.TrimSpace(params.Symbol) == <span class="string">""</span> &#123;</span><br><span class="line">		w.Write(errcode.BlankSymbol.ToJson())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> params.Price.IsNegative() &#123;</span><br><span class="line">		w.Write(errcode.InvalidPrice.ToJson())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> e := process.NewEngine(params.Symbol, params.Price); !e.IsOK() &#123;</span><br><span class="line">		w.Write(e.ToJson())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	w.Write(errcode.OK.ToJson())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑非常简单，先判断是否为 POST 请求，再读取 body 里的数据并转为结构体对象，接着对参数做个简单的检查，最后就调用 <strong>process.NewEngine(symbol, price)</strong> 进入下一步的业务逻辑，如果结果返回是 OK，也返回 OK 作为请求的响应。</p>
<p>另外，用到了第三方的 <strong>decimal.Decimal</strong> 类型用来表示价格，整个程序都统一用 decimal 来表示浮点数和做精确计算。</p>
<p><strong>CloseMatching</strong> 和 <strong>HandleOrder</strong> 的实现逻辑也是同理，CloseMatching 最后会调用 <strong>process.CloseEngine(symbol)</strong> 函数进入下一步的处理，HandleOrder 最后则调用 <strong>process.Dispatch(order)</strong> 进入下一步。不过，Order 结构体是定义在 engine 包的，其结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Order <span class="keyword">struct</span> &#123;</span><br><span class="line">	Action    enum.OrderAction <span class="string">`json:"action"`</span></span><br><span class="line">	Symbol    <span class="keyword">string</span>           <span class="string">`json:"symbol"`</span></span><br><span class="line">	OrderId   <span class="keyword">string</span>           <span class="string">`json:"orderId"`</span></span><br><span class="line">	Side      enum.OrderSide   <span class="string">`json:"side"`</span></span><br><span class="line">	Type      enum.OrderType   <span class="string">`json:"type"`</span></span><br><span class="line">	Amount    decimal.Decimal  <span class="string">`json:"amount"`</span></span><br><span class="line">	Price     decimal.Decimal  <span class="string">`json:"price"`</span></span><br><span class="line">	Timestamp <span class="keyword">int64</span>            <span class="string">`json:"timestamp"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，其中的字段，除了有 Decimal 类型，还有 enum 包的几个类型，这几个其实是我们程序中自己定义的枚举类型。Golang 语言本身并没有提供和其他语言一样的 enum 关键字来定义枚举类型，所以一般采用<strong>类型定义+常量</strong>来模拟枚举类型，以 enum.OrderAction 为例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> OrderAction <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	ActionCreate OrderAction = <span class="string">"create"</span></span><br><span class="line">	ActionCancel OrderAction = <span class="string">"cancel"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>其他几个枚举类型也是这样定义的。</p>
<p>另外，为了方便转为字符串和检验参数是否有效，程序中还为每个枚举类型分别提供了两个函数，还是以 OrderAction 为例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o OrderAction)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> o &#123;</span><br><span class="line">	<span class="keyword">case</span> ActionCreate:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"create"</span></span><br><span class="line">	<span class="keyword">case</span> ActionCancel:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"cancel"</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"unknown"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o OrderAction)</span> <span class="title">Valid</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> o.String() == <span class="string">"unknown"</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他几个枚举类型也都定义了类似的两个函数，就不再贴代码了。</p>
<h2 id="process-包"><a href="#process-包" class="headerlink" title="process 包"></a>process 包</h2><p>来回顾下 process 包有哪些文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">└── process                  #</span><br><span class="line">    ├── close_engine.go      # 关闭引擎</span><br><span class="line">    ├── dispatch.go          # 分发订单</span><br><span class="line">    ├── init.go              # 初始化</span><br><span class="line">    └── new_engine.go        # 启动新引擎</span><br></pre></td></tr></table></figure>

<p>init.go 就一个初始化函数，上文已经讲了。其他三个文件分别定义了上文三个 handler 对应的下一步逻辑实现。</p>
<h3 id="启动新引擎"><a href="#启动新引擎" class="headerlink" title="启动新引擎"></a>启动新引擎</h3><p>先来看看 <strong>new_engine.go</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> process</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"matching/engine"</span></span><br><span class="line">	<span class="string">"matching/errcode"</span></span><br><span class="line">	<span class="string">"matching/middleware/cache"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/shopspring/decimal"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEngine</span><span class="params">(symbol <span class="keyword">string</span>, price decimal.Decimal)</span> *<span class="title">errcode</span>.<span class="title">Errcode</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> engine.ChanMap[symbol] != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errcode.EngineExist</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	engine.ChanMap[symbol] = <span class="built_in">make</span>(<span class="keyword">chan</span> engine.Order, <span class="number">100</span>)</span><br><span class="line">	<span class="keyword">go</span> engine.Run(symbol, price)</span><br><span class="line"></span><br><span class="line">	cache.SaveSymbol(symbol)</span><br><span class="line">	cache.SavePrice(symbol, price)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> errcode.OK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑也是比较简单的，第一步先判断 ChanMap[symbol] 是否为空，该 ChanMap 就是上文所说的引擎包初始化时用来保存订单通道的 map。如果 ChanMap[symbol] 不为空，说明该 symbol 的撮合引擎已经启动过了，那就返回错误。如果为空，那就初始化这个 symbol 的通道，从代码可知，ChanMap[symbol] 初始化为一个缓冲大小为 100 的订单通道。</p>
<p>接着，就调用 engine.Run() 启动一个 goroutine 了，这行代码即表示用 goroutine 的方式启动指定 symbol 的撮合引擎了。</p>
<p>然后，就将 symbol 和 price 都缓存起来了。</p>
<p>最后，返回 OK，搞定。</p>
<h3 id="2-分发订单"><a href="#2-分发订单" class="headerlink" title="2. 分发订单"></a>2. 分发订单</h3><p>接着，来看看 Dispatch 的实现又是怎样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dispatch</span><span class="params">(order engine.Order)</span> *<span class="title">errcode</span>.<span class="title">Errcode</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> engine.ChanMap[order.Symbol] == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errcode.EngineNotFound</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> order.Action == enum.ActionCreate &#123;</span><br><span class="line">		<span class="keyword">if</span> cache.OrderExist(order.Symbol, order.OrderId, order.Action.String()) &#123;</span><br><span class="line">			<span class="keyword">return</span> errcode.OrderExist</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !cache.OrderExist(order.Symbol, order.OrderId, enum.ActionCreate.String()) &#123;</span><br><span class="line">			<span class="keyword">return</span> errcode.OrderNotFound</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	order.Timestamp = time.Now().UnixNano() / <span class="number">1e3</span></span><br><span class="line">	cache.SaveOrder(order.ToMap())</span><br><span class="line">	engine.ChanMap[order.Symbol] &lt;- order</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> errcode.OK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一步，判断 ChanMap[order.Symbol] 是否为空，如果为空，表示引擎没开启，那就无法处理订单。</p>
<p>第二步，判断订单是否存在。如果是 create 订单，那缓存中就不应该查到订单，否则说明是重复请求。如果是 cancel 订单，那缓存中如果也查不到订单，那说明该订单已经全部成交或已经成功撤单过了。</p>
<p>第三步，将订单时间设为当前时间，时间单位是 100 纳秒，这可以保证时间戳长度刚好为 16 位，保存到 Redis 里就不会有精度失真的问题。这点后续文章讲到 Redis 详细设计时再说。</p>
<p>第四步，将订单缓存。</p>
<p>第五步，将订单传入对应的订单通道，对应引擎会从该通道中获取该订单进行处理。这一步就实现了订单的分发。</p>
<p>第六步，返回 OK。</p>
<h3 id="3-关闭引擎"><a href="#3-关闭引擎" class="headerlink" title="3. 关闭引擎"></a>3. 关闭引擎</h3><p>关闭引擎的实现就非常简单了，请看代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CloseEngine</span><span class="params">(symbol <span class="keyword">string</span>)</span> *<span class="title">errcode</span>.<span class="title">Errcode</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> engine.ChanMap[symbol] == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errcode.EngineNotFound</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>(engine.ChanMap[symbol])</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> errcode.OK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心代码就一行，将对应 symbol 的订单通道关闭。后续的处理其实是在引擎里完成的，待会我们再结合引擎里的代码来讲解这个设计。</p>
<h2 id="引擎入口的实现"><a href="#引擎入口的实现" class="headerlink" title="引擎入口的实现"></a>引擎入口的实现</h2><p>交易引擎 goroutine 的启动入口就是 <strong>engine.Run()</strong> 函数，来看看其代码实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(symbol <span class="keyword">string</span>, price decimal.Decimal)</span></span> &#123;</span><br><span class="line">	lastTradePrice := price</span><br><span class="line"></span><br><span class="line">	book := &amp;orderBook&#123;&#125;</span><br><span class="line">	book.init()</span><br><span class="line"></span><br><span class="line">	log.Info(<span class="string">"engine %s is running"</span>, symbol)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		order, ok := &lt;-ChanMap[symbol]</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			log.Info(<span class="string">"engine %s is closed"</span>, symbol)</span><br><span class="line">			<span class="built_in">delete</span>(ChanMap, symbol)</span><br><span class="line">			cache.Clear(symbol)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		log.Info(<span class="string">"engine %s receive an order: %s"</span>, symbol, order.ToJson())</span><br><span class="line">		<span class="keyword">switch</span> order.Action &#123;</span><br><span class="line">		<span class="keyword">case</span> enum.ActionCreate:</span><br><span class="line">			dealCreate(&amp;order, book, &amp;lastTradePrice)</span><br><span class="line">		<span class="keyword">case</span> enum.ActionCancel:</span><br><span class="line">			dealCancel(&amp;order, book)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一步，先定义和初始化了一个 book 变量，该变量就是用来保存整个<strong>交易委托账本</strong>。</p>
<p>接着，就是一个 <strong>for</strong> 循环了，for 循环里的第一行就是从对应 <strong>symbol</strong> 的订单通道里读取出一个订单，读取到订单时，<strong>order</strong> 变量就会有值，且 <strong>ok</strong> 变量为 <strong>true</strong>。如果通道里暂时没有订单，那就会阻塞在这行代码，直到从通道中获取到订单或通道已关闭的消息。</p>
<p>当通道被关闭之后，最后，从通道中读取到的 <strong>ok</strong> 变量则为 <strong>false</strong>，当然，在这之前，会先依序读取完通道里剩下的订单。当 ok 为 false 时，引擎里会执行两步操作：一是从 ChanMap 中删除该 symbol 对应的记录，二是清空该 symbol 对应的缓存数据。最后用 <strong>return</strong> 来退出 for 循环，这样，整个 Run() 函数就结束退出了，意味着该引擎也真正关闭了。</p>
<p>当每读取到一个订单，就会判断是下单还是撤单，然后进行相应的逻辑处理了。</p>
<p>我们先来看看撤单的逻辑，这个比较简单：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dealCancel</span><span class="params">(order *Order, book *orderBook)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ok <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">switch</span> order.Side &#123;</span><br><span class="line">	<span class="keyword">case</span> enum.SideBuy:</span><br><span class="line">		ok = book.removeBuyOrder(order)</span><br><span class="line">	<span class="keyword">case</span> enum.SideSell:</span><br><span class="line">		ok = book.removeSellOrder(order)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cache.RemoveOrder(order.ToMap())</span><br><span class="line">	mq.SendCancelResult(order.Symbol, order.OrderId, ok)</span><br><span class="line">	log.Info(<span class="string">"engine %s, order %s cancel result is %s"</span>, order.Symbol, order.OrderId, ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心就三个步骤：</p>
<ol>
<li>从委托账本中移除该订单；</li>
<li>从缓存中移除该订单；</li>
<li>发送撤单结果到 MQ。</li>
</ol>
<p>下单逻辑就比较复杂了，需要根据不同的订单类型做不同的逻辑处理，请看代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dealCreate</span><span class="params">(order *Order, book *orderBook, lastTradePrice *decimal.Decimal)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> order.Type &#123;</span><br><span class="line">	<span class="keyword">case</span> enum.TypeLimit:</span><br><span class="line">		dealLimit(order, book, lastTradePrice)</span><br><span class="line">	<span class="keyword">case</span> enum.TypeLimitIoc:</span><br><span class="line">		dealLimitIoc(order, book, lastTradePrice)</span><br><span class="line">	<span class="keyword">case</span> enum.TypeMarket:</span><br><span class="line">		dealMarket(order, book, lastTradePrice)</span><br><span class="line">	<span class="keyword">case</span> enum.TypeMarketTop5:</span><br><span class="line">		dealMarketTop5(order, book, lastTradePrice)</span><br><span class="line">	<span class="keyword">case</span> enum.TypeMarketTop10:</span><br><span class="line">		dealMarketTop10(order, book, lastTradePrice)</span><br><span class="line">	<span class="keyword">case</span> enum.TypeMarketOpponent:</span><br><span class="line">		dealMarketOpponent(order, book, lastTradePrice)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个类型再分买卖方向处理，以 dealLimit() 为例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dealLimit</span><span class="params">(order *Order, book *orderBook, lastTradePrice *decimal.Decimal)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> order.Side &#123;</span><br><span class="line">	<span class="keyword">case</span> enum.SideBuy:</span><br><span class="line">		dealBuyLimit(order, book, lastTradePrice)</span><br><span class="line">	<span class="keyword">case</span> enum.SideSell:</span><br><span class="line">		dealSellLimit(order, book, lastTradePrice)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，再来看看 dealBuyLimit() 的处理逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dealBuyLimit</span><span class="params">(order *Order, book *orderBook, lastTradePrice *decimal.Decimal)</span></span> &#123;</span><br><span class="line">LOOP:</span><br><span class="line">	headOrder := book.getHeadSellOrder()</span><br><span class="line">	<span class="keyword">if</span> headOrder == <span class="literal">nil</span> || order.Price.LessThan(headOrder.Price) &#123;</span><br><span class="line">		book.addBuyOrder(order)</span><br><span class="line">		log.Info(<span class="string">"engine %s, a order has added to the orderbook: %s"</span>, order.Symbol, order.ToJson())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		matchTrade(headOrder, order, book, lastTradePrice)</span><br><span class="line">		<span class="keyword">if</span> order.Amount.IsPositive() &#123;</span><br><span class="line">			<span class="keyword">goto</span> LOOP</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我来解析下这个处理流程：</p>
<ol>
<li>从委托账本中读取出卖单队列的头部订单；</li>
<li>如果头部订单为空，或新订单(买单)价格小于头部订单(卖单)，则无法匹配成交，那就将新订单添加到委托账本的买单队列中去；</li>
<li>如果头部订单不为空，且新订单(买单)价格大于等于头部订单(卖单)，则两个订单可以匹配成交，那就对这两个订单进行成交处理；</li>
<li>如果上一步的成交处理完之后，新订单的剩余数量还不为零，那就继续重复第一步。</li>
</ol>
<p>其中，匹配成交的记录会作为一条输出记录发送到 MQ。</p>
<p>对其他类型的处理也是类似的，就不再一一讲解了。</p>
<p>那引擎包的实现就先讲到这里，后续文章再聊其他部分的实现。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本小节主要还是通过代码梳理清楚整个数据流程，包括一些细节上的设计。理解了本文所列举的这些代码，也就对整个撮合服务的实现理解一大半了。</p>
<p>这次的思考题：ChanMap 保存的订单通道是否可以改用无缓冲的通道？用无缓冲的通道和用有缓冲的通道处理逻辑有哪些不同？两种方案各自的优缺点是什么？</p>
<hr>
<p>扫描以下二维码即可关注公众号（公众号名称：Keegan小钢）</p>
<img src="/post/matching/20191130/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/matching/20191127/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/matching/20191127/" class="post-title-link" itemprop="url">撮合引擎开发:解密黑箱流程</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-27 22:35:16" itemprop="dateCreated datePublished" datetime="2019-11-27T22:35:16+08:00">2019-11-27</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-04 16:45:45" itemprop="dateModified" datetime="2019-12-04T16:45:45+08:00">2019-12-04</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/matching/" itemprop="url" rel="index"><span itemprop="name">matching</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/matching/20191127"><strong>http://keeganlee.me/post/matching/20191127</strong></a><br>微信公众号：名称：Keegan小钢；微信号：keeganlee_me<br>写于2019-11-27</p>
<hr>
<p><a href="http://keeganlee.me/post/matching/20191117">撮合引擎开发：开篇</a><br><a href="http://keeganlee.me/post/matching/20191118">撮合引擎开发：MVP版本</a><br><a href="http://keeganlee.me/post/matching/20191119">撮合引擎开发：数据结构设计</a><br><a href="http://keeganlee.me/post/matching/20191121">撮合引擎开发：对接黑箱</a><br><a href="http://keeganlee.me/post/matching/20191127">撮合引擎开发：解密黑箱流程</a><br><a href="http://keeganlee.me/post/matching/20191130">撮合引擎开发：流程的代码实现</a><br><a href="http://keeganlee.me/post/matching/20191202">撮合引擎开发：缓存和MQ</a><br><a href="http://keeganlee.me/post/matching/20191203">撮合引擎开发：日志输出</a><br><a href="http://keeganlee.me/post/matching/20191204">撮合引擎开发：完结篇</a></p>
<hr>
<h2 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h2><p>前面的几篇文章已经陆续讲到了黑箱内部的一些设计，包括核心的软件结构、数据结构、目录结构等。而从本小节开始，我们将会更加深入，来解密黑箱内部的更多设计和实现细节。</p>
<p>解密黑箱的第一步就是要清楚其内部对数据的处理流程是怎样的。当我们要设计一个新系统的时候，也是一样的，第一步要梳理清楚业务流程和数据流向。对撮合引擎来说，就是要了解：<strong>从输入到输出，中间都经过了哪些处理流程</strong>。</p>
<p>前面的文章已经讲过，本撮合引擎定义了三种输入：<strong>开启撮合、处理订单、关闭撮合</strong>。后面就分别来看看这三种输入背后的流程。</p>
<h2 id="开启撮合"><a href="#开启撮合" class="headerlink" title="开启撮合"></a>开启撮合</h2><p>开启撮合即是开启某个交易标的（交易对）的撮合引擎，未开启撮合的交易标的是无法处理订单的，而已经开启了撮合的交易标的也无法再次开启，不然就会出现同时有两个引擎处理同个交易标的的订单，这是不合理的，同个交易标的的订单只能由一个引擎串行来处理。</p>
<p>为什么不能并行呢？如果同一交易标的的订单可以用多个引擎并行处理的话，那至少会产生几个问题：</p>
<ol>
<li><strong>成交价以哪个为准？</strong>理论上，每一时刻只能有一个成交价，那并行之后，就会产生多个成交价，那成交价就难以确定了。</li>
<li><strong>如何维护统一的委托账本？</strong>理论上，每个交易标的有一本保存了所有委托单的委托账本，那并行之后，如何在多个引擎之间维护这个统一的账本呢？如果用数据库统一维护，那无疑会减低撮合性能；如果分为多个子账本，那就很难保证价格优先、时间优先的原则。</li>
</ol>
<p>以上这两个问题都不好解决，因此，只能先对所有订单进行定序，然后丢入引擎进行串行处理。</p>
<p>说到定序，自然就需要一个定序队列，因此开启撮合时需要初始化对应交易标的的订单定序队列。初始化好定序队列后，就可以真正启动对应交易标的的引擎了。在 Go 程序中，每个交易标的的引擎是以独立 goroutine 运行的；而在其他语言，比如 Java，则是以独立线程来运行。</p>
<p>引擎启动之后，需要先初始化交易委托账本，用来保存委托单。之后就等待定序队列有订单的时候逐个取出来处理了。</p>
<p>另外，再考虑一个场景，撮合程序重启时会发生什么？对于开启了撮合的交易标的，重启后是否需要恢复呢？需要的话，那如何恢复呢？最简单的方案当然是使用缓存，用 Redis 将开启了撮合的交易标的缓存起来，重启时从 Redis 加载并重新开启这些交易标的即可。</p>
<p>因此，触发开启撮合的场景其实有两个，一是接口的主动调用触发的，二是程序重启后从 Redis 缓存自动加载启动的。</p>
<p>最后，开启撮合的结果是同步返回的，因此，它没有异步的输出。</p>
<p>总结下，开启撮合的内部流程大致如下：</p>
<img src="/post/matching/20191127/开启撮合流程图.png">

<h2 id="处理订单"><a href="#处理订单" class="headerlink" title="处理订单"></a>处理订单</h2><p>开启撮合之后，就可以接收处理订单的输入了。撮合程序接收到处理订单的请求时，第一步需要做一些检查，包括每个参数是否有效、订单是否重复或存在、对应交易标的的引擎是否已经开启等。通过了检查之后，就可以将整个订单缓存到 Redis，接着添加到对应交易标的的定序队列中去，等待对应交易标的的引擎消费它进行撮合处理。这个流程如下图：</p>
<img src="/post/matching/20191127/处理订单接口流程.png">

<p>当订单成功添加到定序队列中后，接口就可以同步返回成功的响应结果了。后续的处理结果则是通过异步的 MQ 进行输出了。交易标的的引擎接收到订单后，根据不同情况会产生不同的输出结果。</p>
<p>我们知道，处理订单有两种 <strong>action</strong>：<strong>下单</strong>和<strong>撤单</strong>。撤单的业务逻辑很简单，就是从交易委托账本中查询该订单是否存在，若存在则从委托账本中删除该订单，然后输出撤单成功的撤单结果；若不存在则输出撤单失败的撤单结果。下单的业务逻辑则比较复杂，还要根据不同的订单类型作不同处理。写作此文时的撮合程序版本支持 6 种不同的 <strong>type</strong>，包括两种<strong>限价</strong>类型和四种<strong>市价</strong>类型。下面就来分别讲解不同订单类型的下单在不同条件下会有怎样的结果。</p>
<ul>
<li><strong>limit</strong>：普通限价。当委托账本里存在能与该订单匹配成交的委托单时，则可能生成一条或多条成交记录，每条成交记录都将产生异步输出；当委托账本里没有可匹配的委托单时，则将该订单(全部数量或剩余数量)添加到委托账本中，这时不会产生任何输出。</li>
<li><strong>limit-ioc</strong>：IOC限价-即时成交剩余撤销。当委托账本里存在能与该订单匹配成交的委托单时，则可能生成一条或多条成交记录，每条成交记录都将产生异步输出；当委托账本里没有可匹配的委托单时，则将该订单(全部或剩余数量)进行撤单处理，这时会产生一条撤单成功的输出。</li>
<li><strong>market</strong>：默认市价-即时成交剩余撤销。和 IOC 限价一样，当委托账本里与该订单相反方向的订单队列里（也称对手方）存在委托单时，则可能生成一条或多条成交记录，每条成交记录都将产生异步输出；当委托账本里对手方没有委托单时，则将该订单(全部或剩余数量)进行撤单处理，这时会产生一条撤单成功的输出。与 IOC 限价不同的在于：IOC 限价订单是由用户指定了委托价格的，而市价则无需指定委托价格，会直接与对手方的头部委托单成交，直到该订单已全部成交或对手方再无委托单为止。</li>
<li><strong>market-top5</strong>：市价-最优五档即时成交剩余撤销。market 可以与对手方所有价格档位的订单成交，但 market-top5 最多只会和对手方的五个价格档位内的订单成交，超出五档外的订单将不会成交。剩余未成交的都将做撤单处理并产生一条撤单成功的输出。</li>
<li><strong>market-top10</strong>：市价-最优十档即时成交剩余撤销。最多只会和对手方的十个价格档位内的订单成交。</li>
<li><strong>market-opponent</strong>：市价-对手方最优价。如果对手方没有订单，则直接对该订单进行撤单处理并产生一条撤单成功的输出；如果对手方有订单，那最多只会成交一档，如果还剩有未成交的量，那将以对手方一档的价格转为限价单并添加到委托账本中，此时不会产生输出。</li>
</ul>
<p>用图可表示如下：</p>
<img src="/post/matching/20191127/引擎处理订单流程.png">

<p>另外，每个处理订单的请求——不管是下单还是撤单，也都会缓存到 Redis 里，产生变更时还会更新缓存。这样，程序重启后就可以恢复订单了。</p>
<h2 id="关闭撮合"><a href="#关闭撮合" class="headerlink" title="关闭撮合"></a>关闭撮合</h2><p>当某个交易标的准备下架、或取消交易、或暂停交易时，都需要关闭引擎。关闭引擎之前，上游服务最好先停止调用处理订单的接口，不然可能会出现一些非预期的错误，虽然程序已经做了容错处理。</p>
<p>关闭引擎时，同样也有些简单的判断，比如判断该交易标的的引擎是否已经开启，未开启的引擎自然无法关闭。</p>
<p>关闭引擎时，如果定序队列中还存在未处理的订单，那应该等这些订单处理完才真正关闭引擎。</p>
<p>最后，也要清除缓存，将该交易标的的所有订单都从缓存中清除。</p>
<p>关闭引擎的结果也是同步返回的，所有也没有异步的输出。</p>
<p>流程图也比较简答：</p>
<img src="/post/matching/20191127/关闭引擎.png">

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本小节讲解了撮合黑箱内部的核心业务流程，包括开启撮合、处理订单、关闭撮合三个输入各自的内部逻辑。理解了这些流程之后，下一篇我们开始来讲代码实现。</p>
<p>惯例留几个思考题：如果关闭撮合的同时还有下单的并发请求，是否容易产生问题？如果有，哪里会产生？什么问题？能如何解决？</p>
<hr>
<p>扫描以下二维码即可关注公众号（公众号名称：Keegan小钢）</p>
<img src="/post/matching/20191127/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/matching/20191121/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/matching/20191121/" class="post-title-link" itemprop="url">撮合引擎开发:对接黑箱</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-21 22:41:26" itemprop="dateCreated datePublished" datetime="2019-11-21T22:41:26+08:00">2019-11-21</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-04 16:45:18" itemprop="dateModified" datetime="2019-12-04T16:45:18+08:00">2019-12-04</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/matching/" itemprop="url" rel="index"><span itemprop="name">matching</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/matching/20191121"><strong>http://keeganlee.me/post/matching/20191121</strong></a><br>微信公众号：名称：Keegan小钢；微信号：keeganlee_me<br>写于2019-11-21</p>
<hr>
<p><a href="http://keeganlee.me/post/matching/20191117">撮合引擎开发：开篇</a><br><a href="http://keeganlee.me/post/matching/20191118">撮合引擎开发：MVP版本</a><br><a href="http://keeganlee.me/post/matching/20191119">撮合引擎开发：数据结构设计</a><br><a href="http://keeganlee.me/post/matching/20191121">撮合引擎开发：对接黑箱</a><br><a href="http://keeganlee.me/post/matching/20191127">撮合引擎开发：解密黑箱流程</a><br><a href="http://keeganlee.me/post/matching/20191130">撮合引擎开发：流程的代码实现</a><br><a href="http://keeganlee.me/post/matching/20191202">撮合引擎开发：缓存和MQ</a><br><a href="http://keeganlee.me/post/matching/20191203">撮合引擎开发：日志输出</a><br><a href="http://keeganlee.me/post/matching/20191204">撮合引擎开发：完结篇</a></p>
<hr>
<h2 id="黑箱引擎"><a href="#黑箱引擎" class="headerlink" title="黑箱引擎"></a>黑箱引擎</h2><p>我们的撮合引擎作为一个相对通用的组件，其实就是一个黑箱，如果想将它应用到各种不同的交易系统，只要有标准的输入和输出，对接是很容易的。</p>
<p>写作此文时的撮合引擎为 1.3 版本，我将其编译构建成可在 Linux amd64 环境运行的可执行文件，并与依赖的配置文件一起压缩成一个压缩包 <strong>matching.zip</strong>。这就成为一个黑箱引擎了。</p>
<p>不过，该黑箱引擎除了对运行系统有要求，还对 Redis 有要求。由于使用了 Redis 的新版 MQ 功能，即 stream 数据结构，要求 Redis 至少是 5.0 版本。</p>
<p>其实，我也可以编译构建成其他系统环境的可执行文件，如 Windows 或 Mac 系统。但作为一款商业软件以及对性能的一些要求，运行在 Linux 环境更合适。</p>
<p>后面，我们就来看看，如果要将这个黑箱引擎应用到自己的交易系统中，如何对接？</p>
<h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><p>安装部署的系统环境需是 Linux amd64 的，另外，如果要让撮合性能更快，建议 Redis 与撮合引擎可以使用同一服务器，这可以减少不同服务器之前的传输耗时。</p>
<p>按照以下步骤操作就可以将撮合引擎安装部署到运行环境了：</p>
<ol>
<li>将 <strong>matching.zip</strong> 压缩包上传到运行环境；</li>
<li>在运行环境解压 <strong>matching.zip</strong> 压缩包，解压后有一个可执行文件和一个文件夹：<ul>
<li><strong>matching</strong>：这是撮合引擎程序的可执行文件</li>
<li><strong>conf</strong>：存放配置文件的目录，里面就一个配置文件 <strong>config.yaml</strong></li>
</ul>
</li>
<li>修改配置文件为自己想要的配置值：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="string">:9466</span>  <span class="string">//撮合引擎程序启动监听的端口</span></span><br><span class="line"><span class="attr">log:</span>                 <span class="string">//输出日志配置</span></span><br><span class="line"><span class="attr">  fileDir:</span> <span class="string">logs</span>      <span class="string">//输出日志存放的目录</span></span><br><span class="line"><span class="attr">  fileName:</span> <span class="string">matching</span> <span class="string">//日志文件名，会按日期分割</span></span><br><span class="line"><span class="attr">  prefix:</span>            <span class="string">//日志消息前缀</span></span><br><span class="line"><span class="attr">  level:</span> <span class="string">debug</span>       <span class="string">//日志级别，由低到高为：debug、info、warn、error</span></span><br><span class="line"><span class="attr">redis:</span></span><br><span class="line"><span class="attr">  addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379</span>  <span class="string">//Redis地址</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>如果使用默认配置，请确认运行环境本地已安装并启动了Redis并运行在6379端口；</li>
<li>如果不用默认配置，依然需要确认Redis能正确连接；</li>
<li>运行以下命令，后台启动撮合引擎程序：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./matching &amp;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>运行以下命令，检查程序是否启动成功：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux|grep matching</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>程序启动成功后，会在配置的日志目录生成日志文件，默认为与 <strong>matching</strong> 可执行文件同目录下的 logs/matching.log；</li>
<li>至此，撮合引擎程序安装部署成功。</li>
</ol>
<h2 id="对接输入"><a href="#对接输入" class="headerlink" title="对接输入"></a>对接输入</h2><p>接入撮合引擎只需要对接三个 HTTP 接口，接口统一采用 POST 方法，参数统一用 json 格式，传 body。</p>
<h3 id="1-开启撮合"><a href="#1-开启撮合" class="headerlink" title="1. 开启撮合"></a>1. 开启撮合</h3><p>开启指定交易标的（交易对）的撮合功能。</p>
<h4 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h4><ul>
<li>POST  <em>/openMatching</em></li>
</ul>
<h4 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h4><ul>
<li><strong>symbol</strong>：字符串类型，必传字段，交易标的(交易对)的标识，如 BTC_USDT</li>
<li><strong>price</strong>：数字类型，非必传字段，默认为 0，开盘价</li>
</ul>
<h4 id="请求示例"><a href="#请求示例" class="headerlink" title="请求示例"></a>请求示例</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST  /openMatching</span><br><span class="line">Body：</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"symbol"</span>: <span class="string">"BTC_USDT"</span>,</span><br><span class="line">  <span class="attr">"price"</span>: <span class="number">8219.85</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"code"</span>:<span class="number">0</span>,<span class="attr">"msg"</span>:<span class="string">"OK"</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-关闭撮合"><a href="#2-关闭撮合" class="headerlink" title="2. 关闭撮合"></a>2. 关闭撮合</h3><p>关闭指定交易标的（交易对）的撮合功能。</p>
<h4 id="HTTP请求-1"><a href="#HTTP请求-1" class="headerlink" title="HTTP请求"></a>HTTP请求</h4><ul>
<li>POST  <em>/closeMatching</em></li>
</ul>
<h4 id="请求参数-1"><a href="#请求参数-1" class="headerlink" title="请求参数"></a>请求参数</h4><ul>
<li><strong>symbol</strong>：字符串类型，必传字段，交易标的(交易对)的标识，如 BTC_USDT</li>
</ul>
<h4 id="请求示例-1"><a href="#请求示例-1" class="headerlink" title="请求示例"></a>请求示例</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST  /closeMatching</span><br><span class="line">Body：</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"symbol"</span>: <span class="string">"BTC_USDT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="响应数据-1"><a href="#响应数据-1" class="headerlink" title="响应数据"></a>响应数据</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"code"</span>:<span class="number">0</span>,<span class="attr">"msg"</span>:<span class="string">"OK"</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-处理订单"><a href="#3-处理订单" class="headerlink" title="3. 处理订单"></a>3. 处理订单</h3><p>接收下单和撤单请求。</p>
<h4 id="HTTP请求-2"><a href="#HTTP请求-2" class="headerlink" title="HTTP请求"></a>HTTP请求</h4><ul>
<li>POST  <em>/handleOrder</em></li>
</ul>
<h4 id="请求参数-2"><a href="#请求参数-2" class="headerlink" title="请求参数"></a>请求参数</h4><ul>
<li><strong>symbol</strong>：字符串类型，必传字段，交易标的(交易对)的标识，如 BTC_USDT</li>
<li><strong>action</strong>：字符串类型，必传字段，订单动作，下单=create，撤单=cancel</li>
<li><strong>orderId</strong>：字符串类型，必传字段，订单ID</li>
<li><strong>side</strong>：字符串类型，必传字段，买卖方向，买入=buy，卖出=sell</li>
<li><strong>type</strong>：字符串类型，必传字段，订单类型，包括：limit、limit-ioc、market、market-top5、market-top10、market-opponent，说明见下文</li>
<li><strong>amount</strong>：数字类型，非必传字段，默认为 0，订单交易量，下单时必传，撤单时可不传</li>
<li><strong>price</strong>：数字类型，非必传字段，默认为 0，委托价格，订单类型为市价时可不传</li>
</ul>
<p>订单类型说明：</p>
<ul>
<li><strong>limit</strong>：普通限价</li>
<li><strong>limit-ioc</strong>：IOC限价-即时成交剩余撤销</li>
<li><strong>market</strong>：默认市价-即时成交剩余撤销</li>
<li><strong>market-top5</strong>：市价-最优五档即时成交剩余撤销</li>
<li><strong>market-top10</strong>：市价-最优十档即时成交剩余撤销</li>
<li><strong>market-opponent</strong>：市价-对手方最优价</li>
</ul>
<h4 id="请求示例-2"><a href="#请求示例-2" class="headerlink" title="请求示例"></a>请求示例</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST  /handleOrder</span><br><span class="line">Body：</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"symbol"</span>: <span class="string">"BTC_USDT"</span>,</span><br><span class="line">  <span class="attr">"action"</span>: <span class="string">"create"</span>,</span><br><span class="line">  <span class="attr">"orderId"</span>: <span class="string">"a0001"</span>,</span><br><span class="line">  <span class="attr">"side"</span>: <span class="string">"buy"</span>,</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"limit"</span>,</span><br><span class="line">  <span class="attr">"amount"</span>: <span class="number">0.012</span>,</span><br><span class="line">  <span class="attr">"price"</span>: <span class="number">8230.74</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="响应数据-2"><a href="#响应数据-2" class="headerlink" title="响应数据"></a>响应数据</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"code"</span>:<span class="number">0</span>,<span class="attr">"msg"</span>:<span class="string">"OK"</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对接输出"><a href="#对接输出" class="headerlink" title="对接输出"></a>对接输出</h2><p>撮合引擎有两种输出：<strong>撤单结果</strong>和<strong>成交记录</strong>。统一用 MQ 的方式进行输入，MQ 是保存为 Redis 5.0 版本之后引入的新数据结构 Stream 类型。每个消息队列其实就是一条 stream，关于 stream 的具体用法我就不展开了，大伙自行去网上搜索学习即可。</p>
<h3 id="1-撤单结果"><a href="#1-撤单结果" class="headerlink" title="1. 撤单结果"></a>1. 撤单结果</h3><p>每个不同的 symbol 设置一个 stream，其 key 的格式为：<strong>matching:cancelresults:{symbol}</strong>，value 包含两个字段：</p>
<ul>
<li><strong>orderId</strong>：订单号</li>
<li><strong>ok</strong>：1=成功；0=失败</li>
</ul>
<h3 id="2-成交记录"><a href="#2-成交记录" class="headerlink" title="2. 成交记录"></a>2. 成交记录</h3><p>每个不同的 symbol 也设置一个 MQ，key 的格式为：<strong>matching:trades:{symbol}</strong>，value 包含的字段如下：</p>
<ul>
<li><strong>makerId</strong>：maker订单ID</li>
<li><strong>takerId</strong>：taker订单ID</li>
<li><strong>takerSide</strong>：taker买卖方向</li>
<li><strong>amount</strong>：成交数量</li>
<li><strong>price</strong>：成交价格</li>
<li><strong>timestamp</strong>：成交时间</li>
</ul>
<p>下游服务就可以通过订阅监听这两种输出，之后做后续的处理，比如 K 线行情服务订阅监听成交记录来生成 K 线数据。等撮合引擎完成之后，我下一个要开发的组件就是 K 线行情服务。</p>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>最后，先给大伙看看我们这个黑箱内部的整个 Go 项目的文件目录结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">├── conf                     # 配置文件存放目录，在1.1版本时增加</span><br><span class="line">│   ├── config.yaml          # 配置文件，在1.1版本时增加</span><br><span class="line">├── engine                   # 引擎包</span><br><span class="line">│   ├── init.go              # 初始化</span><br><span class="line">│   ├── order.go             # 委托单</span><br><span class="line">│   ├── order_book.go        # 交易委托账本</span><br><span class="line">│   ├── order_queue.go       # 订单队列</span><br><span class="line">│   ├── run.go               # 具体交易对的撮合引擎启动入口</span><br><span class="line">│   └── trade.go             # 成交记录</span><br><span class="line">├── enum                     # 枚举类型的包</span><br><span class="line">│   ├── order_action.go      # 订单行为，create为下单，cancel为撤单</span><br><span class="line">│   ├── order_side.go        # 买卖方向，buy为买入，sell为卖出</span><br><span class="line">│   ├── order_type.go        # 订单类型，MVP版本(1.0版本)只支持limit，1.3版本共支持7种类型 </span><br><span class="line">│   └── sort_direction.go    # 排序方向，asc为升序，desc为降序</span><br><span class="line">├── errcode                  #</span><br><span class="line">│   ├── code.go              # 定义了各种不同的错误码</span><br><span class="line">│   └── errcode.go           # 错误码的数据结构，包括code和msg两个字段</span><br><span class="line">├── handler                  #</span><br><span class="line">│   ├── close_matching.go    # 接收关闭撮合的请求</span><br><span class="line">│   ├── handle_order.go      # 接收处理订单的请求</span><br><span class="line">│   └── open_matching.go     # 接收开启撮合的请求</span><br><span class="line">├── log                      # 日志包，在1.2版本增加</span><br><span class="line">│   ├── log.go               # 日志输出，在1.2版本增加</span><br><span class="line">├── main.go                  # Go程序唯一入口</span><br><span class="line">├── middleware               # 中间件的包</span><br><span class="line">│   ├── cache                # 缓存包</span><br><span class="line">│   │   └── cache.go         # 缓存操作</span><br><span class="line">│   ├── mq                   # 消息队列包</span><br><span class="line">│   │   └── mq.go            # MQ操作</span><br><span class="line">│   └── redis.go             # 主要做Redis初始化操作</span><br><span class="line">└── process                  #</span><br><span class="line">    ├── close_engine.go      # 关闭引擎</span><br><span class="line">    ├── dispatch.go          # 分发订单</span><br><span class="line">    ├── init.go              # 初始化</span><br><span class="line">    └── new_engine.go        # 启动新引擎</span><br></pre></td></tr></table></figure>

<p>包括 main 包，整个项目总共划分为了 10 个包和 1 个配置文件目录：</p>
<ul>
<li><strong>conf</strong>：存放配置文件的目录。</li>
<li><strong>main</strong>：main 包只有一个 main.go 文件，定义了程序入口函数。</li>
<li><strong>enum</strong>：枚举包实现了几个枚举类型的数据结构，包括订单行为、买卖方向、订单类型和排序方向。</li>
<li><strong>errcode</strong>：存放错误码的包，errcode.go 定义了错误码的数据结构，有 code 和 msg 两个属性；code.go 则定义了一些错误码对象。</li>
<li><strong>handler</strong>：接收 HTTP 请求的函数都放在这个包里，目前也就只有三个 handler 函数。</li>
<li><strong>process</strong>：启动、关闭引擎和分发订单的处理过程都在这个包里，包里还维护着不同交易对的订单通道，用来分发不同交易对的订单。</li>
<li><strong>engine</strong>：引擎包，包含了委托单、交易委托账本、订单队列、成交记录这几个核心的数据结构，以及用于处理交易对撮合的入口函数。</li>
<li><strong>middleware</strong>：存放中间件的包，目前只用到了 Redis 一个中间件。</li>
<li><strong>cache</strong>：缓存包，只有一个 cache.go 文件，缓存操作都在这个文件里定义。</li>
<li><strong>mq</strong>：消息队列包，也只有一个 mq.go 文件，消息的发送就定义在这里。</li>
<li><strong>log</strong>：日志包，实现了日志消息按日期分割并输出到文件。</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本节我们了解到撮合引擎作为一个通用组件，有标准的输入和输出，而且这输入和输出都非常简单。也开始给大家展示了黑箱内部的文件目录结构，开始探究黑箱的内部逻辑，后续章节将陆续揭露这些内部实现逻辑。</p>
<p>本节预留的思考题：揣测下为什么我要将下单和撤单定义到同一个接口？而不是分开两个接口？分两个接口和用一个接口各有何优劣？</p>
<hr>
<p>扫描以下二维码即可关注公众号（公众号名称：Keegan小钢）</p>
<img src="/post/matching/20191121/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/matching/20191119/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/matching/20191119/" class="post-title-link" itemprop="url">撮合引擎开发:数据结构设计</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-19 20:21:14" itemprop="dateCreated datePublished" datetime="2019-11-19T20:21:14+08:00">2019-11-19</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-04 16:46:38" itemprop="dateModified" datetime="2019-12-04T16:46:38+08:00">2019-12-04</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/matching/" itemprop="url" rel="index"><span itemprop="name">matching</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/matching/20191119"><strong>http://keeganlee.me/post/matching/20191119</strong></a><br>微信公众号：名称：Keegan小钢；微信号：keeganlee_me<br>写于2019-11-19</p>
<hr>
<p><a href="http://keeganlee.me/post/matching/20191117">撮合引擎开发：开篇</a><br><a href="http://keeganlee.me/post/matching/20191118">撮合引擎开发：MVP版本</a><br><a href="http://keeganlee.me/post/matching/20191119">撮合引擎开发：数据结构设计</a><br><a href="http://keeganlee.me/post/matching/20191121">撮合引擎开发：对接黑箱</a><br><a href="http://keeganlee.me/post/matching/20191127">撮合引擎开发：解密黑箱流程</a><br><a href="http://keeganlee.me/post/matching/20191130">撮合引擎开发：流程的代码实现</a><br><a href="http://keeganlee.me/post/matching/20191202">撮合引擎开发：缓存和MQ</a><br><a href="http://keeganlee.me/post/matching/20191203">撮合引擎开发：日志输出</a><br><a href="http://keeganlee.me/post/matching/20191204">撮合引擎开发：完结篇</a></p>
<hr>
<h2 id="交易委托账本"><a href="#交易委托账本" class="headerlink" title="交易委托账本"></a>交易委托账本</h2><p><strong>交易委托账本(OrderBook)</strong>是整个撮合引擎里最核心也是最复杂的数据结构，每个交易对都需要维护一份交易委托账本，账本里保存着指定交易对所有待撮合的委托单。每份账本都有两个队列，一个卖单队列和一个买单队列，两个队列都需要按照<strong>价格优先、时间优先</strong>的原则进行排序。</p>
<p>所谓价格优先、时间优先，即是说：卖单队列的委托单是按价格由低到高排序，买单队列则相反，按价格由高到低排序；相同价格的委托单，则是按下单时间的先后来排序。</p>
<img src="/post/matching/20191119/orderbook.png">

<p>如上图，每个小方格表示一个委托单，标 <strong>H</strong> 的是排在头部的委托单，<strong>N</strong>则是与 H 同价格但下单时间上排在 H 后面的委托单，<strong>S</strong>则是下一档位价格的第一个委托单。可以从图中明显看出，横向上，委托单是按时间排序的，竖向上，又是按价格排序的。</p>
<p>撮合的时候，都是先取出 <strong>H</strong> 委托单与新委托单进行匹配。如果新委托单是<strong>买单</strong>，则获取<strong>卖单队列</strong>的 H 单出来匹配；如果新委托单是<strong>卖单</strong>，则获取<strong>买单队列</strong>的 H 单。如果 <strong>H</strong> 单全部匹配成交了，那标识为 <strong>N</strong> 的委托单就变成了新的 <strong>H</strong> 单。如果第一排的全部委托单都匹配完了，那就 <strong>S</strong> 单会变成新的 <strong>H</strong> 单。</p>
<p>交易委托账本可支持一些操作方法，包括初始化、增加买卖委托单、移除买卖委托单、获取头部委托单等。交易委托账本的类图大概如下：</p>
<img src="/post/matching/20191119/class-orderbook.png">

<p>其中，<strong>getHead</strong> 和 <strong>popHead</strong> 方法的区别是：get 只读头部委托单但不会移除它，而 pop 会将头部委托单从队列中移除。</p>
<h2 id="订单队列"><a href="#订单队列" class="headerlink" title="订单队列"></a>订单队列</h2><p>买单队列和卖单队列可以设计为使用统一的订单队列类型，两者只有价格排序方向不同，那订单队列就可以用一个属性来表示排序方向。队列里的所有订单可以采用二维数组或二维链表来保存，考虑到主要操作是插入和删除，用链表比用数组效率更高。如果想让操作效率更高，那就需要使用更复杂的数据结构了，比如再结合跳表。目前版本为了简单，采用简单的二维链表即可。</p>
<p>使用二维链表的话，那链表中的每个元素保存的就是横向上按时间排序的订单链表，这些订单链表又组成了竖向上按价格排序的链表。</p>
<p>另外，还可以保存一个 Map，将价格作为 Key，将同价格的订单链表作为 Value，这样就能加快同价格订单的查询。</p>
<p>订单队列可支持的操作方法也很简单，包括初始化、新增订单、移除订单、获取头部订单等。其类图大概如下：</p>
<img src="/post/matching/20191119/class-orderqueue.png">

<p><strong>sortBy</strong> 指定价格排序的方向，<strong>parentList</strong> 保存整个二维链表，第一维以价格排序，第二维以时间排序，<strong>elementMap</strong> 则是 Key 为价格、Value 为第二维订单链表的键值对。</p>
<h2 id="委托单"><a href="#委托单" class="headerlink" title="委托单"></a>委托单</h2><p>委托单则是撮合引擎里最基本的数据结构了，其数据主要是从上游服务传输过来的，其类图大概如下：</p>
<img src="/post/matching/20191119/class-order.png">

<p><strong>action</strong> 声明对委托单要进行哪种操作，我们只需支持两种操作：<strong>下单(create)</strong>和<strong>撤单(cancel)</strong>。<strong>symbol</strong> 指定该委托单所属的交易对，<strong>orderId</strong> 是该委托单的唯一标识，<strong>side</strong> 指明是<strong>买入(buy)</strong>还是<strong>卖出(sell)</strong>。<strong>type</strong> 表示交易类型，即<strong>限价交易(limit)</strong>或<strong>市价交易(market)</strong>等，我们的 MVP 版本只支持限价交易。<strong>amount</strong> 是购买数量，<strong>price</strong> 是购买价格，<strong>timestamp</strong> 则是订单时间。</p>
<p><strong>toJson()</strong> 和 <strong>fromJson()</strong> 方法是为了支持订单数据传输时的序列化和反序列化。</p>
<h2 id="成交记录"><a href="#成交记录" class="headerlink" title="成交记录"></a>成交记录</h2><p>撮合成交的委托单就会生成对应的成交记录，成交记录需要发布到 MQ 给下游服务消费。成交记录的数据结构如下图：</p>
<img src="/post/matching/20191119/class-trade.png">

<p><strong>maker</strong> 指挂单，是本来挂在交易委托账本里的订单，而 <strong>taker</strong> 则是吃单，是指吃掉 maker 的订单。<strong>makerId</strong> 和 <strong>takerId</strong> 就是挂单和吃单的订单 ID。<strong>takerSide</strong> 就是吃单的买卖方向，我们在行情软件里看到的成交记录会有不同颜色，就是由这个 takerSide 决定的。<strong>amount</strong> 就是成交数量，<strong>price</strong> 指成交价格，<strong>timestamp</strong> 是成交时间。</p>
<h2 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h2><p>我们需要用 Redis 缓存委托单数据和撮合中的交易对数据，主要有两个作用，一是可以对请求做去重处理，二是程序重启后可以恢复数据。</p>
<p>由于网络中断或延迟，或其他异常情况，上游服务有可能会重复发送相同请求给到撮合引擎，因此，程序是需要做去重处理的，有了数据缓存就可以解决去重问题了。另外，由于我们采用的是内存撮合，撮合时的数据都是直接保存在程序内存里的，一旦程序退出了，那所有数据也都消失了，重启后就需要从其他地方重新加载数据，采用Redis缓存就可以很快速地缓存数据和加载数据。</p>
<p>开启一个交易对引擎时需要将交易对缓存，关闭时则从缓存中删除，保证缓存的都是运行中的交易对，当重启时，就可以重新启动这些交易对的撮合引擎了。需要缓存的交易对数据包括两个：<strong>symbol</strong> 和 <strong>price</strong>，即标识和价格。关于价格，每次产生新的成交记录时，价格也需要同步更新，因此价格的更新会非常频繁。而标识基本无需更新，因此两者最好分开缓存。</p>
<p>所有交易对的 symbol 可以统一缓存到一个 set 里。我们可以将 key 值设置为 <strong>matching:symbols</strong>，用 Redis 的 <strong>sadd</strong> 和 <strong>srem</strong> 命令将不同的 symbol 缓存到该 key 值里或从 key 中删除。而 price 则可以保存为 string 类型，为不同交易对的价格设置不同的 key，key 值可以设置为 <strong>matching:price:{symbol}</strong>，{symbol} 为具体交易对的 symbol 值。</p>
<p>每个委托单也需要缓存和更新，为了能够从缓存中最快地读取和更新委托单数据，最好为每个委托单都设置一个单独的 key，key 值可以设置为 <strong>matching:order:{symbol}:{orderId}:{action}</strong>，而 value 值建议设置为 hash 类型，因为 hash 类型特别适合存储结构化的对象。</p>
<p>交易对和委托单数据都缓存了，就能够解决去重问题和程序重启后重新启动各交易对的撮合引擎了，但其实还有一个问题，撮合引擎里的交易委托账本如何恢复？该问题先留给大伙去思考，后续章节我再来讲解我的方案。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>撮合引擎里涉及到的数据结构其实并不多，最复杂的也只有交易委托账本，其设计还会直接关系到撮合的速度。Redis 缓存的设计也有些学问在里面，设计得不好也一样会影响整体的撮合性能。本小节完成了数据结构的设计，下一小节我们就开始深入到代码实现。</p>
<p>最后，请抽时间研究下遗留的思考题：撮合引擎里的交易委托账本如何恢复？</p>
<hr>
<p>扫描以下二维码即可关注公众号（公众号名称：Keegan小钢）</p>
<img src="/post/matching/20191119/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/matching/20191118/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/matching/20191118/" class="post-title-link" itemprop="url">撮合引擎开发:MVP版本</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-18 20:21:14" itemprop="dateCreated datePublished" datetime="2019-11-18T20:21:14+08:00">2019-11-18</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-04 16:46:50" itemprop="dateModified" datetime="2019-12-04T16:46:50+08:00">2019-12-04</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/matching/" itemprop="url" rel="index"><span itemprop="name">matching</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/matching/20191118"><strong>http://keeganlee.me/post/matching/20191118</strong></a><br>微信公众号：名称：Keegan小钢；微信号：keeganlee_me<br>写于2019-11-18</p>
<hr>
<p><a href="http://keeganlee.me/post/matching/20191117">撮合引擎开发：开篇</a><br><a href="http://keeganlee.me/post/matching/20191118">撮合引擎开发：MVP版本</a><br><a href="http://keeganlee.me/post/matching/20191119">撮合引擎开发：数据结构设计</a><br><a href="http://keeganlee.me/post/matching/20191121">撮合引擎开发：对接黑箱</a><br><a href="http://keeganlee.me/post/matching/20191127">撮合引擎开发：解密黑箱流程</a><br><a href="http://keeganlee.me/post/matching/20191130">撮合引擎开发：流程的代码实现</a><br><a href="http://keeganlee.me/post/matching/20191202">撮合引擎开发：缓存和MQ</a><br><a href="http://keeganlee.me/post/matching/20191203">撮合引擎开发：日志输出</a><br><a href="http://keeganlee.me/post/matching/20191204">撮合引擎开发：完结篇</a></p>
<hr>
<p>开篇文章发出去之后，我的撮合引擎被一位超级大佬（曾担任上交所的首席架构师）定位为玩具，直接将我的撮合引擎和国家级撮合引擎作对比了。如果我的撮合引擎达到上交所级别，那就不止值5万了，估计至少值500万了。不过，我的撮合引擎随着不断升级迭代，以后能达到国家级别也说不定。为了避免再次出现这种尴尬，我还是先说明清楚对此撮合引擎的定位。</p>
<h2 id="MVP版本需求"><a href="#MVP版本需求" class="headerlink" title="MVP版本需求"></a>MVP版本需求</h2><p>《精益创业》有个核心概念叫 <strong>MVP</strong>(Minimum Viable Product)，即<strong>最小可行性产品</strong>。我的撮合引擎第一个版本也是一个 MVP，只实现最基础的功能。所谓最基础的功能，即是说，如果移除了该功能，整个系统都无法完成工作。当然，我们还要加上应用场景，应用于一个初创的小交易平台和应用于像火币、币安甚至深交所、上交所这样庞大的交易平台，对基础功能的定义范围是有很大区别的。我所要做的 MVP 版本，只要适用于小交易平台即可。</p>
<p>这里我要稍微展开聊下产品设计的问题，很多团队——尤其是初创团队，做第一版产品的时候，总觉得这个功能很重要、那个功能很重要，都往第一版的产品里面加。其实，做第一版的时候，更多的应该是做减法，而不是做加法。很多看起来很重要的功能，大部分都是属于那种有了它更好，但没有它也不是整个产品就运行不下去了。</p>
<p>下面我们就来讨论下 MVP 版本的撮合引擎具体要实现哪些功能。</p>
<p>我们知道，撮合有<strong>集合竞价</strong>和<strong>连续竞价</strong>两种方式，但对于我们的 MVP 版本来说，是否有必要两种撮合方式都支持呢？其实，在币圈，不管是小交易所还是大交易所，基本只采用连续竞价的方式。我以前从事的贵金属交易平台，也同样没有集合竞价这一步。这也说明，集合竞价对一个交易所来说，其实并不是必需的。既然如此，那第一版的撮合引擎其实就可以先把集合竞价功能砍掉。</p>
<p>支持下单和撤单则是必需的，这是一个交易所最最基础的功能，没有这两个功能，交易所就没意义了。下委托单一般还分有几种不同的类型，包括<strong>限价</strong>、<strong>市价</strong>、<strong>止盈止损</strong>等，最简单的就是限价，这也是所有交易所都必须支持的交易类型，初创交易所一般也只先支持限价交易，所以我们的 MVP 版本也只先支持限价交易即可。</p>
<p>下单和撤单的结果还需要通过事件的方式发送出去，其他服务会监听这些事件并做相应的后续处理。</p>
<p>维护<strong>交易委托账本(OrderBook)</strong>也是必需的，撮合就是和 OrderBook 里的订单进行匹配成交，暂时没成交的就会保存在 OrderBook 里。</p>
<p>另外，我们也要采用<strong>内存撮合</strong>技术，因此，OrderBook 其实是直接保存在程序的内存中的。那么，如果程序异常退出的话，那保存的数据也被清空了。所以，我们还需要引入缓存用来备份数据。当程序重启时，可以从缓存中重新加载数据。</p>
<p>MVP 版本还要支持多个交易标的的撮合，因为我们的 MVP 版本撮合引擎只是个单机版的程序，总不能只支持一个交易标的吧。</p>
<p>还要支持开启和关闭指定交易标的撮合的功能，开启撮合时需要做一些初始化的操作，包括初始化开盘价，而关闭撮合后则会删除数据、释放资源等。</p>
<p>汇总一下，我们的 MVP 版本要实现以下这些功能：</p>
<ol>
<li>支持连续竞价的撮合方式；</li>
<li>支持限价交易、支持撤单；</li>
<li>支持下单和撤单结果的下发；</li>
<li>采用内存撮合技术，在内存里维护交易委托账本；</li>
<li>需要缓存数据，当程序重启时，可以恢复数据；</li>
<li>支持多个交易标的的撮合；</li>
<li>支持开启和关闭指定交易标的的撮合功能。</li>
</ol>
<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>需求确定了，接下来就要确定技术方案了，先聊下一些技术选型吧。</p>
<p>首先是开发语言，我的选择是 <strong>Golang</strong>，原因很简单，Golang 有着接近 C/C++ 的执行性能，但比 C/C++ 有着更高的开发效率，既能满足撮合引擎对性能的要求，也能满足我们快速实现产品的需求。当然，用其他语言也能实现，毕竟，设计思路是通用的。</p>
<p>下单和撤单，开启和关闭撮合，以及结果的下发，都涉及到与其他服务的通信。服务间的通信主要就两种可选方案：同步调用的 <strong>RPC</strong> 和异步调用的 <strong>MQ</strong>。同步调用能使请求得到即时的响应，通信相对高效且可靠性较高，但只适用于一对一的通信，且如果并发请求出现超负荷时可能会引发大量的请求超时甚至服务宕机。而 MQ 支持一对多的通信，也因为有缓存队列，能避免并发请求达到峰值时出现服务不可用的情况，但也因为多了个消息中间件，传输有延迟，且请求无法得到即时的应答，还存在丢消息的可能，因此可靠性就比不上同步的 RPC 方式。</p>
<p>对于我们的应用场景来说，结果的下发只能使用 MQ，因为我们并不清楚有多少个下游服务会消费我们的结果消息，也无法要求下游服务提供统一的 RPC 接口供我们调用。下单和撤单请求，则最好采用 RPC 同步方式调用，一是可以对一些无效的请求即时返回响应，二是能减少 MQ 的传输延迟，三是能保证可靠性。对于并发请求超负荷的问题，应该在更上层的网关服务就做好负载均衡，而不应该丢给撮合引擎来处理。</p>
<p>不过，RPC 和 MQ 也有多种具体的实现方案。RPC 方案有 <strong>REST</strong>、<strong>gRPC</strong>、<strong>Thrift</strong>、<strong>rpcx</strong> 等，MQ 方案有 <strong>Kafka</strong>、<strong>RocketMQ</strong>、<strong>RabbitMQ</strong>、<strong>Redis</strong>等。这些不同的具体方案之间的差异性我就不展开了，感兴趣的读者们可以自己去百度或 Google。RPC 方案我们选择最简单的 REST 即可，开发、对接和测试都比较方便。MQ 方案则选定 Redis，因为 Redis 从 5.0 版本开始引入了 <strong>Stream</strong> 数据结构，提供了类似Kafka的消息队列功能，但由于 Redis 的数据是存储在内存中的，其处理速度相比其他 MQ 快很多。另外，我们还要用 Redis 做缓存，用同一个中间件也更方便。</p>
<h2 id="软件结构"><a href="#软件结构" class="headerlink" title="软件结构"></a>软件结构</h2><img src="/post/matching/20191118/v1.0-architecture.png">

<p>上图就是我们 MVP 版本的撮合服务的软件结构设计图，很简单吧。其实，就是按照业务流程进行了分层而已。分层是最简单的一种架构方式，其实任何庞大复杂的系统，第一步拆解都可以按业务流程进行分层。</p>
<p><strong>Handler</strong> 接收由上游服务发过来的 HTTP 请求，我们只需定义三个接口：</p>
<ul>
<li><strong>OpenMatching</strong>：开启撮合，只需接收两个参数：交易标的（交易对）和开盘价。</li>
<li><strong>CloseMatching</strong>：关闭撮合，只需一个参数：交易标的（交易对）。</li>
<li><strong>HandleOrder</strong>：接收委托单，会有一个参数 <strong>Action</strong> 表示动作是下单还是撤单，其他参数则是委托单的数据了，包括订单 ID、交易对、买卖方向、委托数量、委托价格等。</li>
</ul>
<p>Handler 对请求做一些常规的校验之后，就会转发给相应的 Process 做处理，我们也定义了对应的三个 <strong>Process</strong>：</p>
<ul>
<li><strong>NewEngine</strong>：创建一个新的协程/线程，作为指定交易对的撮合引擎。</li>
<li><strong>CloseEngine</strong>：将指定交易对的撮合引擎关闭。</li>
<li><strong>Dispatch</strong>：将不同交易对的委托单分发到相应的撮合引擎。</li>
</ul>
<p><strong>Engine</strong> 即是每个交易对的撮合引擎协程或线程了。由于每个交易对的撮合引擎对委托单的处理必须是串行的，因此，Dispatch 时需将委托单先扔到不同交易对的有序队列里去，再由 Engine 从各自的队列中消费取出委托单进行撮合处理。</p>
<p><strong>Redis</strong> 既用来做数据缓存，也用来做消息队列。缓存的数据主要是当前开启了撮合的交易对，以及撮合引擎里的交易委托账本。为了保证数据的一致性，账本里每个委托单的每一次变化，都需要更新到 Redis 中去。当撮合引擎重启时，就需要从 Redis 中读取缓存的委托单，重新初始化交易委托账本。这样，就能保证程序退出后重启，能恢复到退出前的状态。消息队列则可用 Redis 的新数据结构 Stream 实现，用来发送成交记录和撤单结果。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们第一版先做个 MVP，做个单体版的撮合服务，支持连续竞价、限价委托、撤单、开启和关闭撮合、支持多交易对等功能，采用内存撮合技术。软件结构上主要分为 Handler、Process、Engine 三个层级，底层用 Redis 做数据缓存和消息队列。下一篇我们来设计数据结构。</p>
<p>留一个思考题：Dispatch 分发委托单到 Engine 时，有序队列可以如何实现？</p>
<hr>
<p>扫描以下二维码即可关注公众号（公众号名称：Keegan小钢）</p>
<img src="/post/matching/20191118/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/matching/20191117/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/matching/20191117/" class="post-title-link" itemprop="url">撮合引擎开发:开篇</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-17 20:21:14" itemprop="dateCreated datePublished" datetime="2019-11-17T20:21:14+08:00">2019-11-17</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-04 16:45:58" itemprop="dateModified" datetime="2019-12-04T16:45:58+08:00">2019-12-04</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/matching/" itemprop="url" rel="index"><span itemprop="name">matching</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/matching/20191117"><strong>http://keeganlee.me/post/matching/20191117</strong></a><br>微信公众号：名称：Keegan小钢；微信号：keeganlee_me<br>写于2019-11-17</p>
<hr>
<p><a href="http://keeganlee.me/post/matching/20191117">撮合引擎开发：开篇</a><br><a href="http://keeganlee.me/post/matching/20191118">撮合引擎开发：MVP版本</a><br><a href="http://keeganlee.me/post/matching/20191119">撮合引擎开发：数据结构设计</a><br><a href="http://keeganlee.me/post/matching/20191121">撮合引擎开发：对接黑箱</a><br><a href="http://keeganlee.me/post/matching/20191127">撮合引擎开发：解密黑箱流程</a><br><a href="http://keeganlee.me/post/matching/20191130">撮合引擎开发：流程的代码实现</a><br><a href="http://keeganlee.me/post/matching/20191202">撮合引擎开发：缓存和MQ</a><br><a href="http://keeganlee.me/post/matching/20191203">撮合引擎开发：日志输出</a><br><a href="http://keeganlee.me/post/matching/20191204">撮合引擎开发：完结篇</a></p>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自从有人在微信群里开价5万求购Golang版的撮合引擎之后，我就想自己开发一款，毕竟，以我的经验来说，开发个高性能的撮合引擎并没什么难度。</p>
<p>说干就干，于是，利用业余时间慢慢开发出了一款<strong>Golang</strong>版的高性能撮合引擎，前前后后花了大概一个月的时间。再想想自己好久没更新文章了，我的个人IP都已经生锈了，也应该发大招磨一磨了。因此决定，干脆就以连载的方式，分享下我是如何设计与实现这款价值超5万的撮合引擎的。</p>
<p>本来，想发成掘金小册，收点稿费，毕竟这是个具有很大商业价值的软件，但问了掘金的人员，他们目前不接收这类主题。最终决定免费发布，还可以多发几个渠道，说不定还能给我多带来些关注量。</p>
<p>好了，下面开始进入撮合引擎系列的正题。</p>
<h2 id="撮合引擎简介"><a href="#撮合引擎简介" class="headerlink" title="撮合引擎简介"></a>撮合引擎简介</h2><p>撮合引擎是所有撮合交易系统的核心组件，不管是股票交易系统——包括现货交易、期货交易、期权交易等，还是数字货币交易系统——包括币币交易、合约交易、杠杆交易等，以及各种不同的贵金属交易系统、大宗商品交易系统等，虽然各种不同交易系统的交易标的不同，但只要都是采用撮合交易模式，都离不开撮合引擎。</p>
<p>撮合引擎是可以具有通用性的，一套具有通用性的撮合引擎实现理论上可以应用到任何撮合交易系统中，而无需做任何代码上的调整。即是说，同一套撮合引擎实现，既可以应用在股票交易系统，也可以应用在数字货币交易系统，可以用于现货交易，也可以用于合约交易等。</p>
<p>那么，一套具有通用性的撮合引擎应该具备哪些功能呢？确定该问题的答案之前，我们先简单梳理一下一个完整的交易流程是怎样的？一般会包括以下步骤：</p>
<ol>
<li>系统开放某个交易标的的交易功能。</li>
<li>用户提交该交易标的的买卖申报，即<strong>委托单</strong>。</li>
<li>系统验证委托单是否有效，包括交易标的是否处于可交易的状态、订单的价格和数量是否符合要求等。</li>
<li>确定该委托单的<strong>挂单(Maker)</strong>费率和<strong>吃单(Taker)</strong>费率。</li>
<li>检查用户的资产账户情况，包括账户状态是否交易受限，是否有足够资金用于下单等。</li>
<li>将详细的委托单数据持久化到数据库，并冻结用户账户中相应数量的资金。</li>
<li>将委托单进行撮合处理，即在<strong>交易委托账本(OrderBook)</strong>中寻找能与该委托单匹配成交的订单，匹配的结果可能是：全部成交、部分成交或无匹配。全部成交或部分成交时，可能在交易委托账本中存在一个或多个匹配的订单，即会产生一条或多条成交记录。当无匹配或部分成交时，委托单的部分数据包括剩余未成交的数量会暂时保存到交易委托账本中，等待与后续的委托单匹配撮合。</li>
<li>将撮合产生的成交记录持久化到数据库，并根据历史成交记录生成市场数据，如K线数据、今日涨跌幅等。</li>
<li>更新数据库中所有成交订单的委托单数据，以及更新订单用户的资产账户余额。</li>
<li>将更新的订单数据、市场数据等发送给到前台。</li>
</ol>
<p>整个交易流程中涉及到多个服务，包括用户服务、账户服务、订单服务、撮合服务、市场数据服务等。其中，只有第7步是撮合引擎处理的。从单一职责原则来说，撮合引擎就应该只做一件事，那就是<strong>负责撮合订单</strong>。撮合之前的委托单持久化、冻结资金等，以及撮合之后生成K线数据等，都不应该属于撮合引擎的职责。</p>
<h2 id="撮合竞价方式"><a href="#撮合竞价方式" class="headerlink" title="撮合竞价方式"></a>撮合竞价方式</h2><p>撮合竞价方式一般有两种，一是<strong>集合竞价</strong>，二是<strong>连续竞价</strong>。股票交易系统一般会在不同交易时间段采用不同的竞价方式，比如在开盘或收盘时采用集合竞价，从而产生<strong>开盘价</strong>或<strong>收盘价</strong>，其余时间采用连续竞价。而大多数字货币交易系统则没有集合竞价，只有连续竞价，开盘价一般是在开始交易之前就设定好的。</p>
<h3 id="集合竞价"><a href="#集合竞价" class="headerlink" title="集合竞价"></a>集合竞价</h3><p>所谓集合竞价，是指对一段时间内接收的买卖委托单一次性集中撮合的竞价方式。以深沪的股票交易系统为例，在每个交易日的 9:15~9:25 期间是集合竞价时间。在该时间段内，系统陆续接收到的委托单不会即时成交，而是先将所有委托单按照<strong>价格优先、时间优先</strong>的原则排序，并在此基础上，找出一个基准价格，使它能同时满足以下三个条件：</p>
<ol>
<li>可实现<strong>最大成交量</strong>的价格；</li>
<li>高于该价格的买单与低于该价格的卖单能全部成交的价格；</li>
<li>与该价格相同的买方或卖方至少有一方全部成交的价格。</li>
</ol>
<p>在 9:25 分结束的时候，该基准价格就被确定为<strong>成交价格</strong>，所有高于该价格的买单与低于该价格的卖单都将以该价格成交。未能成交的委托单，则自动转入连续竞价。</p>
<p>不过，如果满足以上三个条件的价格存在两个或两个以上呢？对此，深交所和上交所的处理方案有所不同，深交所会取距<strong>前收盘价</strong>最近的价格为成交价，而上交所则取使<strong>未成交量</strong>最小的价格为成交价，如果未成交量最小的价格仍不止一个，则取<strong>中间价</strong>为成交价。</p>
<p>集合竞价的主要目的就是为了确定开盘价或收盘价。</p>
<h3 id="连续竞价"><a href="#连续竞价" class="headerlink" title="连续竞价"></a>连续竞价</h3><p>所谓连续竞价，也是我们所熟悉的竞价方式，是指对买卖委托单逐笔连续撮合的竞价方式。用户的挂单，只要满足成交条件，就能即时成交。而集合竞价，则要等到最后一刻才会成交。</p>
<p>连续竞价时，依然要满足价格优先、时间优先的成交原则：</p>
<ol>
<li><strong>价格优先</strong>：买单则价格较高者能优先成交，卖单则是价格较低者能优先成交。</li>
<li><strong>时间优先</strong>：买卖方向和价格相同的委托单，先申报的委托单会比后申报的委托单优先成交。</li>
</ol>
<p>另外，买入价必须大于或等于卖出价才能撮合成交。当买入价等于卖出价时，成交价就是买入价或卖出价。当买入价大于卖出价时，则还要参考前一笔成交价来确定最新成交价。假设买入价为 B，卖出价为 S，前一笔成交价为 P，最新成交价为 N，那么：</p>
<ul>
<li>如果 P &gt;= B，则 N = B</li>
<li>如果 P &lt;= S，则 N = S</li>
<li>如果 B &gt; P &gt; S，则 N = P </li>
</ul>
<p>一套通用的撮合引擎应该两种竞价方式都支持，但对于同一交易标的来说，两种竞价方式不能同时进行，因此设计上需要考虑如何在两种竞价方式之间切换，具体的实现思路在后续章节我们再展开来讲。</p>
<h2 id="质量需求"><a href="#质量需求" class="headerlink" title="质量需求"></a>质量需求</h2><p>我们的撮合引擎除了要满足以上所说的功能需求，还应该满足一些质量需求，尤其对<strong>可用性</strong>、<strong>可伸缩性</strong>和<strong>性能</strong>的要求较高。另外，为了达到通用，也要满足<strong>可复用性</strong>的需求。</p>
<p>先说下可复用性，我们期望的是该撮合引擎既能用于股票交易系统，也能用于数字货币交易系统，既能用于币币交易，也能用于合约交易。因此，该撮合引擎要避免引入与具体系统强相关的业务逻辑，以加强它的可复用性。</p>
<p>再看看性能，要衡量一个撮合引擎的性能，就看它处理每个交易对的 <strong>TPS</strong> 有多高，即每秒钟能处理多少笔相同交易对的委托单。以前，基于数据库的撮合技术，TPS 一般只有10笔/秒。而现在基本都是采用内存撮合技术，TPS 很容易就能达到1000笔/秒，如果使用独占的高性能服务器，1万笔/秒甚至更高的 TPS 都不难达到。</p>
<p>接着谈谈可伸缩性，我们的每一个撮合引擎既可以同时处理多个交易标的，也可以只处理单个交易标的。当交易标的和并发量增多的时候，可以增加服务器，部署成撮合引擎集群，分别用来处理不同的交易标的，从而能够实现负载均衡。</p>
<p>最后聊聊可用性，高可用主要体现在两点，一是故障率要低，二是对故障维修的时间要短。要降低故障率，那撮合引擎就需要有较高的健壮性，对于可能导致引擎出故障的各种异常情况要考虑好并设计好解决方案。另外，还可以采用多机热备份技术来提高可用性，而且要保证互备服务器之间的数据一致，那就需要引入内存状态机复制方案，实现上会复杂很多。</p>
<p>不过，我们并非一下子就要达到很高的质量要求，因为要求越高，其架构和实现会越复杂。我们可以先从简单的版本开始，然后不断升级迭代。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们目的是实现一套通用的撮合引擎，要支持集合竞价和连续竞价，还要实现一些质量需求，提高系统的可复用性、性能、可伸缩性、可用性等。后续章节会对这些需求不断深入探讨其设计与实现。另外，我们将采用不断升级迭代的方式来设计和实现多个版本的撮合引擎。</p>
<p>留两个思考题：</p>
<ol>
<li>集合竞价结束的时候，如果不存在符合那三个条件的基准价格，那开盘价又将如何确定？</li>
<li>对于单个交易对，是否可通过横向增加服务器的方式提高其性能？</li>
</ol>
<hr>
<p>扫描以下二维码即可关注公众号（公众号名称：Keegan小钢）</p>
<img src="/post/matching/20191117/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Keegan小钢</p>
              <div class="site-description motion-element" itemprop="description">分享钢哥人生路上的点点滴滴</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Keegan小钢</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.1.2</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/affix.js?v=7.1.2"></script>

  <script src="/js/schemes/pisces.js?v=7.1.2"></script>




  

  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
