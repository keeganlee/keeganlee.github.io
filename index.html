<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="分享钢哥人生路上的点点滴滴">
<meta name="keywords" content="个人成长 全栈 区块链">
<meta property="og:type" content="website">
<meta property="og:title" content="Keegan小钢">
<meta property="og:url" content="https://keeganlee.me/index.html">
<meta property="og:site_name" content="Keegan小钢">
<meta property="og:description" content="分享钢哥人生路上的点点滴滴">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Keegan小钢">
<meta name="twitter:description" content="分享钢哥人生路上的点点滴滴">





  
  
  <link rel="canonical" href="https://keeganlee.me/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Keegan小钢</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Keegan小钢</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">钢哥的个人博客</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/matching/20191121/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/matching/20191121/" class="post-title-link" itemprop="url">撮合引擎开发:对接黑箱</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-21 22:41:26 / 修改时间：22:46:04" itemprop="dateCreated datePublished" datetime="2019-11-21T22:41:26+08:00">2019-11-21</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/matching/" itemprop="url" rel="index"><span itemprop="name">matching</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/matching/20191121"><strong>http://keeganlee.me/post/matching/20191121</strong></a><br>微信公众号：名称：Keegan小钢；微信号：keeganlee_me<br>写于2019-11-21</p>
<hr>
<p><a href="http://keeganlee.me/post/matching/20191117">撮合引擎开发：开篇</a><br><a href="http://keeganlee.me/post/matching/20191118">撮合引擎开发：MVP版本</a><br><a href="http://keeganlee.me/post/matching/20191119">撮合引擎开发：数据结构设计</a><br><a href="http://keeganlee.me/post/matching/20191121">撮合引擎开发：对接黑箱</a></p>
<hr>
<h2 id="黑箱引擎"><a href="#黑箱引擎" class="headerlink" title="黑箱引擎"></a>黑箱引擎</h2><p>我们的撮合引擎作为一个相对通用的组件，其实就是一个黑箱，如果想将它应用到各种不同的交易系统，只要有标准的输入和输出，对接是很容易的。</p>
<p>写作此文时的撮合引擎为 1.3 版本，我将其编译构建成可在 Linux amd64 环境运行的可执行文件，并与依赖的配置文件一起压缩成一个压缩包 <strong>matching.zip</strong>。这就成为一个黑箱引擎了。</p>
<p>不过，该黑箱引擎除了对运行系统有要求，还对 Redis 有要求。由于使用了 Redis 的新版 MQ 功能，即 stream 数据结构，要求 Redis 至少是 5.0 版本。</p>
<p>其实，我也可以编译构建成其他系统环境的可执行文件，如 Windows 或 Mac 系统。但作为一款商业软件以及对性能的一些要求，运行在 Linux 环境更合适。</p>
<p>后面，我们就来看看，如果要将这个黑箱引擎应用到自己的交易系统中，如何对接？</p>
<h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><p>安装部署的系统环境需是 Linux amd64 的，另外，如果要让撮合性能更快，建议 Redis 与撮合引擎可以使用同一服务器，这可以减少不同服务器之前的传输耗时。</p>
<p>按照以下步骤操作就可以将撮合引擎安装部署到运行环境了：</p>
<ol>
<li>将 <strong>matching.zip</strong> 压缩包上传到运行环境；</li>
<li>在运行环境解压 <strong>matching.zip</strong> 压缩包，解压后有一个可执行文件和一个文件夹：<ul>
<li><strong>matching</strong>：这是撮合引擎程序的可执行文件</li>
<li><strong>conf</strong>：存放配置文件的目录，里面就一个配置文件 <strong>config.yaml</strong></li>
</ul>
</li>
<li>修改配置文件为自己想要的配置值：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="string">:9466</span>  <span class="string">//撮合引擎程序启动监听的端口</span></span><br><span class="line"><span class="attr">log:</span>                 <span class="string">//输出日志配置</span></span><br><span class="line"><span class="attr">  fileDir:</span> <span class="string">logs</span>      <span class="string">//输出日志存放的目录</span></span><br><span class="line"><span class="attr">  fileName:</span> <span class="string">matching</span> <span class="string">//日志文件名，会按日期分割</span></span><br><span class="line"><span class="attr">  prefix:</span>            <span class="string">//日志消息前缀</span></span><br><span class="line"><span class="attr">  level:</span> <span class="string">debug</span>       <span class="string">//日志级别，由低到高为：debug、info、warn、error</span></span><br><span class="line"><span class="attr">redis:</span></span><br><span class="line"><span class="attr">  addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379</span>  <span class="string">//Redis地址</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>如果使用默认配置，请确认运行环境本地已安装并启动了Redis并运行在6379端口；</li>
<li>如果不用默认配置，依然需要确认Redis能正确连接；</li>
<li>运行以下命令，后台启动撮合引擎程序：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./matching &amp;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>运行以下命令，检查程序是否启动成功：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux|grep matching</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>程序启动成功后，会在配置的日志目录生成日志文件，默认为与 <strong>matching</strong> 可执行文件同目录下的 logs/matching.log；</li>
<li>至此，撮合引擎程序安装部署成功。</li>
</ol>
<h2 id="对接输入"><a href="#对接输入" class="headerlink" title="对接输入"></a>对接输入</h2><p>接入撮合引擎只需要对接三个 HTTP 接口，接口统一采用 POST 方法，参数统一用 json 格式，传 body。</p>
<h3 id="1-开启撮合"><a href="#1-开启撮合" class="headerlink" title="1. 开启撮合"></a>1. 开启撮合</h3><p>开启指定交易标的（交易对）的撮合功能。</p>
<h4 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h4><ul>
<li>POST  <em>/openMatching</em></li>
</ul>
<h4 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h4><ul>
<li><strong>symbol</strong>：字符串类型，必传字段，交易标的(交易对)的标识，如 BTC_USDT</li>
<li><strong>price</strong>：数字类型，非必传字段，默认为 0，开盘价</li>
</ul>
<h4 id="请求示例"><a href="#请求示例" class="headerlink" title="请求示例"></a>请求示例</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST  /openMatching</span><br><span class="line">Body：</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"symbol"</span>: <span class="string">"BTC_USDT"</span>,</span><br><span class="line">  <span class="attr">"price"</span>: <span class="number">8219.85</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"code"</span>:<span class="number">0</span>,<span class="attr">"msg"</span>:<span class="string">"OK"</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-关闭撮合"><a href="#2-关闭撮合" class="headerlink" title="2. 关闭撮合"></a>2. 关闭撮合</h3><p>关闭指定交易标的（交易对）的撮合功能。</p>
<h4 id="HTTP请求-1"><a href="#HTTP请求-1" class="headerlink" title="HTTP请求"></a>HTTP请求</h4><ul>
<li>POST  <em>/closeMatching</em></li>
</ul>
<h4 id="请求参数-1"><a href="#请求参数-1" class="headerlink" title="请求参数"></a>请求参数</h4><ul>
<li><strong>symbol</strong>：字符串类型，必传字段，交易标的(交易对)的标识，如 BTC_USDT</li>
</ul>
<h4 id="请求示例-1"><a href="#请求示例-1" class="headerlink" title="请求示例"></a>请求示例</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST  /closeMatching</span><br><span class="line">Body：</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"symbol"</span>: <span class="string">"BTC_USDT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="响应数据-1"><a href="#响应数据-1" class="headerlink" title="响应数据"></a>响应数据</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"code"</span>:<span class="number">0</span>,<span class="attr">"msg"</span>:<span class="string">"OK"</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-处理订单"><a href="#3-处理订单" class="headerlink" title="3. 处理订单"></a>3. 处理订单</h3><p>接收下单和撤单请求。</p>
<h4 id="HTTP请求-2"><a href="#HTTP请求-2" class="headerlink" title="HTTP请求"></a>HTTP请求</h4><ul>
<li>POST  <em>/handleOrder</em></li>
</ul>
<h4 id="请求参数-2"><a href="#请求参数-2" class="headerlink" title="请求参数"></a>请求参数</h4><ul>
<li><strong>symbol</strong>：字符串类型，必传字段，交易标的(交易对)的标识，如 BTC_USDT</li>
<li><strong>action</strong>：字符串类型，必传字段，订单动作，下单=create，撤单=cancel</li>
<li><strong>orderId</strong>：字符串类型，必传字段，订单ID</li>
<li><strong>side</strong>：字符串类型，必传字段，买卖方向，买入=buy，卖出=sell</li>
<li><strong>type</strong>：字符串类型，必传字段，订单类型，包括：limit、limit-ioc、market、market-top5、market-top10、market-opponent，说明见下文</li>
<li><strong>amount</strong>：数字类型，非必传字段，默认为 0，订单交易量，下单时必传，撤单时可不传</li>
<li><strong>price</strong>：数字类型，非必传字段，默认为 0，委托价格，订单类型为市价时可不传</li>
</ul>
<p>订单类型说明：</p>
<ul>
<li><strong>limit</strong>：普通限价</li>
<li><strong>limit-ioc</strong>：IOC限价-即时成交剩余撤销</li>
<li><strong>market</strong>：默认市价-即时成交剩余撤销</li>
<li><strong>market-top5</strong>：市价-最优五档即时成交剩余撤销</li>
<li><strong>market-top10</strong>：市价-最优十档即时成交剩余撤销</li>
<li><strong>market-opponent</strong>：市价-对手方最优价</li>
</ul>
<h4 id="请求示例-2"><a href="#请求示例-2" class="headerlink" title="请求示例"></a>请求示例</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST  /handleOrder</span><br><span class="line">Body：</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"symbol"</span>: <span class="string">"BTC_USDT"</span>,</span><br><span class="line">  <span class="attr">"action"</span>: <span class="string">"create"</span>,</span><br><span class="line">  <span class="attr">"orderId"</span>: <span class="string">"a0001"</span>,</span><br><span class="line">  <span class="attr">"side"</span>: <span class="string">"buy"</span>,</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"limit"</span>,</span><br><span class="line">  <span class="attr">"amount"</span>: <span class="number">0.012</span>,</span><br><span class="line">  <span class="attr">"price"</span>: <span class="number">8230.74</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="响应数据-2"><a href="#响应数据-2" class="headerlink" title="响应数据"></a>响应数据</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"code"</span>:<span class="number">0</span>,<span class="attr">"msg"</span>:<span class="string">"OK"</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对接输出"><a href="#对接输出" class="headerlink" title="对接输出"></a>对接输出</h2><p>撮合引擎有两种输出：<strong>撤单结果</strong>和<strong>成交记录</strong>。统一用 MQ 的方式进行输入，MQ 是保存为 Redis 5.0 版本之后引入的新数据结构 Stream 类型。每个消息队列其实就是一条 stream，关于 stream 的具体用法我就不展开了，大伙自行去网上搜索学习即可。</p>
<h3 id="1-撤单结果"><a href="#1-撤单结果" class="headerlink" title="1. 撤单结果"></a>1. 撤单结果</h3><p>每个不同的 symbol 设置一个 stream，其 key 的格式为：<strong>matching:cancelresults:{symbol}</strong>，value 包含两个字段：</p>
<ul>
<li><strong>orderId</strong>：订单号</li>
<li><strong>ok</strong>：1=成功；0=失败</li>
</ul>
<h3 id="2-成交记录"><a href="#2-成交记录" class="headerlink" title="2. 成交记录"></a>2. 成交记录</h3><p>每个不同的 symbol 也设置一个 MQ，key 的格式为：<strong>matching:trades:{symbol}</strong>，value 包含的字段如下：</p>
<ul>
<li><strong>makerId</strong>：maker订单ID</li>
<li><strong>takerId</strong>：taker订单ID</li>
<li><strong>takerSide</strong>：taker买卖方向</li>
<li><strong>amount</strong>：成交数量</li>
<li><strong>price</strong>：成交价格</li>
<li><strong>timestamp</strong>：成交时间</li>
</ul>
<p>下游服务就可以通过订阅监听这两种输出，之后做后续的处理，比如 K 线行情服务订阅监听成交记录来生成 K 线数据。等撮合引擎完成之后，我下一个要开发的组件就是 K 线行情服务。</p>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>最后，先给大伙看看我们这个黑箱内部的整个 Go 项目的文件目录结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">├── conf                     # 配置文件存放目录，在1.1版本时增加</span><br><span class="line">│   ├── config.yaml          # 配置文件，在1.1版本时增加</span><br><span class="line">├── engine                   # 引擎包</span><br><span class="line">│   ├── init.go              # 初始化</span><br><span class="line">│   ├── order.go             # 委托单</span><br><span class="line">│   ├── order_book.go        # 交易委托账本</span><br><span class="line">│   ├── order_queue.go       # 订单队列</span><br><span class="line">│   ├── run.go               # 具体交易对的撮合引擎启动入口</span><br><span class="line">│   └── trade.go             # 成交记录</span><br><span class="line">├── enum                     # 枚举类型的包</span><br><span class="line">│   ├── order_action.go      # 订单行为，create为下单，cancel为撤单</span><br><span class="line">│   ├── order_side.go        # 买卖方向，buy为买入，sell为卖出</span><br><span class="line">│   ├── order_type.go        # 订单类型，MVP版本(1.0版本)只支持limit，1.3版本共支持7种类型 </span><br><span class="line">│   └── sort_direction.go    # 排序方向，asc为升序，desc为降序</span><br><span class="line">├── errcode                  #</span><br><span class="line">│   ├── code.go              # 定义了各种不同的错误码</span><br><span class="line">│   └── errcode.go           # 错误码的数据结构，包括code和msg两个字段</span><br><span class="line">├── handler                  #</span><br><span class="line">│   ├── close_matching.go    # 接收关闭撮合的请求</span><br><span class="line">│   ├── handle_order.go      # 接收处理订单的请求</span><br><span class="line">│   └── open_matching.go     # 接收开启撮合的请求</span><br><span class="line">├── log                      # 日志包，在1.2版本增加</span><br><span class="line">│   ├── log.go               # 日志输出，在1.2版本增加</span><br><span class="line">├── main.go                  # Go程序唯一入口</span><br><span class="line">├── middleware               # 中间件的包</span><br><span class="line">│   ├── cache                # 缓存包</span><br><span class="line">│   │   └── cache.go         # 缓存操作</span><br><span class="line">│   ├── mq                   # 消息队列包</span><br><span class="line">│   │   └── mq.go            # MQ操作</span><br><span class="line">│   └── redis.go             # 主要做Redis初始化操作</span><br><span class="line">└── process                  #</span><br><span class="line">    ├── close_engine.go      # 关闭引擎</span><br><span class="line">    ├── dispatch.go          # 分发订单</span><br><span class="line">    ├── init.go              # 初始化</span><br><span class="line">    └── new_engine.go        # 启动新引擎</span><br></pre></td></tr></table></figure>

<p>包括 main 包，整个项目总共划分为了 10 个包和 1 个配置文件目录：</p>
<ul>
<li><strong>conf</strong>：存放配置文件的目录。</li>
<li><strong>main</strong>：main 包只有一个 main.go 文件，定义了程序入口函数。</li>
<li><strong>enum</strong>：枚举包实现了几个枚举类型的数据结构，包括订单行为、买卖方向、订单类型和排序方向。</li>
<li><strong>errcode</strong>：存放错误码的包，errcode.go 定义了错误码的数据结构，有 code 和 msg 两个属性；code.go 则定义了一些错误码对象。</li>
<li><strong>handler</strong>：接收 HTTP 请求的函数都放在这个包里，目前也就只有三个 handler 函数。</li>
<li><strong>process</strong>：启动、关闭引擎和分发订单的处理过程都在这个包里，包里还维护着不同交易对的订单通道，用来分发不同交易对的订单。</li>
<li><strong>engine</strong>：引擎包，包含了委托单、交易委托账本、订单队列、成交记录这几个核心的数据结构，以及用于处理交易对撮合的入口函数。</li>
<li><strong>middleware</strong>：存放中间件的包，目前只用到了 Redis 一个中间件。</li>
<li><strong>cache</strong>：缓存包，只有一个 cache.go 文件，缓存操作都在这个文件里定义。</li>
<li><strong>mq</strong>：消息队列包，也只有一个 mq.go 文件，消息的发送就定义在这里。</li>
<li><strong>log</strong>：日志包，实现了日志消息按日期分割并输出到文件。</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本节我们了解到撮合引擎作为一个通用组件，有标准的输入和输出，而且这输入和输出都非常简单。也开始给大家展示了黑箱内部的文件目录结构，开始探究黑箱的内部逻辑，后续章节将陆续揭露这些内部实现逻辑。</p>
<p>本节预留的思考题：揣测下为什么我要将下单和撤单定义到同一个接口？而不是分开两个接口？分两个接口和用一个接口各有何优劣？</p>
<hr>
<p>扫描以下二维码即可关注公众号（公众号名称：Keegan小钢）</p>
<img src="/post/matching/20191121/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/matching/20191119/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/matching/20191119/" class="post-title-link" itemprop="url">撮合引擎开发:数据结构设计</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-19 20:21:14" itemprop="dateCreated datePublished" datetime="2019-11-19T20:21:14+08:00">2019-11-19</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-11-21 22:45:14" itemprop="dateModified" datetime="2019-11-21T22:45:14+08:00">2019-11-21</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/matching/" itemprop="url" rel="index"><span itemprop="name">matching</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/matching/20191119"><strong>http://keeganlee.me/post/matching/20191119</strong></a><br>微信公众号：名称：Keegan小钢；微信号：keeganlee_me<br>写于2019-11-19</p>
<hr>
<p><a href="http://keeganlee.me/post/matching/20191117">撮合引擎开发：开篇</a><br><a href="http://keeganlee.me/post/matching/20191118">撮合引擎开发：MVP版本</a><br><a href="http://keeganlee.me/post/matching/20191119">撮合引擎开发：数据结构设计</a><br><a href="http://keeganlee.me/post/matching/20191121">撮合引擎开发：对接黑箱</a></p>
<hr>
<h2 id="交易委托账本"><a href="#交易委托账本" class="headerlink" title="交易委托账本"></a>交易委托账本</h2><p><strong>交易委托账本(OrderBook)</strong>是整个撮合引擎里最核心也是最复杂的数据结构，每个交易对都需要维护一份交易委托账本，账本里保存着指定交易对所有待撮合的委托单。每份账本都有两个队列，一个卖单队列和一个买单队列，两个队列都需要按照<strong>价格优先、时间优先</strong>的原则进行排序。</p>
<p>所谓价格优先、时间优先，即是说：卖单队列的委托单是按价格由低到高排序，买单队列则相反，按价格由高到低排序；相同价格的委托单，则是按下单时间的先后来排序。</p>
<img src="/post/matching/20191119/orderbook.png">

<p>如上图，每个小方格表示一个委托单，标 <strong>H</strong> 的是排在头部的委托单，<strong>N</strong>则是与 H 同价格但下单时间上排在 H 后面的委托单，<strong>S</strong>则是下一档位价格的第一个委托单。可以从图中明显看出，横向上，委托单是按时间排序的，竖向上，又是按价格排序的。</p>
<p>撮合的时候，都是先取出 <strong>H</strong> 委托单与新委托单进行匹配。如果新委托单是<strong>买单</strong>，则获取<strong>卖单队列</strong>的 H 单出来匹配；如果新委托单是<strong>卖单</strong>，则获取<strong>买单队列</strong>的 H 单。如果 <strong>H</strong> 单全部匹配成交了，那标识为 <strong>N</strong> 的委托单就变成了新的 <strong>H</strong> 单。如果第一排的全部委托单都匹配完了，那就 <strong>S</strong> 单会变成新的 <strong>H</strong> 单。</p>
<p>交易委托账本可支持一些操作方法，包括初始化、增加买卖委托单、移除买卖委托单、获取头部委托单等。交易委托账本的类图大概如下：</p>
<img src="/post/matching/20191119/class-orderbook.png">

<p>其中，<strong>getHead</strong> 和 <strong>popHead</strong> 方法的区别是：get 只读头部委托单但不会移除它，而 pop 会将头部委托单从队列中移除。</p>
<h2 id="订单队列"><a href="#订单队列" class="headerlink" title="订单队列"></a>订单队列</h2><p>买单队列和卖单队列可以设计为使用统一的订单队列类型，两者只有价格排序方向不同，那订单队列就可以用一个属性来表示排序方向。队列里的所有订单可以采用二维数组或二维链表来保存，考虑到主要操作是插入和删除，用链表比用数组效率更高。如果想让操作效率更高，那就需要使用更复杂的数据结构了，比如再结合跳表。目前版本为了简单，采用简单的二维链表即可。</p>
<p>使用二维链表的话，那链表中的每个元素保存的就是横向上按时间排序的订单链表，这些订单链表又组成了竖向上按价格排序的链表。</p>
<p>另外，还可以保存一个 Map，将价格作为 Key，将同价格的订单链表作为 Value，这样就能加快同价格订单的查询。</p>
<p>订单队列可支持的操作方法也很简单，包括初始化、新增订单、移除订单、获取头部订单等。其类图大概如下：</p>
<img src="/post/matching/20191119/class-orderqueue.png">

<p><strong>sortBy</strong> 指定价格排序的方向，<strong>parentList **保存整个二维链表，第一维以价格排序，第二维以时间排序，</strong>elementMap** 则是 Key 为价格、Value 为第二维订单链表的键值对。</p>
<h2 id="委托单"><a href="#委托单" class="headerlink" title="委托单"></a>委托单</h2><p>委托单则是撮合引擎里最基本的数据结构了，其数据主要是从上游服务传输过来的，其类图大概如下：</p>
<img src="/post/matching/20191119/class-order.png">

<p><strong>action</strong> 声明对委托单要进行哪种操作，我们只需支持两种操作：<strong>下单(create)</strong>和<strong>撤单(cancel)</strong>。<strong>symbol</strong> 指定该委托单所属的交易对，<strong>orderId</strong> 是该委托单的唯一标识，<strong>side</strong> 指明是<strong>买入(buy)</strong>还是<strong>卖出(sell)</strong>。<strong>type **表示交易类型，即</strong>限价交易(limit)<strong>或</strong>市价交易(market)<strong>等，我们的 MVP 版本只支持限价交易。</strong>amount <strong>是购买数量，</strong>price** 是购买价格，<strong>timestamp</strong> 则是订单时间。</p>
<p><strong>toJson() *<em>和 *</em>fromJson()</strong> 方法是为了支持订单数据传输时的序列化和反序列化。</p>
<h2 id="成交记录"><a href="#成交记录" class="headerlink" title="成交记录"></a>成交记录</h2><p>撮合成交的委托单就会生成对应的成交记录，成交记录需要发布到 MQ 给下游服务消费。成交记录的数据结构如下图：</p>
<img src="/post/matching/20191119/class-trade.png">

<p><strong>maker</strong> 指挂单，是本来挂在交易委托账本里的订单，而 <strong>taker</strong> 则是吃单，是指吃掉 maker 的订单。<strong>makerId *<em>和 *</em>takerId</strong> 就是挂单和吃单的订单 ID。<strong>takerSide</strong> 就是吃单的买卖方向，我们在行情软件里看到的成交记录会有不同颜色，就是由这个 takerSide 决定的。<strong>amount **就是成交数量，</strong>price** 指成交价格，*<em>timestamp *</em>是成交时间。</p>
<h2 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h2><p>我们需要用 Redis 缓存委托单数据和撮合中的交易对数据，主要有两个作用，一是可以对请求做去重处理，二是程序重启后可以恢复数据。</p>
<p>由于网络中断或延迟，或其他异常情况，上游服务有可能会重复发送相同请求给到撮合引擎，因此，程序是需要做去重处理的，有了数据缓存就可以解决去重问题了。另外，由于我们采用的是内存撮合，撮合时的数据都是直接保存在程序内存里的，一旦程序退出了，那所有数据也都消失了，重启后就需要从其他地方重新加载数据，采用Redis缓存就可以很快速地缓存数据和加载数据。</p>
<p>开启一个交易对引擎时需要将交易对缓存，关闭时则从缓存中删除，保证缓存的都是运行中的交易对，当重启时，就可以重新启动这些交易对的撮合引擎了。需要缓存的交易对数据包括两个：<strong>symbol</strong> 和 <strong>price</strong>，即标识和价格。关于价格，每次产生新的成交记录时，价格也需要同步更新，因此价格的更新会非常频繁。而标识基本无需更新，因此两者最好分开缓存。</p>
<p>所有交易对的 symbol 可以统一缓存到一个 set 里。我们可以将 key 值设置为 <strong>matching:symbols</strong>，用 Redis 的 <strong>sadd</strong> 和 <strong>srem</strong> 命令将不同的 symbol 缓存到该 key 值里或从 key 中删除。而 price 则可以保存为 string 类型，为不同交易对的价格设置不同的 key，key 值可以设置为 <strong>matching:price:{symbol}</strong>，{symbol} 为具体交易对的 symbol 值。</p>
<p>每个委托单也需要缓存和更新，为了能够从缓存中最快地读取和更新委托单数据，最好为每个委托单都设置一个单独的 key，key 值可以设置为 <strong>matching:order:{symbol}:{orderId}:{action}</strong>，而 value 值建议设置为 hash 类型，因为 hash 类型特别适合存储结构化的对象。</p>
<p>交易对和委托单数据都缓存了，就能够解决去重问题和程序重启后重新启动各交易对的撮合引擎了，但其实还有一个问题，撮合引擎里的交易委托账本如何恢复？该问题先留给大伙去思考，后续章节我再来讲解我的方案。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>撮合引擎里涉及到的数据结构其实并不多，最复杂的也只有交易委托账本，其设计还会直接关系到撮合的速度。Redis 缓存的设计也有些学问在里面，设计得不好也一样会影响整体的撮合性能。本小节完成了数据结构的设计，下一小节我们就开始深入到代码实现。</p>
<p>最后，请抽时间研究下遗留的思考题：撮合引擎里的交易委托账本如何恢复？</p>
<hr>
<p>扫描以下二维码即可关注公众号（公众号名称：Keegan小钢）</p>
<img src="/post/matching/20191119/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/matching/20191118/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/matching/20191118/" class="post-title-link" itemprop="url">撮合引擎开发:MVP版本</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-18 20:21:14" itemprop="dateCreated datePublished" datetime="2019-11-18T20:21:14+08:00">2019-11-18</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-11-21 22:45:45" itemprop="dateModified" datetime="2019-11-21T22:45:45+08:00">2019-11-21</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/matching/" itemprop="url" rel="index"><span itemprop="name">matching</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/matching/20191118"><strong>http://keeganlee.me/post/matching/20191118</strong></a><br>微信公众号：名称：Keegan小钢；微信号：keeganlee_me<br>写于2019-11-18</p>
<hr>
<p><a href="http://keeganlee.me/post/matching/20191117">撮合引擎开发：开篇</a><br><a href="http://keeganlee.me/post/matching/20191118">撮合引擎开发：MVP版本</a><br><a href="http://keeganlee.me/post/matching/20191119">撮合引擎开发：数据结构设计</a><br><a href="http://keeganlee.me/post/matching/20191121">撮合引擎开发：对接黑箱</a></p>
<hr>
<p>开篇文章发出去之后，我的撮合引擎被一位超级大佬（曾担任上交所的首席架构师）定位为玩具，直接将我的撮合引擎和国家级撮合引擎作对比了。如果我的撮合引擎达到上交所级别，那就不止值5万了，估计至少值500万了。不过，我的撮合引擎随着不断升级迭代，以后能达到国家级别也说不定。为了避免再次出现这种尴尬，我还是先说明清楚对此撮合引擎的定位。</p>
<h2 id="MVP版本需求"><a href="#MVP版本需求" class="headerlink" title="MVP版本需求"></a>MVP版本需求</h2><p>《精益创业》有个核心概念叫 <strong>MVP</strong>(Minimum Viable Product)，即<strong>最小可行性产品</strong>。我的撮合引擎第一个版本也是一个 MVP，只实现最基础的功能。所谓最基础的功能，即是说，如果移除了该功能，整个系统都无法完成工作。当然，我们还要加上应用场景，应用于一个初创的小交易平台和应用于像火币、币安甚至深交所、上交所这样庞大的交易平台，对基础功能的定义范围是有很大区别的。我所要做的 MVP 版本，只要适用于小交易平台即可。</p>
<p>这里我要稍微展开聊下产品设计的问题，很多团队——尤其是初创团队，做第一版产品的时候，总觉得这个功能很重要、那个功能很重要，都往第一版的产品里面加。其实，做第一版的时候，更多的应该是做减法，而不是做加法。很多看起来很重要的功能，大部分都是属于那种有了它更好，但没有它也不是整个产品就运行不下去了。</p>
<p>下面我们就来讨论下 MVP 版本的撮合引擎具体要实现哪些功能。</p>
<p>我们知道，撮合有<strong>集合竞价</strong>和<strong>连续竞价</strong>两种方式，但对于我们的 MVP 版本来说，是否有必要两种撮合方式都支持呢？其实，在币圈，不管是小交易所还是大交易所，基本只采用连续竞价的方式。我以前从事的贵金属交易平台，也同样没有集合竞价这一步。这也说明，集合竞价对一个交易所来说，其实并不是必需的。既然如此，那第一版的撮合引擎其实就可以先把集合竞价功能砍掉。</p>
<p>支持下单和撤单则是必需的，这是一个交易所最最基础的功能，没有这两个功能，交易所就没意义了。下委托单一般还分有几种不同的类型，包括<strong>限价</strong>、<strong>市价</strong>、<strong>止盈止损</strong>等，最简单的就是限价，这也是所有交易所都必须支持的交易类型，初创交易所一般也只先支持限价交易，所以我们的 MVP 版本也只先支持限价交易即可。</p>
<p>下单和撤单的结果还需要通过事件的方式发送出去，其他服务会监听这些事件并做相应的后续处理。</p>
<p>维护<strong>交易委托账本(OrderBook)</strong>也是必需的，撮合就是和 OrderBook 里的订单进行匹配成交，暂时没成交的就会保存在 OrderBook 里。</p>
<p>另外，我们也要采用<strong>内存撮合</strong>技术，因此，OrderBook 其实是直接保存在程序的内存中的。那么，如果程序异常退出的话，那保存的数据也被清空了。所以，我们还需要引入缓存用来备份数据。当程序重启时，可以从缓存中重新加载数据。</p>
<p>MVP 版本还要支持多个交易标的的撮合，因为我们的 MVP 版本撮合引擎只是个单机版的程序，总不能只支持一个交易标的吧。</p>
<p>还要支持开启和关闭指定交易标的撮合的功能，开启撮合时需要做一些初始化的操作，包括初始化开盘价，而关闭撮合后则会删除数据、释放资源等。</p>
<p>汇总一下，我们的 MVP 版本要实现以下这些功能：</p>
<ol>
<li>支持连续竞价的撮合方式；</li>
<li>支持限价交易、支持撤单；</li>
<li>支持下单和撤单结果的下发；</li>
<li>采用内存撮合技术，在内存里维护交易委托账本；</li>
<li>需要缓存数据，当程序重启时，可以恢复数据；</li>
<li>支持多个交易标的的撮合；</li>
<li>支持开启和关闭指定交易标的的撮合功能。</li>
</ol>
<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>需求确定了，接下来就要确定技术方案了，先聊下一些技术选型吧。</p>
<p>首先是开发语言，我的选择是 <strong>Golang</strong>，原因很简单，Golang 有着接近 C/C++ 的执行性能，但比 C/C++ 有着更高的开发效率，既能满足撮合引擎对性能的要求，也能满足我们快速实现产品的需求。当然，用其他语言也能实现，毕竟，设计思路是通用的。</p>
<p>下单和撤单，开启和关闭撮合，以及结果的下发，都涉及到与其他服务的通信。服务间的通信主要就两种可选方案：同步调用的 <strong>RPC</strong> 和异步调用的 <strong>MQ</strong>。同步调用能使请求得到即时的响应，通信相对高效且可靠性较高，但只适用于一对一的通信，且如果并发请求出现超负荷时可能会引发大量的请求超时甚至服务宕机。而 MQ 支持一对多的通信，也因为有缓存队列，能避免并发请求达到峰值时出现服务不可用的情况，但也因为多了个消息中间件，传输有延迟，且请求无法得到即时的应答，还存在丢消息的可能，因此可靠性就比不上同步的 RPC 方式。</p>
<p>对于我们的应用场景来说，结果的下发只能使用 MQ，因为我们并不清楚有多少个下游服务会消费我们的结果消息，也无法要求下游服务提供统一的 RPC 接口供我们调用。下单和撤单请求，则最好采用 RPC 同步方式调用，一是可以对一些无效的请求即时返回响应，二是能减少 MQ 的传输延迟，三是能保证可靠性。对于并发请求超负荷的问题，应该在更上层的网关服务就做好负载均衡，而不应该丢给撮合引擎来处理。</p>
<p>不过，RPC 和 MQ 也有多种具体的实现方案。RPC 方案有 <strong>REST</strong>、<strong>gRPC</strong>、<strong>Thrift</strong>、<strong>rpcx</strong> 等，MQ 方案有 <strong>Kafka</strong>、<strong>RocketMQ</strong>、<strong>RabbitMQ</strong>、<strong>Redis</strong>等。这些不同的具体方案之间的差异性我就不展开了，感兴趣的读者们可以自己去百度或 Google。RPC 方案我们选择最简单的 REST 即可，开发、对接和测试都比较方便。MQ 方案则选定 Redis，因为 Redis 从 5.0 版本开始引入了 <strong>Stream</strong> 数据结构，提供了类似Kafka的消息队列功能，但由于 Redis 的数据是存储在内存中的，其处理速度相比其他 MQ 快很多。另外，我们还要用 Redis 做缓存，用同一个中间件也更方便。</p>
<h2 id="软件结构"><a href="#软件结构" class="headerlink" title="软件结构"></a>软件结构</h2><img src="/post/matching/20191118/v1.0-architecture.png">

<p>上图就是我们 MVP 版本的撮合服务的软件结构设计图，很简单吧。其实，就是按照业务流程进行了分层而已。分层是最简单的一种架构方式，其实任何庞大复杂的系统，第一步拆解都可以按业务流程进行分层。</p>
<p><strong>Handler</strong> 接收由上游服务发过来的 HTTP 请求，我们只需定义三个接口：</p>
<ul>
<li><strong>OpenMatching</strong>：开启撮合，只需接收两个参数：交易标的（交易对）和开盘价。</li>
<li><strong>CloseMatching</strong>：关闭撮合，只需一个参数：交易标的（交易对）。</li>
<li><strong>HandleOrder</strong>：接收委托单，会有一个参数 <strong>Action</strong> 表示动作是下单还是撤单，其他参数则是委托单的数据了，包括订单 ID、交易对、买卖方向、委托数量、委托价格等。</li>
</ul>
<p>Handler 对请求做一些常规的校验之后，就会转发给相应的 Process 做处理，我们也定义了对应的三个 <strong>Process</strong>：</p>
<ul>
<li><strong>NewEngine</strong>：创建一个新的协程/线程，作为指定交易对的撮合引擎。</li>
<li><strong>CloseEngine</strong>：将指定交易对的撮合引擎关闭。</li>
<li><strong>Dispatch</strong>：将不同交易对的委托单分发到相应的撮合引擎。</li>
</ul>
<p><strong>Engine</strong> 即是每个交易对的撮合引擎协程或线程了。由于每个交易对的撮合引擎对委托单的处理必须是串行的，因此，Dispatch 时需将委托单先扔到不同交易对的有序队列里去，再由 Engine 从各自的队列中消费取出委托单进行撮合处理。</p>
<p><strong>Redis</strong> 既用来做数据缓存，也用来做消息队列。缓存的数据主要是当前开启了撮合的交易对，以及撮合引擎里的交易委托账本。为了保证数据的一致性，账本里每个委托单的每一次变化，都需要更新到 Redis 中去。当撮合引擎重启时，就需要从 Redis 中读取缓存的委托单，重新初始化交易委托账本。这样，就能保证程序退出后重启，能恢复到退出前的状态。消息队列则可用 Redis 的新数据结构 Stream 实现，用来发送成交记录和撤单结果。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们第一版先做个 MVP，做个单体版的撮合服务，支持连续竞价、限价委托、撤单、开启和关闭撮合、支持多交易对等功能，采用内存撮合技术。软件结构上主要分为 Handler、Process、Engine 三个层级，底层用 Redis 做数据缓存和消息队列。下一篇我们来设计数据结构。</p>
<p>留一个思考题：Dispatch 分发委托单到 Engine 时，有序队列可以如何实现？</p>
<hr>
<p>扫描以下二维码即可关注公众号（公众号名称：Keegan小钢）</p>
<img src="/post/matching/20191118/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/matching/20191117/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/matching/20191117/" class="post-title-link" itemprop="url">撮合引擎开发:开篇</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-17 20:21:14" itemprop="dateCreated datePublished" datetime="2019-11-17T20:21:14+08:00">2019-11-17</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-11-21 22:45:28" itemprop="dateModified" datetime="2019-11-21T22:45:28+08:00">2019-11-21</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/matching/" itemprop="url" rel="index"><span itemprop="name">matching</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/matching/20191117"><strong>http://keeganlee.me/post/matching/20191117</strong></a><br>微信公众号：名称：Keegan小钢；微信号：keeganlee_me<br>写于2019-11-17</p>
<hr>
<p><a href="http://keeganlee.me/post/matching/20191117">撮合引擎开发：开篇</a><br><a href="http://keeganlee.me/post/matching/20191118">撮合引擎开发：MVP版本</a><br><a href="http://keeganlee.me/post/matching/20191119">撮合引擎开发：数据结构设计</a><br><a href="http://keeganlee.me/post/matching/20191121">撮合引擎开发：对接黑箱</a></p>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自从有人在微信群里开价5万求购Golang版的撮合引擎之后，我就想自己开发一款，毕竟，以我的经验来说，开发个高性能的撮合引擎并没什么难度。</p>
<p>说干就干，于是，利用业余时间慢慢开发出了一款<strong>Golang</strong>版的高性能撮合引擎，前前后后花了大概一个月的时间。再想想自己好久没更新文章了，我的个人IP都已经生锈了，也应该发大招磨一磨了。因此决定，干脆就以连载的方式，分享下我是如何设计与实现这款价值超5万的撮合引擎的。</p>
<p>本来，想发成掘金小册，收点稿费，毕竟这是个具有很大商业价值的软件，但问了掘金的人员，他们目前不接收这类主题。最终决定免费发布，还可以多发几个渠道，说不定还能给我多带来些关注量。</p>
<p>好了，下面开始进入撮合引擎系列的正题。</p>
<h2 id="撮合引擎简介"><a href="#撮合引擎简介" class="headerlink" title="撮合引擎简介"></a>撮合引擎简介</h2><p>撮合引擎是所有撮合交易系统的核心组件，不管是股票交易系统——包括现货交易、期货交易、期权交易等，还是数字货币交易系统——包括币币交易、合约交易、杠杆交易等，以及各种不同的贵金属交易系统、大宗商品交易系统等，虽然各种不同交易系统的交易标的不同，但只要都是采用撮合交易模式，都离不开撮合引擎。</p>
<p>撮合引擎是可以具有通用性的，一套具有通用性的撮合引擎实现理论上可以应用到任何撮合交易系统中，而无需做任何代码上的调整。即是说，同一套撮合引擎实现，既可以应用在股票交易系统，也可以应用在数字货币交易系统，可以用于现货交易，也可以用于合约交易等。</p>
<p>那么，一套具有通用性的撮合引擎应该具备哪些功能呢？确定该问题的答案之前，我们先简单梳理一下一个完整的交易流程是怎样的？一般会包括以下步骤：</p>
<ol>
<li>系统开放某个交易标的的交易功能。</li>
<li>用户提交该交易标的的买卖申报，即<strong>委托单</strong>。</li>
<li>系统验证委托单是否有效，包括交易标的是否处于可交易的状态、订单的价格和数量是否符合要求等。</li>
<li>确定该委托单的<strong>挂单(Maker)</strong>费率和<strong>吃单(Taker)</strong>费率。</li>
<li>检查用户的资产账户情况，包括账户状态是否交易受限，是否有足够资金用于下单等。</li>
<li>将详细的委托单数据持久化到数据库，并冻结用户账户中相应数量的资金。</li>
<li>将委托单进行撮合处理，即在<strong>交易委托账本(OrderBook)</strong>中寻找能与该委托单匹配成交的订单，匹配的结果可能是：全部成交、部分成交或无匹配。全部成交或部分成交时，可能在交易委托账本中存在一个或多个匹配的订单，即会产生一条或多条成交记录。当无匹配或部分成交时，委托单的部分数据包括剩余未成交的数量会暂时保存到交易委托账本中，等待与后续的委托单匹配撮合。</li>
<li>将撮合产生的成交记录持久化到数据库，并根据历史成交记录生成市场数据，如K线数据、今日涨跌幅等。</li>
<li>更新数据库中所有成交订单的委托单数据，以及更新订单用户的资产账户余额。</li>
<li>将更新的订单数据、市场数据等发送给到前台。</li>
</ol>
<p>整个交易流程中涉及到多个服务，包括用户服务、账户服务、订单服务、撮合服务、市场数据服务等。其中，只有第7步是撮合引擎处理的。从单一职责原则来说，撮合引擎就应该只做一件事，那就是<strong>负责撮合订单</strong>。撮合之前的委托单持久化、冻结资金等，以及撮合之后生成K线数据等，都不应该属于撮合引擎的职责。</p>
<h2 id="撮合竞价方式"><a href="#撮合竞价方式" class="headerlink" title="撮合竞价方式"></a>撮合竞价方式</h2><p>撮合竞价方式一般有两种，一是<strong>集合竞价</strong>，二是<strong>连续竞价</strong>。股票交易系统一般会在不同交易时间段采用不同的竞价方式，比如在开盘或收盘时采用集合竞价，从而产生<strong>开盘价</strong>或<strong>收盘价</strong>，其余时间采用连续竞价。而大多数字货币交易系统则没有集合竞价，只有连续竞价，开盘价一般是在开始交易之前就设定好的。</p>
<h3 id="集合竞价"><a href="#集合竞价" class="headerlink" title="集合竞价"></a>集合竞价</h3><p>所谓集合竞价，是指对一段时间内接收的买卖委托单一次性集中撮合的竞价方式。以深沪的股票交易系统为例，在每个交易日的 9:15~9:25 期间是集合竞价时间。在该时间段内，系统陆续接收到的委托单不会即时成交，而是先将所有委托单按照<strong>价格优先、时间优先</strong>的原则排序，并在此基础上，找出一个基准价格，使它能同时满足以下三个条件：</p>
<ol>
<li>可实现<strong>最大成交量</strong>的价格；</li>
<li>高于该价格的买单与低于该价格的卖单能全部成交的价格；</li>
<li>与该价格相同的买方或卖方至少有一方全部成交的价格。</li>
</ol>
<p>在 9:25 分结束的时候，该基准价格就被确定为<strong>成交价格</strong>，所有高于该价格的买单与低于该价格的卖单都将以该价格成交。未能成交的委托单，则自动转入连续竞价。</p>
<p>不过，如果满足以上三个条件的价格存在两个或两个以上呢？对此，深交所和上交所的处理方案有所不同，深交所会取距<strong>前收盘价</strong>最近的价格为成交价，而上交所则取使<strong>未成交量</strong>最小的价格为成交价，如果未成交量最小的价格仍不止一个，则取<strong>中间价</strong>为成交价。</p>
<p>集合竞价的主要目的就是为了确定开盘价或收盘价。</p>
<h3 id="连续竞价"><a href="#连续竞价" class="headerlink" title="连续竞价"></a>连续竞价</h3><p>所谓连续竞价，也是我们所熟悉的竞价方式，是指对买卖委托单逐笔连续撮合的竞价方式。用户的挂单，只要满足成交条件，就能即时成交。而集合竞价，则要等到最后一刻才会成交。</p>
<p>连续竞价时，依然要满足价格优先、时间优先的成交原则：</p>
<ol>
<li><strong>价格优先</strong>：买单则价格较高者能优先成交，卖单则是价格较低者能优先成交。</li>
<li><strong>时间优先</strong>：买卖方向和价格相同的委托单，先申报的委托单会比后申报的委托单优先成交。</li>
</ol>
<p>另外，买入价必须大于或等于卖出价才能撮合成交。当买入价等于卖出价时，成交价就是买入价或卖出价。当买入价大于卖出价时，则还要参考前一笔成交价来确定最新成交价。假设买入价为 B，卖出价为 S，前一笔成交价为 P，最新成交价为 N，那么：</p>
<ul>
<li>如果 P &gt;= B，则 N = B</li>
<li>如果 P &lt;= S，则 N = S</li>
<li>如果 B &gt; P &gt; S，则 N = P </li>
</ul>
<p>一套通用的撮合引擎应该两种竞价方式都支持，但对于同一交易标的来说，两种竞价方式不能同时进行，因此设计上需要考虑如何在两种竞价方式之间切换，具体的实现思路在后续章节我们再展开来讲。</p>
<h2 id="质量需求"><a href="#质量需求" class="headerlink" title="质量需求"></a>质量需求</h2><p>我们的撮合引擎除了要满足以上所说的功能需求，还应该满足一些质量需求，尤其对<strong>可用性</strong>、<strong>可伸缩性</strong>和<strong>性能</strong>的要求较高。另外，为了达到通用，也要满足<strong>可复用性</strong>的需求。</p>
<p>先说下可复用性，我们期望的是该撮合引擎既能用于股票交易系统，也能用于数字货币交易系统，既能用于币币交易，也能用于合约交易。因此，该撮合引擎要避免引入与具体系统强相关的业务逻辑，以加强它的可复用性。</p>
<p>再看看性能，要衡量一个撮合引擎的性能，就看它处理每个交易对的 <strong>TPS</strong> 有多高，即每秒钟能处理多少笔相同交易对的委托单。以前，基于数据库的撮合技术，TPS 一般只有10笔/秒。而现在基本都是采用内存撮合技术，TPS 很容易就能达到1000笔/秒，如果使用独占的高性能服务器，1万笔/秒甚至更高的 TPS 都不难达到。</p>
<p>接着谈谈可伸缩性，我们的每一个撮合引擎既可以同时处理多个交易标的，也可以只处理单个交易标的。当交易标的和并发量增多的时候，可以增加服务器，部署成撮合引擎集群，分别用来处理不同的交易标的，从而能够实现负载均衡。</p>
<p>最后聊聊可用性，高可用主要体现在两点，一是故障率要低，二是对故障维修的时间要短。要降低故障率，那撮合引擎就需要有较高的健壮性，对于可能导致引擎出故障的各种异常情况要考虑好并设计好解决方案。另外，还可以采用多机热备份技术来提高可用性，而且要保证互备服务器之间的数据一致，那就需要引入内存状态机复制方案，实现上会复杂很多。</p>
<p>不过，我们并非一下子就要达到很高的质量要求，因为要求越高，其架构和实现会越复杂。我们可以先从简单的版本开始，然后不断升级迭代。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们目的是实现一套通用的撮合引擎，要支持集合竞价和连续竞价，还要实现一些质量需求，提高系统的可复用性、性能、可伸缩性、可用性等。后续章节会对这些需求不断深入探讨其设计与实现。另外，我们将采用不断升级迭代的方式来设计和实现多个版本的撮合引擎。</p>
<p>留两个思考题：</p>
<ol>
<li>集合竞价结束的时候，如果不存在符合那三个条件的基准价格，那开盘价又将如何确定？</li>
<li>对于单个交易对，是否可通过横向增加服务器的方式提高其性能？</li>
</ol>
<hr>
<p>扫描以下二维码即可关注公众号（公众号名称：Keegan小钢）</p>
<img src="/post/matching/20191117/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/blockchain/20180425/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/blockchain/20180425/" class="post-title-link" itemprop="url">漫谈区块链共识机制</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-04-25 16:00:00" itemprop="dateCreated datePublished" datetime="2018-04-25T16:00:00+08:00">2018-04-25</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-02 11:18:29" itemprop="dateModified" datetime="2019-07-02T11:18:29+08:00">2019-07-02</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/blockchain/" itemprop="url" rel="index"><span itemprop="name">blockchain</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/blockchain/20180425"><strong>http://keeganlee.me/post/blockchain/20180425</strong></a><br>微信订阅号：<strong>keeganlee_me</strong><br>写于2018-04-25</p>
<hr>
<p>专栏地址：<a href="https://xiaozhuanlan.com/fullstack" target="_blank" rel="noopener">https://xiaozhuanlan.com/fullstack</a></p>
<hr>
<p>共识机制是区块链的一个核心特征，是保证区块链系统在分布式架构下的一致性方案。目前主流的也有好多种共识算法：POW、POS、DPOS、RCP、PBFT、DBFT 等等。网上已经充斥了很多对这些共识算法的简单介绍，但基本流于表面而缺少深入的讲解，从而读者们也很难理解到这些共识机制背后的核心原理。而本文将以深入浅出的方式讲解区块链共识机制，但由于篇幅有限，因此，只会讲解最重要的两种区块链的共识机制，即比特币和以太坊的共识机制。</p>
<h2 id="比特币共识机制"><a href="#比特币共识机制" class="headerlink" title="比特币共识机制"></a>比特币共识机制</h2><p>比特币是区块链的第一个应用，也是第一个实现了共识机制的，因此，要理解区块链共识机制，自然也要先从比特币共识机制开始。另外，虽然很多文章都提到比特币的共识机制为 <strong>POW（Proof of Work，工作量证明）</strong>，但实际上，POW 只是整个比特币共识机制中的一部分，虽然是核心的那部分，但却不是全部。其实，比特币的分布式共识是由网络节点的 4 种独立过程相互作用而达成的：</p>
<ul>
<li><strong>每个全节点基于一份长长的判断标准清单对每个交易进行独立验证</strong></li>
<li><strong>每个挖矿节点独立将多个交易打包进新区块，通过完成 POW 算法的验算</strong></li>
<li><strong>每个节点独立验证新区块并组装进区块链</strong></li>
<li><strong>每个节点独立选择最长链，即在 POW 机制下累计工作量最多的那条链</strong></li>
</ul>
<p>先说第一种过程，对交易的独立验证。每个节点收到每一个交易之后，都会先根据一份很长的判断标准清单对该交易进行有效性校验，包括但不限于校验交易的语法和数据结构是否正确、输入和输出是否为空、输入总额是否小于输出总额、每一个输入所引用的输出是否已经被消费，等等。如果该交易通过所有验证，则可以说明该交易是有效的，那么，该节点就会将该交易放入本地的<strong>交易池</strong>（或称<strong>内存池</strong>），并将该交易广播给其他相临的节点。如果没通过验证，则会废弃该交易，也不会将其广播出去。其他节点接收到该交易后，也各自做同样的独立校验，校验为交易有效之后，同样也放入各节点自己的<strong>交易池</strong>，并继续广播给其他节点。所以，理论上来说，无效的交易一开始就会被废弃，而有效的交易最终会到达整个网络所有节点，并被每个全节点所保存，即全网达成了“该交易有效”的共识。</p>
<p>接着，再来聊聊第二种过程，了解有效的交易是如何被打包进区块的。经过一段时间后，一般是 10 分钟左右，每个节点的交易池里会收集到很多有效但还未确认的交易，这些交易会组装成一颗 <strong>Merkle Tree</strong>。关于 <strong>Merkle Tree</strong> 的结构，我们在之前的文章<a href="https://xiaozhuanlan.com/topic/2394807516" target="_blank" rel="noopener">《014|从微观到宏观理解区块链》</a>已经讲过，这里就不赘述了。不过，组装进 <strong>Merkle Tree</strong> 的第一笔交易是比较特殊的，这是一笔<strong>创币交易</strong>，也叫 <strong>Coinbase 交易</strong>，新的比特币就是从该笔交易产生的。这笔交易是由节点自己创建的，并将挖矿奖励支付到矿工自己的地址，挖矿奖励包括新创建的比特币和打包进该区块所有交易的手续费总额。组装好 <strong>Merkle Tree</strong> 之后，就得到 <strong>Merkle Root</strong>，再结合区块头的其他 5 个字段——<strong>Version、Pre Block、Times、Difficulty、Nonce</strong>，总共 6 个字段合在一起经过<strong>两次 SHA256 计算</strong>得到区块哈希值。一个有效的区块要求其哈希值必须小于 Difficulty 难度值，写作本文时的难度要求哈希值至少已经有 18 个 0 开头。挖矿其实就是通过修改参数的值而不断计算区块哈希值，直到计算出符合难度要求的哈希值。一般是通过修改 Nonce 值来计算区块哈希值，其他 5 个字段基本是不变的。而由于哈希函数的特性，难度值越大，理论上计算出符合要求的哈希值所需的计算量就越大。举个简单例子，比如你扔三个骰子，如果难度要求总和小于18，那是非常容易达到的，基本扔个一两次就能满足要求了；而如果加大难度，要求总和小于9，那从概率上来说相对就没那么容易了，可能要扔个十几次甚至几十次才能达到；而如果要求总和等于 3，那只能扔出三个 1 才行，这谁都知道要达到的概率是很低的，也许扔个一两百次才可能出现。因此，从统计学来说，一定的难度值可以推算出概率上对应所需的计算次数，也就是“工作量”，所以，只要你达到了难度要求，也就间接证明你付出了对应的工作量，这就是<strong>工作量证明</strong>。</p>
<p>当某个节点计算出符合难度要求的区块哈希时，即说明该矿工挖矿成功了，该节点就会将此区块组装到本地的区块链，同时也将此区块广播给其他节点。然后，就进入第三种过程了。当其他节点收到此区块时，也会各自独立验证该区块是否有效。和独立验证交易一样，也存在一份验证标准清单，包括但不限于校验引用的上一个区块是否是否正确、难度值是否符合标准、区块哈希是否真的符合难度要求、Coinbase 交易中的挖矿奖励是否多于应得的、整个区块的每笔交易是否都是有效的，等等。其中，难度值是有标准的计算公式的，每个节点都会根据标准公式独立计算实际的难度值，所以，矿工如果不按照标准而自己设置一个较低的难度，在其他节点是无法通过的。同样，挖矿奖励也是有标准公式的，所以，如果矿工给自己奖励过多的比特币，在其他节点也是同样无法通过的。每个节点验证该区块为有效之后，也会各自将该区块组装进它们本地的区块链，并继续将该区块广播给其他节点。</p>
<p>由于所有节点同时在挖同一个区块，就有可能会出现多个节点同时挖出了同个区块，并都将各自挖到的区块广播到其他节点。假设有两个节点同时挖出了新区块，分别为区块 N1 和 N2，它们的上一个区块都是 P。有些节点会先收到 N1，它们会将 N1 先组装进它们本地的区块链，也称为主链。但之后不久，这些节点也会收到 N2，这时候，它们会将 N2 放入备选链。而其他节点则先收到 N2 再收到 N1，则 N2 在它们的主链上，而 N1 在它们的备选链上。这时候，整个区块链暂时就分成了两个分叉，而要打破这种局面，就要看下一个生成的区块是基于 N1 还是 N2 了。如果下一个区块是基于 N1，自然，N1 的这条链就变成了最长链，也是累计工作量最多的链。那么，那些将 N2 链设为主链的节点就会根据实际情况自己选择将 N1 链改为主链，而 N2 将成为<strong>孤块</strong>而被废弃。</p>
<p>以上就是比特币共识机制的核心内容了，说白了其实就是根据一些所有节点都认可的标准对每个交易和区块的创建和校验进行独立验证，当大多数节点都认可并写入自己的区块链的时候，就自动形成了分布式共识。所有区块链基本都是这个逻辑，不同区块链主要在于制定的标准不同，比特币主要就是基于 POW 机制，这种机制实现简单，但它会造成大量的能源浪费，由于所有节点同时竞争挖矿同一个区块，而基本只有一个节点能胜出，那其他未胜出的节点所消耗的算力能源就白费了。另外，每次交易确认（即出块时间）大概 10 分钟，一笔交易一般要有 6 次确认才算安全，那基本就要 1 个小时了，这共识达成的时间太长了。</p>
<h2 id="以太坊共识机制"><a href="#以太坊共识机制" class="headerlink" title="以太坊共识机制"></a>以太坊共识机制</h2><p>以太坊的共识机制也是基于 POW 的，但与比特币相比，主要有两点不同：一是挖矿时间控制在 10 ~ 19 秒之间，出块时间比比特币快了很多；二是对于<strong>孤块</strong>也有挖矿奖励。在比特币中，<strong>孤块</strong>（即上文的 N2 区块）是会被丢弃的，挖出了孤块的矿工是得不到任何奖励的。但在以太坊中，孤块是能被打包进区块里的，如果后续的区块将前面产生的孤块也打包进区块里，那这个孤块就变成了<strong>叔块</strong>，那么，挖到这个叔块的矿工就能得到奖励，而将叔块打包进区块的矿工也能得到额外的奖励，但每个区块最多只能包含两个叔块，而且也不能包含太久的孤块，最多只支持到 7 层的祖先孤块。由于以太坊的出块时间短很多，那自然更容易出现临时分叉而产生孤块，而且这么短的时间内，每个区块也很难能够在全网充分传播，那对于网速慢的矿工来说，就非常吃亏了。所以，为了平衡各方利益，以太坊才设计了叔块机制。写作本文时，叔块率在 16.9% 左右。</p>
<p>不过，以太坊正在计划从 POW 机制切换为 <strong>POS（Proof of Stack，权益证明）</strong>机制，其新的共识机制名为 <strong>Casper</strong>，其存在两个不同实现的版本，分别是：</p>
<ul>
<li>Casper the Friendly Finality Gadget（FFG）</li>
<li>Casper the Friendly GHOST: Correct-by-Construction（CBC）</li>
</ul>
<p>Casper FFG 是由 Vitalik 主导的，侧重于通过逐步迭代实现，慢慢过渡到 POS 机制。而 Casper CBC 则是由 Vlad Zamfir 主导的，不同于传统的协议设计方式，即先定义完整的协议，CBC 协议在开始阶段只是部分确定的，其余部分协议以证明能够满足所需/必需属性的方式得到。不过，也只是两种不同的方法，关于 POS 的核心理念还是一致的。相对来说，FFG 比较容易理解，也很大可能是即将第一个部署到以太坊的 Casper 版本，所以下面的篇幅主要讲解 FFG。</p>
<p>FFG 版本的 Casper 是一种混合 POW / POS 的共识机制，该机制下的每次出块依然还是采用 POW 挖矿机制，但每 100 个区块会增加一个 POS <strong>检查点（checkpoint）</strong>，通过<strong>验证人（validator）</strong>来评估区块的最终有效性。创世区块是一个检查点，区块高度为 100 的倍数的区块也是检查点，将这些检查点连起来就组成了一条<strong>检查点链（checkpoint chain）</strong>。检查点一般会有两种状态：<strong>justified</strong> 和 <strong>finalized</strong>，<strong>finalized</strong> 则表示已经确定为最终有效的，该状态的检查点至少已经存在一个子检查点，<strong>justified</strong> 则表示该检查点是已经被证明合理的，<strong>finalized</strong> 的检查点一定是 <strong>justified</strong> 的，但反过来则不一定。而一个检查点是否有效，是通过多个验证人投票得出的结果。下面，我们就来简单聊聊这个过程。</p>
<p>首先，要成为验证人，是需要投入<strong>保证金</strong>的，即抵押一定量的以太币作为权益证明，才有资格成为验证人。投入保证金是通过广播一条 <strong>deposit</strong> 消息进行操作的，只要这条消息是有效的并被打包进区块中，那就能加入<strong>验证人集合（validator set）</strong>，成为其中一个验证人。另外，如果要退出<strong>验证人集合</strong>，则可以再广播一条 <strong>withdraw</strong> 消息。不过，需要注意，一旦退出后，该验证人的公钥将被永久禁止再次加入验证人集合。</p>
<p>接着，成为验证人之后，就可以开始投票选举检查点了，通过广播一条 <strong>vote</strong> 消息到网络中。vote 消息主要包含五个信息：两个检查点 <strong>s</strong> 和 <strong>t</strong>，以及这两个检查点的高度 <strong>h(s)</strong> 和 <strong>h(t)</strong>，以及验证人的公钥 <strong>ν</strong>。要求 s 必须是 t 的祖先，一般来说，t 就是最新的检查点，而 s 是上一个已经确定为最终有效的检查点。另外，还要求验证人的公钥 v 必须在验证人集合中找得到，否则都认为该投票是无效的。当超过 2/3 的验证人（实际上是 2/3 的总保证金）都投给了 (s, t) 这对检查点时，那 s 就是 <strong>finalized</strong> 的，t 则是 <strong>justified</strong> 的。而且，那些投注了 (s, t) 的验证人还会得到货币奖励，得到的奖励是和抵押的保证金成比例的，就是说抵押的保证金越多，得到的奖励越多。这个奖励也可以理解为抵押保证金的利息。</p>
<p>另外，Casper 设置了两条戒律：</p>
<ol>
<li>验证人不能发布两个 h(t) 相同的投票，即如果存在两个投票：&lt;ν, s1, t1, h(s1), h(t1)&gt; 和 &lt;ν,s2,t2,h(s2),h(t2)&gt;，那么 h(t1) = h(t2) 是不允许的；</li>
<li>如果 h(s1) &lt; h(s2) &lt; h(t2) &lt; h(t1)，则第一个投票的跨度已经涵盖了第二个投票，这也是不允许的。</li>
</ol>
<p>如果验证人违反了上面的戒律，则会对验证人进行惩罚，没收他抵押的保证金。</p>
<p>最后，Casper 对分叉链的选择不同于 POW 机制下选择累计工作量最多的那条链，Casper 对分叉链选择的规则就是选择 justified 检查点高度最大的链，原文是：</p>
<ul>
<li><strong>FOLLOW THE CHAIN CONTAINING THE JUSTIFIED CHECKPOINT OF THE GREATEST HEIGHT.</strong></li>
</ul>
<p>很明显，以太坊的共识机制和比特币相比复杂得多，主要在于两点引起的：一是大大缩短了出块时间，二是引入了 POS 机制。在 POW 机制下将出块时间缩短到十几秒，虽然加快了性能，但其实减低了安全性，因为会引入很多其他问题，比如新区块难以在这么短的时间内扩散到全网，比如分叉链出现的概率更大，为了解决这些问题，就需要设计更多共识协议来提高安全性。引入 POS 机制变成 POW + POS 的混合机制，那这种复杂度不是 1 + 1 = 2 这么简单的。</p>
<h2 id="思考和实践"><a href="#思考和实践" class="headerlink" title="思考和实践"></a>思考和实践</h2><p>EOS 的共识机制是怎样的？其安全性和性能又如何呢？</p>
<hr>
<p>扫描以下二维码即可关注订阅号。</p>
<img src="/post/blockchain/20180425/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/blockchain/20180313/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/blockchain/20180313/" class="post-title-link" itemprop="url">详解区块链P2P网络</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-03-13 16:48:12" itemprop="dateCreated datePublished" datetime="2018-03-13T16:48:12+08:00">2018-03-13</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-02 11:18:30" itemprop="dateModified" datetime="2019-07-02T11:18:30+08:00">2019-07-02</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/blockchain/" itemprop="url" rel="index"><span itemprop="name">blockchain</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/blockchain/20180313"><strong>http://keeganlee.me/post/blockchain/20180313</strong></a><br>微信订阅号：<strong>keeganlee_me</strong><br>写于2018-03-13</p>
<hr>
<p>专栏地址：<a href="https://xiaozhuanlan.com/fullstack" target="_blank" rel="noopener">https://xiaozhuanlan.com/fullstack</a></p>
<hr>
<p>根据前一篇文章《<a href="http://keeganlee.me/post/blockchain/20180224">从微观到宏观理解区块链</a>》我们已经了解到，微观上，区块链本质就是一种<strong>不可篡改且可追踪溯源的哈希链条</strong>；宏观上，还具备了另外三个基本特征：<strong>分布式存储、P2P 网络和共识机制</strong>。分布式存储无非就是网络上大部分节点都保存了整条区块链，这容易理解也不复杂，所以就没必要再展开细讲了。但区块链的 P2P 网络和共识机制相对则复杂得多，因此我将用两篇文章分别展开讲讲这两部分内容，本篇文章就先来了解区块链的 P2P 网络。</p>
<h2 id="P2P-网络"><a href="#P2P-网络" class="headerlink" title="P2P 网络"></a>P2P 网络</h2><p>由于大部分人对 P2P 网络了解甚少，因此有必要先聊聊 P2P 网络的一些基本原理。这个章节的内容主要来自<strong>《P2P对等网络原理与应用》</strong>这本书，这本书较为系统地介绍了 P2P 的理论基础，非常适合希望全面掌握 P2P 知识的初级读者，建议大伙都可以看看。</p>
<p>P2P 网络不同于传统的<strong>客户端/服务端(client/server,C/S)结构</strong>，P2P 网络中的每个节点都可以既是客户端也是服务端，因此也不适合使用 HTTP 协议进行节点之间的通信，一般都是直接使用 Socket 进行网络编程。</p>
<p>P2P 主要存在四种不同的网络模型，也代表着 P2P 技术的四个发展阶段：<strong>集中式、纯分布式、混合式和结构化模型</strong>。不过需要指出的是，这里所说的网络模型主要是指路由查询结构，即不同节点之间如何建立连接通道，两个节点之间一旦建立连接，具体传输什么数据则是两个节点之间的事情了。</p>
<p>最简单的路由方式就是<strong>集中式</strong>，即存在一个中心节点保存了其他所有节点的索引信息，索引信息一般包括节点 IP 地址、端口、节点资源等。集中式路由的优点就是结构简单、实现容易。但缺点也很明显，由于中心节点需要存储所有节点的路由信息，当节点规模扩展时，就很容易出现性能瓶颈；而且也存在单点故障问题。</p>
<img src="/post/blockchain/20180313/2018-03-06-22-25-08.jpg">

<p>那第二种路由结构则是<strong>纯分布式</strong>的，移除了中心节点，在 P2P 节点之间建立随机网络，就是在一个新加入节点和 P2P 网络中的某个节点间随机建立连接通道，从而形成一个随机拓扑结构。新节点加入该网络的实现方法也有很多种，最简单的就是随机选择一个已经存在的节点并建立邻居关系。像比特币的话，则是使用 DNS 的方式来查询其他节点，DNS 一般是硬编码到代码里的，这些 DNS 服务器就会提供比特币节点的 IP 地址列表，从而新节点就可以找到其他节点建立连接通道。新节点与邻居节点建立连接后，还需要进行全网广播，让整个网络知道该节点的存在。全网广播的方式就是，该节点首先向邻居节点广播，邻居节点收到广播消息后，再继续向自己的邻居节点广播，以此类推，从而广播到整个网络。这种广播方法也称为<strong>泛洪机制</strong>。纯分布式结构不存在集中式结构的单点性能瓶颈问题和单点故障问题，具有较好的可扩展性，但泛洪机制引入了新的问题，主要是可控性差的问题，包括两个较大的问题，一是容易形成泛洪循环，比如节点 A 发出的消息经过节点 B 到 节点 C，节点 C 再广播到节点 A，这就形成了一个循环；另一个棘手问题则是响应消息风暴问题，如果节点 A 想请求的资源被很多节点所拥有，那么在很短时间内，会出现大量节点同时向节点 A 发送响应消息，这就可能会让节点 A 瞬间瘫痪。</p>
<img src="/post/blockchain/20180313/2018-03-07-10-54-06.jpg">

<p>再来看看第三种路由结构：<strong>混合式</strong>。混合式其实就是混合了集中式和分布式结构，如下图所示，网络中存在多个<strong>超级节点</strong>组成分布式网络，而每个超级节点则有多个<strong>普通节点</strong>与它组成局部的集中式网络。一个新的普通节点加入，则先选择一个超级节点进行通信，该超级节点再推送其他超级节点列表给新加入节点，加入节点再根据列表中的超级节点状态决定选择哪个具体的超级节点作为父节点。这种结构的泛洪广播就只是发生在超级节点之间，就可以避免大规模泛洪存在的问题。在实际应用中，混合式结构是相对灵活并且比较有效的组网架构，实现难度也相对较小，因此目前较多系统基于混合式结构进行开发实现。其实，比特币网络如今也是这种结构，后面再细说。</p>
<img src="/post/blockchain/20180313/2018-03-06-22-27-23.jpg">

<p>最后一种网络则是<strong>结构化 P2P 网络</strong>，它也是一种分布式网络结构，但与纯分布式结构不同。纯分布式网络就是一个随机网络，而结构化网络则将所有节点按照某种结构进行有序组织，比如形成一个环状网络或树状网络。而结构化网络的具体实现上，普遍都是基于 <strong>DHT(Distributed Hash Table，分布式哈希表) *<em>算法思想。DHT 只是提出一种网络模型，并不涉及具体实现，主要想解决如何在分布式环境下快速而又准确地路由、定位数据的问题。具体的实现方案有 Chord、Pastry、CAN、Kademlia 等算法，其中 *</em>Kademlia</strong> 也是以太坊网络的实现算法，很多常用的 P2P 应用如 BitTorrent、电驴等也是使用 Kademlia。因为篇幅有限，就不展开讲这些算法的具体原理了。目前，我们主要理解 DHT 的核心思想即可。</p>
<p>在 P2P 网络中，可以抽象出两种空间：<strong>资源空间</strong>和<strong>节点空间</strong>。资源空间就是所有节点保存的资源集合，节点空间就是所有节点的集合。对所有资源和节点分别进行编号，如把资源名称或内容用 Hash 函数变成一个数值（这也是 DHT 常用的一种方法），这样，每个资源就有对应的一个 ID，每个节点也有一个 ID，资源 ID 和节点 ID 之间建立起一种映射关系，比如，将资源 n 的所有索引信息存放到节点 n 上，那要搜索资源 n 时，只要找到节点 n 即可，从而就可以避免泛洪广播，能更快速而又准确地路由和定位数据。当然，在实际应用中，资源 ID 和节点 ID 之间是无法做到一一对应的，但因为 ID 都是数字，就存在大小关系或偏序关系等，基于这些关系就能建立两者的映射关系。这就是 DHT 的核心思想。DHT 算法在资源编号和节点编号上就是使用了分布式哈希表，使得资源空间和节点空间的编号有唯一性、均匀分布式等较好的性质，能够适合结构化分布式网络的要求。</p>
<p>综上，这就是 P2P 网络的一点理论基础，不同的区块链可能会使用不一样的网络模型，但基本原理是一样的。后面分别讲解下最有代表性的两个区块链的网络：比特币网络和以太坊网络。</p>
<h2 id="比特币网络"><a href="#比特币网络" class="headerlink" title="比特币网络"></a>比特币网络</h2><p>首先，比特币网络中的节点主要有四大功能：<strong>钱包、挖矿、区块链数据库、网络路由</strong>。每个节点都会具备路由功能，但其他功能不一定都具备，不同类型的节点可能只包含部分功能，一般只有<strong>比特币核心(bitcoin core)</strong>节点才会包含所有四大功能。</p>
<img src="/post/blockchain/20180313/2018-03-09-16-35-26.jpg">

<p>所有节点都会参与校验和广播交易及区块信息，且会发现和维持与其他节点的连接。有些节点会包含完整的区块链数据库，包括所有交易数据，这种节点也称为<strong>全节点(Full Node)</strong>。另外一些节点只存储了区块链数据库的一部分，一般只存储区块头而不存储交易数据，它们会通过“<strong>简化交易验证(SPV)</strong>”的方式完成交易校验，这样的节点也称为 <strong>SPV节点</strong>或<strong>轻节点(Lightweight Node)</strong>。钱包一般是 PC 或手机客户端的功能，用户通过钱包查看自己的账户金额、管理钱包地址和私钥、发起交易等。除了比特币核心钱包是全节点之外，大部分钱包都是<strong>轻节点</strong>。挖矿节点则通过解决<strong>工作量证明(PoW)</strong>算法问题，与其他挖矿节点相互竞争创建新区块。有些挖矿节点同时也是<strong>全节点</strong>，即也存储了完整的区块链数据库，这种节点一般都是<strong>独立矿工(Solo Miner)</strong>。还有一些挖矿节点不是独立挖矿的，而是和其他节点一起连接到<strong>矿池</strong>，参与集体挖矿，这种节点一般也称为<strong>矿池矿工(Pool Miner)</strong>。这会形成一个局部的集中式矿池网络，中心节点是一个<strong>矿池服务器</strong>，其他挖矿节点全部连接到矿池服务器。<strong>矿池矿工</strong>和<strong>矿池服务器</strong>之间的通信也不是采用标准的<strong>比特币协议</strong>，而是使用<strong>矿池挖矿协议</strong>，而矿池服务器作为一个<strong>全节点</strong>再与其他比特币节点使用主网络的<strong>比特币协议</strong>进行通信。</p>
<p>在整个比特币网络中，除了不同节点间使用<strong>比特币协议</strong>作为通信协议的主网络，也存在很多扩展网络，包括上面提到的<strong>矿池网络</strong>。不同的矿池网络可能还会使用不同的矿池挖矿协议，目前主流的具体矿池协议应该是 <strong>Stratum协议</strong>，该协议除了支持挖矿节点，也支持<strong>瘦客户端钱包</strong>。一个包含了比特币协议主网络各种节点和 Stratum 网络，以及其他矿池网络的扩展比特币网络大概如下图所示：</p>
<img src="/post/blockchain/20180313/bitcoin-network.jpeg">

<p>另外，挖矿这块还有特殊需求。我们知道，矿工创建新区块后，是需要广播给全网所有节点的，当全网都接受了该区块，给矿工的挖矿奖励才算是有效的，这之后才好开始下一个区块 Hash 的计算。所以矿工必须最大限度缩短新区块的广播和下一个区块 Hash 计算之间的时间。如果矿工之间传播区块只采用上图所示的比特币协议网络，那无疑会有很高的网络延迟，所以，需要一个专门的传播网络用来加快新区块在矿工之间的同步传播，这个专门网络也叫<strong>比特币传播网络</strong>或<strong>比特币中继网络(Bitcoin Relay Network)</strong>。</p>
<h2 id="以太坊网络"><a href="#以太坊网络" class="headerlink" title="以太坊网络"></a>以太坊网络</h2><p>和比特币一样，以太坊的节点也具备<strong>钱包、挖矿、区块链数据库、网络路由</strong>四大功能，也同样存在很多不同类型的节点，除了主网络之外也同样存在很多扩展网络。但与比特币不同的，比特币主网的 P2P 网络是无结构的，但以太坊的 P2P 网络是有结构的。前面我们已经提过，以太坊的 P2P 网络主要采用了 <strong>Kademlia(简称 Kad)</strong> 算法实现，Kad 是一种<strong>分布式哈希表(DHT)</strong>技术，使用该技术，可以实现在分布式环境下快速而又准确地路由、定位数据的问题。所以，下面主要讲解下以太坊的 Kad 网络。</p>
<p>在 Kad 网络中，每个节点都具有一个唯一的节点 ID。另外，也会计算不同节点之间的距离，但这个距离不是物理上的距离，而是逻辑上的距离，是通过对两个节点 ID 进行 <strong>异或(符号为^)</strong> 计算得到的，即 A、B 两节点之间的距离的计算公式为：<strong>D(A,B) = A.ID^B.ID</strong>。异或有一个重要的性质：假设 a、b、c 为任意三个数，如果 a^b = a^c 成立，那就一定 b = c。因此，如果给定一个结点 a 和距离 L，那就有且仅有一个结点 b, 会使得 D(a,b) = L。通过这种方式，就能有效度量 Kad 网络中不同节点之间的逻辑距离。</p>
<p>在异或距离度量的基础上，Kad 还可以将整个网络拓扑组织成如下图所示的一个<strong>二叉前缀树</strong>，每个 NodeID 会映射到二叉树上的某个叶子。</p>
<img src="/post/blockchain/20180313/2018-03-13-12-31-47.png">

<p>映射规则主要是：</p>
<ol>
<li>将 NodeID 以二进制形式表示，然后从高到低对每一位的 0 或 1 依次处理；</li>
<li>二进制的第 n 位就对应了二叉树的第 n 层；</li>
<li>如果该位是 0，进入左子树，是 1 则进入右子树（反过来也可以）；</li>
<li>全部位都处理完后，这个 NodeID 就对应了二叉树上的某个叶子。</li>
</ol>
<p>在这种二叉树结构下，对每个节点来说，离它越近的节点异或距离也是越近的。接着，可以按照离自己异或距离的远近，对整颗二叉树进行拆分。拆分规则是：从根节点开始，将不包括自己的那颗子树拆分出来，然后在包含自己的子树中，把不包括自己的下一层子树再拆分出来，以此类推，直到只剩下自己。以上图的 110 节点为例，从根节点开始，由于 110 节点在右子树，所以将左边的整颗子树拆分出来，即包含 000、001、010 这三个节点的这颗子树；接着，到第二层子树，将不包含 110 节点的左子树再拆分出来，即包含 100 和 101 这两个节点的子树；最后，再将 111 拆分出来。这样，就将 110 节点之外的整个二叉树拆分出了三颗子树。</p>
<p>完成子树拆分后，只要知道每个子树里面的其中一个节点，就可以进行递归路由实现整颗二叉树所有节点的遍历。但在实际场景下，由于节点是动态变化的，所以一般不会只知道每个子树的一个节点，而是需要知道多个节点。因此，Kad 中有一个叫 <strong>K-桶(K-bucket)</strong>的概念，每个桶会记录每颗子树里所知道的多个节点。其实，一个<strong>K-桶</strong>就是一张<strong>路由表</strong>，如果拆分出来有 m 颗子树，那对应节点就需要维护 m 个路由表。每个节点都会各自维护自己的 m 个 K-桶，每个 K-桶里记录的节点信息一般会包括 NodeID、IP、Endpoint、与 Target 节点（即维护该 K-桶的节点）的异或距离等信息。以太坊中，每个节点维护的 K-桶数量为 256 个，这 256 个 K-桶会根据与 Target 节点的异或距离进行排序，每个 K-桶保存的节点数量上限是 16。</p>
<p>在以太坊的 Kad 网络中，节点之间的通信是基于 UDP 的，另外设置了 4 个主要的通信协议：</p>
<ol>
<li><strong>Ping</strong>：用于探测一个节点是否在线</li>
<li><strong>Pong</strong>：用于响应 Ping 命令</li>
<li><strong>FindNode</strong>：用于查找与 Target 节点异或距离最近的其他节点</li>
<li><strong>Neighbours</strong>：用于响应 FindNode 命令，会返回一或多个节点</li>
</ol>
<p>通过以上 4 个命令，就可以实现新节点的加入、K-桶的刷新等机制。具体的实现流程就不细讲了，留给大伙自己去思考。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不同结构的 P2P 网络，会有不同的优点和缺点。比特币网络的结构明显容易理解，实现起来也相对容易得多，而以太坊网络引入了异或距离、二叉前缀树、K-桶等，结构上复杂不少，但在节点路由上的确会比比特币快很多。另外，不管是比特币还是以太坊，其实都只是一种或多种协议的集合，不同节点其实可以用不同的具体实现，比如，比特币就有用 C++ 实现的 Bitcoin Core，还有用 Java 实现的 BitcoinJ；以太坊也有用 Go 语言实现的 go-ethereum，也有用 C++ 实现的 go-ethereum，还有用 Java 实现的 Ethereum(J)。</p>
<h2 id="思考和实践"><a href="#思考和实践" class="headerlink" title="思考和实践"></a>思考和实践</h2><p>在以太坊的 Kad 网络中，新节点的加入和 K-桶的刷新流程是怎样的？比特币的新节点加入流程又是怎样的？哈希表有哪些实现方式？</p>
<hr>
<p>扫描以下二维码即可关注订阅号。</p>
<img src="/post/blockchain/20180313/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/blockchain/20180224/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/blockchain/20180224/" class="post-title-link" itemprop="url">从微观到宏观理解区块链</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-02-24 00:09:49" itemprop="dateCreated datePublished" datetime="2018-02-24T00:09:49+08:00">2018-02-24</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-02 11:18:28" itemprop="dateModified" datetime="2019-07-02T11:18:28+08:00">2019-07-02</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/blockchain/" itemprop="url" rel="index"><span itemprop="name">blockchain</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/blockchain/20180224"><strong>http://keeganlee.me/post/blockchain/20180224</strong></a><br>微信订阅号：<strong>keeganlee_me</strong><br>写于2018-02-24</p>
<hr>
<p>专栏地址：<a href="https://xiaozhuanlan.com/fullstack" target="_blank" rel="noopener">https://xiaozhuanlan.com/fullstack</a></p>
<hr>
<p>最近区块链异常火爆，而且就只是在这一两个月内的事情，无疑，今年应该会成为区块链爆发元年，相应地，对区块链技术人员的需求将会大幅度增加，为了让大家早日入门区块链开发领域，以取得先发优势，从而在这场区块链革命浪潮中立于不败之地，因此，我决定提前编写系列文章，跟大家聊聊区块链技术。</p>
<h2 id="微观区块链"><a href="#微观区块链" class="headerlink" title="微观区块链"></a>微观区块链</h2><p>相信不少人都听到说<strong>区块链</strong>是分布式账本、分布式数据库、去中心化的等等，有了一些大概的认知，但也只是一些碎片化的认知，还无法形成体系，所以也还不能理解区块链的本质。下面，我将从微观到宏观简单讲解区块链，力求让大伙更容易理解区块链的真正本质。</p>
<p>那么，从微观上理解区块链，就要从理解区块链最底层的数据结构开始。<strong>区块链(Blockchain)</strong>，简单来说就是按时间顺序将数据区块通过哈希指针的方式连接起来的一个链表。<strong>哈希指针</strong>是区块链里最常用的数据结构，其实就是一串数据的<strong>哈希值</strong>，我们知道，一串数据的哈希值就是这串数据的<strong>指纹/摘要</strong>，因此就可以用这个哈希值来指向这串数据，如下图：</p>
<img src="/post/blockchain/20180224/2018-02-07-12-50-00.jpg">
<p>区块链里的每一个区块都有对应本区块的哈希指针，而除了创世区块（即第一个区块）之外，其他每个区块都存储了前一个区块的哈希指针，从而形成如下所示的一个链条，即区块链：</p>
<img src="/post/blockchain/20180224/blockchain.png">
<p>这样的数据结构可以保证数据无法篡改，因为一旦篡改了任何区块的数据，对应的哈希指针就会出错，因此一旦有恶意篡改就能校验到。数据的无法篡改也是区块链本质上最核心的一个特性。</p>
<p>接着，再来看看区块链的基本单元——<strong>区块(block)</strong>，以比特币为例，每个区块的数据结构大致如下：</p>
<img src="/post/blockchain/20180224/block.png">
<p>其中，<strong>Tx0 ~ Tx3</strong> 表示每一笔交易数据，<strong>Hash0</strong> 则是 <strong>Tx0</strong> 这笔交易数据的哈希指针，<strong>Hash01</strong> 则是 <strong>Hash0 + Hash1</strong> 的哈希指针，这样层层叠加上去，得到最后的 <strong>Root Hash</strong>。从图中也可以看出，从Hash0 到 Root Hash 是一个三层的二叉树，由于这颗树的所有节点都是 Hash 值，所以也称为 Hash Tree，但更专业的名称叫 <strong>Merkle Tree</strong>。不过 Merkle Tree 不一定是二叉树，也可以是多叉树。Merkle Tree 的叶子节点（即Hash0 ~ Hash3）是数据块的 Hash 值，而非叶子节点的 value 则是根据下面的叶子节点的 Hash 值串联起来后再计算 Hash 得出的。通过 Merkle Tree 结构，底层的每一笔交易也都无法篡改，一旦篡改，Root Hash 就会不一致。</p>
<p>另外，该结构也简化了支付校验，比如，我们要校验 Tx3 这笔交易的有效性，那只要校验从 Tx3 到  Root Hash 的分支 Hash 值即可，如下图所示，计算 Tx3 的 Hash值得到 Hash3，再结合 Hash2，计算出 Hash23，再拼上 Hash01 计算出 Merkle Root，只要计算出来的 Merkle Root 和实际存储的 Root Hash 一致，则表明该该笔交易是有效的。</p>
<img src="/post/blockchain/20180224/2018-02-20-23-20-02.jpg">
<p>Root Hash 会保存在区块头里，区块头里一般会保存有以下信息：</p>
<ul>
<li><strong>Version</strong>：版本号</li>
<li><strong>Prev Block</strong>：上一个区块的 Hash 值</li>
<li><strong>Merkle Root</strong>：即上面所说的 Merkle Tree 的 Root Hash</li>
<li><strong>Time</strong>：区块的时间</li>
<li><strong>Difficulty</strong>：区块难度</li>
<li><strong>Nonce</strong>：随机数</li>
</ul>
<p>这是比特币的一个区块：<a href="https://btc.com/0000000000000000005b8d4d2508c14f6ea5cbbb3f1104566612dfb29d281b7a" target="_blank" rel="noopener">https://btc.com/0000000000000000005b8d4d2508c14f6ea5cbbb3f1104566612dfb29d281b7a</a>。比特币的每一笔交易，可以有多个输入和多个输出。比如说，我们要做一笔转账，从 A 转 3.3 个 BTC 到 B，假设 A 的钱包地址上原本有 10 个 BTC。那这笔转账，会有一个输入，即 A 的地址有 10 个 BTC，交易完成后变成两个输出，一个是 B 的地址增加 3.3 个 BTC，一个是 A 的地址变成 6.7 个 BTC。这样子，每一个地址的所有交易其实都是可以追溯的，每一个比特币的转账记录也是可以追溯的。</p>
<p>不过，以太坊的区块结构则复杂得多，每个区块并非只有一颗 Merkle Tree，而是有三颗 Merkle Tree，除了<strong>交易树</strong>，还有<strong>状态树</strong>和<strong>收据树</strong>。另外，使用的 Merkle Tree 也是复杂得多，叫 <strong>Merkle Patricia Tree</strong>。详细结构就不展开了，感兴趣的读者自行去搜索了解即可。</p>
<p>简而言之，从微观上来说，区块链就是一种哈希链条，其核心本质特征是<strong>不可篡改且可追踪溯源</strong>。</p>
<h2 id="宏观区块链"><a href="#宏观区块链" class="headerlink" title="宏观区块链"></a>宏观区块链</h2><p>如果只是从微观上理解区块链，那就像井底之蛙，是看不到区块链即将改变世界的未来的。毕竟，从微观上来看的话，要实现不可篡改且可追踪溯源的特性，并不一定需要使用区块链技术。所以，还要看懂区块链宏观上的本质，才能预见到区块链真实的未来。</p>
<p>当然，宏观上来说，区块链的本质是什么，不同人会有不同观点，不少人认为其本质特征是<strong>去中心化的</strong>，另一帮人认为其本质就是<strong>分布式数据库/分布式公共账本</strong>，而在我看来，其核心本质就是一种<strong>自信任的新一代互联网基础协议</strong>。下面我将逐步剖析我的观点。</p>
<p>首先，宏观上的区块链就是一种基础协议，而不是指代具体的技术。作为一种基础协议，有几个基本特征是必备的，那就是<strong>分布式存储、P2P 网络和共识机制</strong>，当然，还有微观层面的<strong>不可篡改且可追踪溯源</strong>，如果不具备这几个特征，哪怕只缺了一个，都不能称为区块链。</p>
<p>先来聊聊第一个基本特征——<strong>分布式存储</strong>。前面我们已经了解到，区块链最底层的数据结构就是一种哈希链条，是用来存储数据的，当然，采用哪种具体的数据库来存储区块链数据则是由各区块链的开发团队自己决定的，比如，比特币和以太坊就选择了 LevelDB。分布式存储，就是说，区块链数据的存储是分布式的，也因此很多人将区块链称为分布式数据库，但区块链的分布式存储与传统的分步式存储有所不同。传统的分布式存储是将数据分散存储到多个服务器上，每个存储服务器上的数据只是全量数据的一部分。但区块链的分布式存储，每个数据节点存储的都是全量数据。不过，区块链的节点可分为<strong>全节点</strong>和<strong>轻节点</strong>，全节点存储了整条区块链的所有数据，包括所有区块头和所有交易数据，而轻节点则只存储了整条链的所有区块头。那如果要在轻节点查询某笔交易的有效性，就需要转去全节点查询了，那节点之间如何通信呢？这就涉及到第二个基本特征——<strong>P2P 网络</strong>。另外，既然是分布式存储，那就还要解决数据一致性的问题，就这涉及到第三个基本特征——<strong>共识机制</strong>。</p>
<p><strong>P2P 网络</strong>，即<strong>对等网络</strong>，也称<strong>点对点网络</strong>或<strong>端对端网络</strong>，是区块链系统中不同节点之间通信的方式，也是一种分布式的网络结构。通过 P2P 网络，不同节点之间可以直接交互，而且彼此连接的每个节点都处于对等的地位。每个节点既充当服务器，为其他节点提供服务，同时也享用其他节点提供的服务。那么，既然每个节点的地位都是对等的，那不同节点之间出现分歧时，要如何达成一致共识呢？这也是<strong>共识机制</strong>所解决的问题。</p>
<p><strong>共识机制</strong>是区块链的一个核心特征，是保证区块链系统在分布式架构下的一致性方案。要理解共识机制，我们先来了解下交易写入区块链的简要过程。首先，当你在某个节点发起一笔交易时，比如从地址 A 转 0.1 个 BTC 到地址 B，该节点接收到交易信息后就对其进行校验，如果地址 A 上的未消费 BTC 的余额大于 0.1 个则可认为该笔交易是合法的，那就会将这笔交易信息放入本节点的 pending 池（待写入区块的交易池），并将这笔交易信息<strong>广播</strong>给其他已建立连接的节点，其他节点接收到交易信息后也做同样的校验并广播，当其中某个节点获得记账权时则可将它<strong>当前的区块（包含上面那笔交易）</strong>写入本节点存储的区块链中并将这个区块广播出去，其他大部分节点校验了此区块为有效，也同样写入它们自己存储的区块链中，这样，你的这笔交易就算真正写入到区块链中了。那如果你同时向 B 和 C 地址分别转 0.1 个 BTC，但你的地址 A 的未消费 BTC 余额只有 0.1 个的情况下，假设有些节点可能只接收到转给 B 的交易，而有些节点则只接收到转到 C 的交易，这些节点分别校验通过并写入了它们的 pending 池，但最终只有其中一笔交易能被写入区块链，取决于哪个节点先获得记账权并被其他大部分节点所接受，而另一笔交易就算已经被那些将其写入了 pending 池的节点所接受，其他节点再次校验后也不会通过。所以，一笔交易是否合法，以及一个新增区块是否有效，不是由某一个节点说了算，而是需要经过多数节点的最终一致共识。</p>
<p>根据区块链的这几个基本特征，明显可以看出，区块链的确是<strong>分布式</strong>的：<strong>分布式存储、分布式网络、分布式共识</strong>。分布式的确是一个重要的特征，但分布式只是一种手段，而不是目的。区块链之所以能被称为革命性的技术，是因为它改变了传统的信任机制。传统的信任机制是怎样的呢？其实就是有一个中间机构为信任背书，比如银行、淘宝、滴滴等，我们通过信任这些中间机构和其他人进行交易。而区块链则没有中间机构这一层了，用户之间直接点对点交易，区块链的数据结构、分布式存储特性和共识机制结合在一起，保证了数据是可靠且不可篡改的，从而实现了一个不需要中间机构的<strong>自信任系统</strong>。也由于没有了中间机构，所以也可以说区块链是<strong>去中心化</strong>的，但这里更准确的说法可能是<strong>去中介化</strong>。但<strong>去中介化</strong>和<strong>分布式</strong>一样，只是手段，而不是目的，核心目的还是构建一个<strong>自信任系统</strong>。</p>
<p>那自信任系统相比有中间机构的信任机制有什么好处呢？我们就举个跨境支付的栗子就明白了。传统的交易支付都要经过银行体系，要经过开户行、对手行、清算组织、境外银行等多个机构和非常繁冗的处理流程。而且，整个过程中每一个机构都有自己的账务系统，彼此之间需要建立代理关系，每笔交易都需要在本银行记账，与交易对手进行清算和对账等，导致整个过程花费时间较长、使用成本较高。而有了区块链，交易双方就可以实现点对点支付，而无需这么多中间机构，从而<strong>简化流程、提高效率</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，总结一下，我分别从微观和宏观两个层面简单聊了下区块链，微观上，其实就是区块链最底层的数据结构，本质就是一种<strong>不可篡改且可追踪溯源的哈希链条</strong>；宏观上，区块链还具备了另外三个基本特征：<strong>分布式存储、P2P 网络和共识机制</strong>，从这几个基本特征可以看出，区块链是<strong>分布式</strong>的，但分布式只是手段，而不是目的，区块链的核心目的是构建一个<strong>自信任系统</strong>，相比依赖中间机构的信任机制，可以<strong>简化流程、提高效率</strong>，这才是区块链之所以能被称为革命性技术的本质原因。</p>
<h2 id="思考和实践"><a href="#思考和实践" class="headerlink" title="思考和实践"></a>思考和实践</h2><p>智能合约为区块链带来了什么？区块链是否必须有数字代币？公有链、联盟链、私有链本质上有什么区别？</p>
<hr>
<p>扫描以下二维码即可关注订阅号。</p>
<img src="/post/blockchain/20180224/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/reading/20160722/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/reading/20160722/" class="post-title-link" itemprop="url">读《图解密码技术》(三):密钥、随机数和应用技术</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-07-22 12:00:00" itemprop="dateCreated datePublished" datetime="2016-07-22T12:00:00+08:00">2016-07-22</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-02 12:09:31" itemprop="dateModified" datetime="2019-07-02T12:09:31+08:00">2019-07-02</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/reading/" itemprop="url" rel="index"><span itemprop="name">reading</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/reading/20160722"><strong>http://keeganlee.me/post/reading/20160722</strong></a><br>微信订阅号：<strong>keeganlee_me</strong><br>写于2016-07-22</p>
<hr>
<p><a href="http://keeganlee.me/post/reading/20160629">读《图解密码技术》(一):密码</a><br><a href="http://keeganlee.me/post/reading/20160705">读《图解密码技术》(二):认证</a><br><a href="http://keeganlee.me/post/reading/20160722">读《图解密码技术》(三):密钥、随机数和应用技术</a></p>
<hr>
<p>最后一篇了，如果还没看过前两篇的，最好先翻回去看看，因为这最后一篇的内容是建立在前两篇的基础之上的。本篇的内容包括密钥、随机数、PGP、SSL/TLS，最后再讲讲密码技术的现状和局限性，以及简单介绍一下量子密码和量子计算机。</p>
<h2 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h2><p>在使用对称密码、公钥密码、消息认证码、数字签名等密码技术时，都需要密钥。密钥长度一般不能太短，太短意味着密钥空间太小，那么，进行暴力破解就很容易。</p>
<p>DES的密钥长度为56比特(7字节)，密钥空间为2^56，在现有的计算能力下，还是比较容易被暴力破解的。三重DES的DES-EDE3的密钥长度为168比特(21字节)，是DES的密钥长度的三倍多，但是密钥空间可不是三倍这么简单，DES-EDE3的密钥空间为2^168，整整是DES密钥空间的2^112倍，这么大的密钥空间，以现有的计算能力，还无法在现实的时间里被暴力破解。AES的密钥长度则可以从128、192和256比特中进行选择，三者的密钥空间也是不小的。</p>
<p>密钥和明文其实是等价的，因为对攻击者来说，得到密钥就等价于得到明文。</p>
<blockquote>
<h3 id="各种不同的密钥"><a href="#各种不同的密钥" class="headerlink" title="各种不同的密钥"></a>各种不同的密钥</h3></blockquote>
<p>从前两篇文章我们就知道，密钥分很多种类，这里我们做一下整理。</p>
<p>在对称密码中，加密和解密使用的是相同的<strong>共享密钥</strong>。而在公钥密码中，加密用的是<strong>公钥</strong>，解密用的则是<strong>私钥</strong>，相对应的公钥和私钥组为<strong>密钥对</strong>。消息认证码使用的也是共享密钥。而数字签名使用的和公钥密码一样是密钥对，用私钥签名，用公钥验证签名。混合密码系统中还使用了一次性密钥，称为<strong>会话密钥</strong>。而相对于每次通信都更换的会话密钥，一直被重复使用的密码则称为<strong>主密钥</strong>。用于加密内容的密钥称为<strong>CEK</strong>(Contents Encrypting Key，内容加密密钥)；相对地，用于加密密钥的密钥则称为<strong>KEK</strong>(Key Encrypting Key，密钥加密密钥)。CEK 和 KEK 的用法可以如下图所示：</p>
<img src="/post/reading/20160722/12-34-15.jpg">

<p>在很多情况下，会话密钥都是被作为 CEK 使用的，而主密钥则是被作为 KEK 使用的。</p>
<blockquote>
<h3 id="密钥的管理"><a href="#密钥的管理" class="headerlink" title="密钥的管理"></a>密钥的管理</h3></blockquote>
<p>生成密钥最好的方法就是使用真正的随机数，因为密钥需要具备不可预测性。不过，一般我们都是使用伪随机数生成器来生成密钥。另外，密码学用途的伪随机数生成器必须是专门针对密码学用途而设计的。毕竟，生成伪随机数的算法很多，但有些并不具备不可预测性。</p>
<p>有时我们也会使用容易记住的<strong>口令</strong>(password 或 passphrase)来生成密钥。passphrase 指的是一种由多个单词组成的较长的 passwrod，在此将两者统称为口令。严格来说，很少直接用口令来作为密钥使用，一般都是将口令输入单向散列函数，然后将得到的散列值作为密钥使用。而在使用口令生成密钥时，为了防止字典攻击，需要在口令上面附加一串称为<strong>盐</strong>(salt)的随机数，然后再将其输入单向散列函数。这种方法称为“基于口令的密码”(Password Based Encryption, PBE)。关于 PBE 稍后再详细介绍。</p>
<p>对于共享密钥，就会存在密钥配送问题。在<a href="http://keeganlee.me/post/reading/20160629">密码篇</a>就提到几种解决方案：<strong>事先共享密钥</strong>、<strong>使用密钥分配中心</strong>、<strong>使用公钥密码</strong>、<strong>Diffie-Hellman密钥交换</strong>。关于Diffie-Hellman密钥交换的原理，之前的文章没讲，在本篇稍后会详细介绍。</p>
<p>为了提高通信的机密性，还可以采用<strong>密钥更新</strong>(key updating)的方法。这种方法就是在使用共享密钥进行通信的过程中，定期改变密钥。例如，在更新密钥时，发送者和接收者使用单向散列函数计算当前密钥的散列值，并将这个散列值用作新的密钥。简单说，就是<strong>用当前密钥的散列值作为下一个密钥</strong>。</p>
<p>除了只使用一次的会话密钥，其他密钥基本都需要考虑<strong>保存密钥</strong>的问题。尤其对于共享密钥来说，很多应用都需要将密钥保存在客户端，例如移动App，要么将密钥硬编码在代码里，或者保存在文件中，但无论哪种方式，应用一旦被反编译，密钥就存在泄漏的风险。以防密钥被盗，可以使用<strong>将密钥加密后保存</strong>的方法。但要将密钥加密，必然需要另一个密钥，即 KEK。那么，KEK 又如何保存？这问题还真不好解决。不过，对密钥进行加密的方法却可以<strong>减少需要保管的密钥数量</strong>。比如，假设平台系统接入了10万个应用，每个应用都有一个自己的密钥，即系统需要保管10万个密钥。那么，用 KEK 对这10万个密钥进行加密，这样的话只要保管这一个 KEK 就可以了。即是说，不需要确保多个密钥(CEK)的机密性，而只需要确保一个密钥(KEK)的机密性就可以了。这和认证机构的层级化非常相似。在后者中，我们不需要信任多个认证机构，而只需要信任一个根 CA 就可以了。</p>
<blockquote>
<h3 id="Diffie-Hellman密钥交换"><a href="#Diffie-Hellman密钥交换" class="headerlink" title="Diffie-Hellman密钥交换"></a>Diffie-Hellman密钥交换</h3></blockquote>
<p>通过Diffie-Hellman密钥交换算法，通信双方仅通过交换一些可以公开的信息就能够生成出共享的秘密数字，而这一秘密数字就可以被用作对称密码的密钥。虽然这种方法名字叫“密钥交换”，但实际上双方并没有真正交换密钥，而是通过计算生成出了一个相同的共享密钥。因此，这种方法也称为<strong>Diffie-Hellman密钥协商</strong>。</p>
<p>Diffie-Hellman密钥交换的步骤如下：</p>
<img src="/post/reading/20160722/16-19-35.jpg">

<ol>
<li><strong>Alice 向 Bob 发送两个质数 P 和 G</strong><br>P 必须是一个非常大的质数，而 G 则是一个和 P 相关的数，称为<strong>生成元</strong>(generator)。G 可以是一个较小的数字。</li>
<li><strong>Alice 生成一个随机数 A</strong><br>A 是一个 1 ~ P-2 之间的整数。这个数是一个只有 Alice 知道的秘密数字。</li>
<li><strong>Bob 生成一个随机数 B</strong><br>B 也是一个 1 ~ P-2 之间的整数。这个数是一个只有 Bob 才知道的秘密数字。</li>
<li><strong>Alice 将 G^A mod P 计算结果的数发送给 Bob</strong></li>
<li><strong>Bob 将  G^B mod P 计算结果的数发送给 Alice</strong></li>
<li><strong>Alice 用 Bob 发过来的数计算 A 次方并求 mod P</strong><br>这个数就是共享密钥。Alice 计算的密钥 = (G^B mod P)^A mod P = G^(A*B) mod P</li>
<li><strong>Bob 用 Alice 发过来的数计算 B 次方并求 mod P</strong><br>Bob 计算的密钥 = (G^A mod P)^B mod P = G^(A*B) mod P = Alice 计算的密钥。可见两方计算的密钥是相等的。</li>
</ol>
<p>关于第1步提到的生成元是什么呢？先来看一张表，假设 P = 13：</p>
<img src="/post/reading/20160722/16-45-42.jpg">

<p>其中，2、6、7、11都是13的生成元。这几个数有什么性质呢？从上表可以发现，这几个数的乘方结果中都出现了1~12的全部整数。也就是说，P 的生成元的乘方结果与 1 ~ P-1 中的数字是一一对应的。正是因为具有这样一一对应的关系，Alice 才能够从 1 ~ P-2 的范围中随机选择一个数字(之所以不能选择 P-1，是因为 G^(P-1) mod P 的值一定是等于1的)。</p>
<p>最后，需要清楚，针对Diffie-Hellman密钥交换是可以发动中间人攻击的。而为了防止中间人攻击，可以使用数字签名、证书等方法来应对。</p>
<blockquote>
<h3 id="基于口令的密码-PBE"><a href="#基于口令的密码-PBE" class="headerlink" title="基于口令的密码(PBE)"></a>基于口令的密码(PBE)</h3></blockquote>
<p><strong>基于口令的密码</strong>(Password Based Encryption，PBE)就是一种根据口令生成密钥并用该密钥进行加密的方法。</p>
<p>PBE 的加密可以用下图来表示：</p>
<img src="/post/reading/20160722/17-02-17.jpg">

<p>主要有三个步骤：</p>
<ol>
<li><strong>生成 KEK</strong><br>首先，通过伪随机数生成器生成一个被称为<strong>盐</strong>(salt)的随机数。然后，将盐和口令一起输入单向散列函数，输出的结果就是 KEK。盐是一种用于防御字典攻击的机制。</li>
<li><strong>生成会话密钥并加密</strong><br>会话密钥 CEK 也是通过伪随机数生成器来生成，生成之后使用 KEK 对其进行加密，然后将加密后的会话密钥和盐一起保存在安全的地方。</li>
<li><strong>加密消息</strong><br>最后，使用 CEK 对消息进行加密。</li>
</ol>
<p>而 PBE 解密的过程则如下图：</p>
<img src="/post/reading/20160722/17-10-23.jpg">

<p>解密主要也是有三个步骤：</p>
<ol>
<li><strong>重建KEK</strong><br>将之前保存下来的盐和口令一起输入单向散列函数，得到的散列值就是 KEK 了。</li>
<li><strong>解密会话密钥</strong><br>再将之前保存下来的已加密的会话密钥用 KEK 进行解密，就能得到会话密钥 CEK 了。</li>
<li><strong>解密消息</strong><br>最后，用已解密的 CEK 对密文进行解密即可。</li>
</ol>
<p>另外，在生成 KEK 时，通过多次使用单向散列函数可以提高安全性。</p>
<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>有哪些场景使用到随机数呢？主要可能有以下这些：</p>
<ul>
<li><strong>生成密钥</strong></li>
<li><strong>生成密钥对</strong></li>
<li><strong>生成初始化向量(IV)</strong></li>
<li><strong>生成nonce</strong></li>
<li><strong>生成盐</strong></li>
</ul>
<p>随机数的性质主要分为三类：</p>
<ul>
<li><strong>随机性</strong>：不存在统计学偏差，是完全杂乱的数列。</li>
<li><strong>不可预测性</strong>：不能从过去的数列推测出下一个出现的数。</li>
<li><strong>不可重现性</strong>：除非将数列本身保存下来，否则不能重现相同的数列。</li>
</ul>
<p>上面三个性质中，越往下就越严格。具备随机性，不代表一定具备不可预测性。具备不可预测性的数列，则一定具备随机性。具备不可重现性的数列，也一定具备不可预测性和随机性。在书中，将这三个性质的随机数按顺序分别命名为“弱伪随机数”、“强伪随机数”和“真随机数”。</p>
<blockquote>
<h3 id="伪随机数生成器"><a href="#伪随机数生成器" class="headerlink" title="伪随机数生成器"></a>伪随机数生成器</h3></blockquote>
<p>随机数可以通过硬件来生成，也可以通过软件来生成。通过硬件生成的随机数列一般都是真随机数，是从不可重现的物理现象中获取信息而生成数列的，比如周围的温度和声音的变化、用户移动鼠标的位置信息、键盘输入的时间间隔、放射线测量仪的输出值等。像这样的硬件设备称为<strong>随机数生成器</strong>(Random Number Generator，RNG)。而生成随机数的软件则称为<strong>伪随机数生成器</strong>(Pseudo Random Number Generator，PRNG)。因为仅靠软件无法生成真随机数，因为要加上一个“伪”字。</p>
<p>伪随机数生成器具有“内部状态”，并根据外部输入的“种子”来生成伪随机数列，如下图：</p>
<img src="/post/reading/20160722/22-08-13.jpg">

<p>伪随机数生成器的<strong>内部状态</strong>，是指伪随机数生成器所管理的内存中的数值。这个数值在每次生成随机数后都会改变。而<strong>种子</strong>是用来初始化内部状态的。伪随机数生成器是公开的，但种子是需要保密的，这就好像密码算法是公开的，但密钥是保密的。</p>
<blockquote>
<h3 id="具体的伪随机数生成器"><a href="#具体的伪随机数生成器" class="headerlink" title="具体的伪随机数生成器"></a>具体的伪随机数生成器</h3></blockquote>
<p>具体的伪随机数生成器有很多，书中介绍了五种：杂乱的方法、线性同余法、单向散列函数法、密码法、ANSI X9.17。</p>
<ul>
<li><p><strong>杂乱的方法</strong><br>杂乱的方法就是使用杂乱无章的算法来生成随机数，但这种方法其实并不可取。一是因为复杂算法所生成的数列大多数具有很短的周期(即短数列的不断重复)；二是因为如果程序员不能够理解算法的详细内容，那么就无法判断所生成的随机数是否具备不可预测性。</p>
</li>
<li><p><strong>线性同余法</strong><br>线性同余法就是将当前的伪随机数值乘以 A 再加上 C，然后将除以 M 得到的余数作为下一个伪随机数。其中，A、C、M都是常量，且 A 和 C 需要小于 M。C 语言的库函数 rand，以及Java 的 Random 类，都采用了线性同余法。线性同余法并不具备不可预测性，因此不可以用于密码技术。</p>
<img src="/post/reading/20160722/23-08-18.jpg">
</li>
<li><p><strong>单向散列函数法</strong><br>使用单向散列函数可以编写出具备不可预测性的伪随机数列(即强伪随机数)的伪随机数生成器。单向散列函数的单向性是支撑伪随机数生成器不可预测性的基础。</p>
<img src="/post/reading/20160722/23-16-58.jpg">
</li>
<li><p><strong>密码法</strong><br>也可以使用密码来编写能够生成强伪随机数的伪随机数生成器。既可以使用 AES 等对称密码，也可以使用 RSA 等公钥密码。密码的机密性是支撑伪随机数生成器不可预测性的基础。</p>
<img src="/post/reading/20160722/23-21-49.jpg">
</li>
<li><p><strong>ANSI X9.17</strong><br>ANSI X9.17 伪随机数生成器的结构则有点复杂，PGP 密码软件就使用了这种方法。</p>
<img src="/post/reading/20160722/23-26-50.jpg">

</li>
</ul>
<h2 id="PGP"><a href="#PGP" class="headerlink" title="PGP"></a>PGP</h2><p>PGP 将多种密码技术进行了完美的组合，其具备了现代密码软件所必需的几乎全部功能，包括但不限于：对称密码、公钥密码、数字签名、单向散列函数、证书、压缩、大文件的拆分和拼合、钥匙串管理等。</p>
<blockquote>
<h3 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h3></blockquote>
<p>要在 PGP 中进行加密和数字签名，需要先生成自己的密钥对。下图展示了从命令行生成密钥的过程，其中，粗体为用户输入的内容：</p>
<img src="/post/reading/20160722/12-32-19.jpg">

<blockquote>
<h3 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h3></blockquote>
<p>使用 PGP 进行加密的过程如下图所示：</p>
<img src="/post/reading/20160722/12-24-53.jpg">

<p>而解密的过程则如下：</p>
<img src="/post/reading/20160722/12-25-15.jpg">

<p>PGP 的私钥是保存在用户的钥匙串中的。另外，私钥都是以加密状态保存的，并在保存时使用了基于口令的密码(PBE)。</p>
<blockquote>
<h3 id="生成和验证数字签名"><a href="#生成和验证数字签名" class="headerlink" title="生成和验证数字签名"></a>生成和验证数字签名</h3></blockquote>
<p>生成数字签名的过程如下图：</p>
<img src="/post/reading/20160722/12-40-27.jpg">

<p>而验证签名的过程则如下图：</p>
<img src="/post/reading/20160722/12-41-39.jpg">

<blockquote>
<h3 id="生成数字签名并加密以及解密并验证数字签名"><a href="#生成数字签名并加密以及解密并验证数字签名" class="headerlink" title="生成数字签名并加密以及解密并验证数字签名"></a>生成数字签名并加密以及解密并验证数字签名</h3></blockquote>
<p>如何将密码和数字签名进行组合，下面两张图是整本书最复杂的，但它只不过是将之前讲解的内容组合起来了而已。<br>下图是生成数字签名并加密的过程：</p>
<img src="/post/reading/20160722/12-44-34.jpg">

<p>而下图则是解密并验证数字签名的过程：</p>
<img src="/post/reading/20160722/12-45-00.jpg">

<blockquote>
<h3 id="信任网"><a href="#信任网" class="headerlink" title="信任网"></a>信任网</h3></blockquote>
<p>如何确认公钥的合法性？前面介绍的证书是一种方法。对公钥的信任是建立在对认证机构的信任的基础之上的。不过，PGP 却没有使用认证机构，而是采用了一种叫做<strong>信任网</strong>(也称为<strong>信任圈</strong>或<strong>好友圈</strong>)的方法。信任网的要点是“不依赖认证机构，而是建立每个人之间的信任关系”。换言之，就是能够自己决定要信任哪些公钥。</p>
<p>PGP 当初的设计目的是在连国家都不可信的情况下依然能够使用，因此它并不关心有没有可信的认证机构，而是采用了“由用户自己来决定信任谁”这样的设计。</p>
<p>需要注意，“公钥是否合法”与“所有者是否可信”是两个不同的问题，因为尽管公钥合法，其所有者也可以是不可信的。例如，Alice认为从Bob那获得的公钥是合法的，因为这个公钥是Bob当面交给Alice的。但是Alice不信任Bob在数字签名上的判断能力，即便Bob对其他的公钥进行了数字签名，Alice也会怀疑Bob是否真的进行了本人确认。</p>
<p>在 PGP 中，信任级别可以分为四种：绝对信任、完全信任、有限信任和不信任。</p>
<h2 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h2><p>SSL/TLS也是综合运用了对称密码、公钥密码、消息认证码、数字签名、伪随机数生成器等密码技术。而我们知道SSL/TLS最广泛的应用就是套接在HTTP上，但实际上，SSL/TLS还可以套接在其他网络协议之上的，例如，SMTP 和 POP3 之类的电子邮件协议。因为现在广泛使用的是TLS协议，因此下文只以TLS协议为主。</p>
<p>TLS安全协议可分为两层：<strong>TLS记录协议</strong>和 <strong>TLS握手协议</strong>。TLS记录协议在TLS握手协议的下层，负责数据封装、压缩、加密等功能。而TLS握手协议则用于在实际的数据传输开始前，通信双方进行身份认证、协商加密算法、交换密钥等。TLS握手协议又分为4个子协议：握手协议、密码规格变更协议、警告协议和应用数据协议。TLS协议的层次结构如下图：</p>
<img src="/post/reading/20160722/14-06-27.jpg">

<blockquote>
<h3 id="TLS记录协议"><a href="#TLS记录协议" class="headerlink" title="TLS记录协议"></a>TLS记录协议</h3></blockquote>
<p>TLS记录协议的处理过程如下图：</p>
<img src="/post/reading/20160722/12-43-27.jpg">

<p>首先，消息被分割成多个片段，然后分别对每个片段进行压缩。压缩算法需要与通信对象协商决定。接下来，经过压缩的片段会被加上消息认证码，这就可以保证完整性，并进行数据的认证。同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编号。单向散列函数的算法，以及消息认证码所使用的密钥都需要与通信对象协商决定。再接下来，就是加密了。加密使用CBC模式，CBC模式的初始化向量(IV)通过主密码生成，而对称密码的算法和共享密钥也是需要与通信对象协商决定。最后，密文再加上数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。其中，数据类型为TLS握手协议中的4个子协议之一。</p>
<blockquote>
<h3 id="TLS握手协议"><a href="#TLS握手协议" class="headerlink" title="TLS握手协议"></a>TLS握手协议</h3></blockquote>
<p>TLS握手协议可分为4个子协议，其中，<strong>握手协议</strong>是最复杂的一个子协议，其过程如下图：</p>
<img src="/post/reading/20160722/12-58-28.jpg">

<p><strong>1. ClientHello(客户端-&gt;服务器)</strong><br>客户端向服务器发送ClientHello消息，消息内容主要包括：可用的版本号、当前时间、客户端随机数、会话ID、可用的密码套件清单、可用的压缩方式清单。<br><strong>2. ServerHello(服务器-&gt;客户端)</strong><br>对于客户端发送的ClientHello消息，服务器会返回一个ServerHello消息，消息内容主要包括：使用的版本号、当前时间、服务器随机数、会话ID、使用的密码套件、使用的压缩方式。这一步确定了通信中使用的“版本号”、“密码套件”和“压缩方式”。<br><strong>3. Certificate(服务器-&gt;客户端)</strong><br>服务器再向客户端发送Certificate消息，主要是<strong>证书清单</strong>。首先发送的是服务器的证书，然后会按顺序发送对服务器证书签名的认证机构的证书。<br><strong>4. ServerKeyExchange(服务器-&gt;客户端)</strong><br>当Certificate消息不足以满足需求时，服务器会向客户端发送ServerKeyExchange消息。具体所发送的消息内容会根据所使用的密码套件而有所不同。<br><strong>5. CertificateRequest(服务器-&gt;客户端)</strong><br>CertificateRequest消息用于服务器向客户端请求证书，这是为了进行<strong>客户端认证</strong>。消息内容还包括：服务器能够理解的证书类型清单和认证机构名称清单。当不使用客户端认证时，不会发送CertificateRequest消息。<br><strong>6. ServerHelloDone(服务器-&gt;客户端)</strong><br>服务器发送ServerHelloDone消息则表示从ServerHello消息开始的一系列消息的结束。<br><strong>7. Certificate(客户端-&gt;服务器)</strong><br>当服务器发送了CertificateRequest消息时，则客户端会发送Certificate消息，将自己的证书同消息一起发送给服务器。如果服务器没有发送CertificateRequest消息，客户端则不会发送Certificate消息。<br><strong>8. ClientKeyExchange(客户端-&gt;服务器)</strong><br>客户端发送ClientKeyExchange消息。当密码套件中包含RSA时，会随消息一起发送<strong>经过加密的预备主密码</strong>。当密码套件中包含Diffie-Hellman密钥交换时，会随消息一起发送<strong>Diffie-Hellman的公开值</strong>。预备主密码是由客户端生成的随机数，之后会被用作生成主密码的种子。根据预备主密码，服务器和客户端会计算出相同的<strong>主密码</strong>，然后再根据主密码生成：对称密码的密钥、消息认证码的密钥、对称密码的CBC模式中使用的初始化向量(IV)。<br><strong>9. CertificateVerify(客户端-&gt;服务器)</strong><br>客户端只有在服务器发送CertificateRequest消息时才会发送CertificateVerify消息。这个消息的目的是向服务器证明自己的确持有客户端证书的私钥。为了实现这一目的，客户端会计算“主密码”和“握手协议中传送的消息”的散列值，并加上自己的数字签名后发送给服务器。<br><strong>10. ChangeCipherSpec(客户端-&gt;服务器)</strong><br>客户端发送ChangeCipherSpec消息表示要切换密码。实际上，这不是握手协议的消息，而是密码规格变更协议的消息。在ChangeCipherSpec消息之前，客户端和服务器之间以及交换了所有关于密码套件的信息，因此在收到这一消息时，客户端和服务器会同时切换密码。在这一消息之后，TLS记录协议就开始使用双方协商决定的密码通信方式了。<br><strong>11. Finished(客户端-&gt;服务器)</strong><br>客户端发送Finished消息表示握手协议到此结束。这个消息其实是使用切换后的密码套件来发送的。实际负责加密操作的是TLS记录协议。<br><strong>12. ChangeCipherSpec(服务器-&gt;客户端)</strong><br>这次轮到服务器发送ChangeCipherSpec消息了，表明服务器要切换密码了。<br><strong>13. Finished(服务器-&gt;客户端)</strong><br>服务器也同样发送Finished消息表明握手协议到此结束。这个消息同样使用切换后的密码套件来发送。实际负责加密操作的也是TLS记录协议。<br><strong>14. 切换至应用数据协议</strong><br>在此之后，客户端和服务器会使用应用数据协议和TLS记录协议进行密码通信。</p>
<p>从结果来看，握手协议完成了下列操作：</p>
<ul>
<li>客户端获得了服务器的合法公钥，完成了服务器认证。</li>
<li>服务器获得了客户端的合法公钥，完成了客户端认证(当需要客户端认证时)。</li>
<li>客户端和服务器生成了密码通信中使用的共享密钥。</li>
<li>客户端和服务器生成了消息认证码中使用的共享密钥。</li>
</ul>
<p>除了握手协议，其他3个子协议都很简单。<strong>密码规格变更协议</strong>用于密码切换的同步。简单地说，就跟向对方喊“1、2、3！”差不多。当协议中途发生错误时，就会通过警告协议传达给对方。<strong>警告协议</strong>负责在发生错误时将错误传达给对方。如果没有发生错误，则会使用应用数据协议来进行通信。<strong>应用数据协议</strong>用于和通信对象之间传送应用数据。当TLS套接在HTTP时，HTTP的请求和相应就会通过TLS的应用数据协议和TLS记录协议来进行传送。</p>
<h2 id="密码技术与现实社会"><a href="#密码技术与现实社会" class="headerlink" title="密码技术与现实社会"></a>密码技术与现实社会</h2><p>前面讲到的6种基本的密码技术可整理成下图：</p>
<img src="/post/reading/20160722/14-01-39.jpg">

<p>书中多次使用了<strong>框架</strong>这个说法。框架的特点就是能够对其中作为组成元素的技术进行替换，就像更好零件一样。例如，消息认证码算法HMAC的设计就允许对单向散列函数的算法进行替换。在PGP中，对称密码、公钥密码、单向散列函数等都是可以替换的。在SSL/TLS中，客户端和服务器可以通过握手协议进行通信，并当场决定所使用的密码套件。使用框架能够提高密码技术系统的重用性，也能够提高系统的强度。通过将单独的密码技术像零件一样组合起来，并根据需要进行替换，能够实现更长期的、更高的安全性。</p>
<p>另外，所有密码技术其实也可以看成是一种“压缩技术”，如下表所示：</p>
<img src="/post/reading/20160722/14-16-59.jpg">

<blockquote>
<h3 id="量子密码和量子计算机"><a href="#量子密码和量子计算机" class="headerlink" title="量子密码和量子计算机"></a>量子密码和量子计算机</h3></blockquote>
<p><strong>量子密码</strong>是基于量子理论的通信技术，是一种让通信本身不可窃听的技术，也可以理解为是一种利用光子的量子特性来实现通信的方法。最早的量子密码中，利用了两个事实：<br><strong>1. 从原理上说，无法准确测出光子的偏振方向</strong><br>根据这一事实，可以让窃听者得到的内容变得不正确。<br><strong>2. 测量行为本身会导致光子的状态发送改变</strong><br>根据这一事实，接收者可以判断出通信是否被窃听。</p>
<p>而<strong>量子计算机</strong>则有着超强的计算能力。如果有了量子计算机，那现有的所有密码都能够瞬间被暴力破解。根据量子理论，粒子可同时具有多种状态。如果使用具有多种状态的粒子进行计算，则可以同时完成多种状态的计算。如果用1个粒子能够计算0和1两种状态，那么用128个这样的粒子就可以同时计算2^128中状态。换句话说，就是一台超级并行计算机。</p>
<p>如果量子密码比量子计算机先进入实用领域，则可以使用量子密码来实现一次性密码本，从而产生完美的密码技术。由于一次性密码本在原理上是无法破译的，因此即使用量子计算机也无法破译量子密码。然而，如果量子计算机比量子密码先进入实用领域，则实用目前的密码技术所产生的密文将会全部被破译。</p>
<blockquote>
<h3 id="只有完美的密码，没有完美的人"><a href="#只有完美的密码，没有完美的人" class="headerlink" title="只有完美的密码，没有完美的人"></a>只有完美的密码，没有完美的人</h3></blockquote>
<p>就算量子密码进入实用领域，也不能实现完美的安全。因为在安全问题中，密码技术能够覆盖的范围是非常有限的。在确保系统的整体安全方面，人是一个特别巨大的弱点。</p>
<p>为了配送对称密码的密钥，我们需要使用公钥密码，而为了对公钥进行认证，我们又需要认证机构的公钥。以此类推，无穷无尽，我们必须在某个节点上找到一个公钥是自己能够完全信任的，也就是必须要有一个信任的种子。</p>
<p>通过密码技术，我们可以提高机密性，也能够让认证变得更加容易，但是这并不意味着我们可以实现完美的机密性和完美的认证。</p>
<p>就算通过人的指纹、声纹、面容识别等生物识别认证也并不是完美的认证。要进行生物识别认证，就必须在某个时间点上将生物信息转换为比特序列，而实际的认证则是通过转换后的比特序列来完成的。因此，如果这些比特序列被窃取，就会和钥匙被偷产生相同的后果。</p>
<p>另外，“防御必须天衣无缝，攻击只需突破一点”。为了保卫系统安全，我们必须应对各种可能的攻击，而且这种防御必须24小时连续工作。另一方面，要攻击一个系统，则只要找到一种有效的攻击方法，而且只需利用防御方一瞬间的破绽就可以完成了。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>其实，在实际应用中，安全问题所涉及的技术，远比这本书里所讲到的密码技术多得多，也复杂得多。例如，App的加壳保护、OAuth认证等。在实际的应用中，还需要考虑更多，比如，安全性和性能之间需要平衡。虽然，懂得了这些密码技术，并不意味着就能设计出非常安全的系统。但是，如果不懂这些密码技术，那就更难以设计出安全的系统。</p>
<hr>
<p>扫描以下二维码即可关注订阅号。</p>
<img src="/post/reading/20160722/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/reading/20160705/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/reading/20160705/" class="post-title-link" itemprop="url">读《图解密码技术》(二):认证</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-07-05 13:30:00" itemprop="dateCreated datePublished" datetime="2016-07-05T13:30:00+08:00">2016-07-05</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-02 11:59:22" itemprop="dateModified" datetime="2019-07-02T11:59:22+08:00">2019-07-02</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/reading/" itemprop="url" rel="index"><span itemprop="name">reading</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/reading/20160705"><strong>http://keeganlee.me/post/reading/20160705</strong></a><br>微信订阅号：<strong>keeganlee_me</strong><br>写于2016-07-05</p>
<hr>
<p><a href="http://keeganlee.me/post/reading/20160629">读《图解密码技术》(一):密码</a><br><a href="http://keeganlee.me/post/reading/20160705">读《图解密码技术》(二):认证</a><br><a href="http://keeganlee.me/post/reading/20160722">读《图解密码技术》(三):密钥、随机数和应用技术</a></p>
<hr>
<p><a href="http://keeganlee.me/post/reading/20160629">前一篇文章</a>总结了密码部分的内容，包括一次性密码本、对称密码、公钥密码、混合密码系统等。这些密码在一定程度上能够保证消息的机密性，即可以防止被窃听导致秘密泄露。但却无法防御信息被篡改，也无法确定消息的来源是否就是真实的发送者而不是来自伪装者，也防止不了发送者事后否认自己先前做过的行为。关于这些问题，在本文总结的密码技术中就可以找到解决方案。</p>
<p>本文是关于《图解密码技术》第二部分的内容总结，包括单向散列函数、消息认证码、数字签名、证书。</p>
<h2 id="单向散列函数"><a href="#单向散列函数" class="headerlink" title="单向散列函数"></a>单向散列函数</h2><p>使用单向散列函数可以获取消息的“指纹”，通过对比“指纹”，就能够知道两条消息是否一致。这种一致性，也称为完整性，可以识别出消息是否被篡改。</p>
<p><strong>单向散列函数</strong>(one-way hash function)有一个输入和一个输出，其中输入称为<strong>消息</strong>(message)，输出称为<strong>散列值</strong>(hash value)。散列值也称为<strong>消息摘要</strong>(message digest)或者<strong>指纹</strong>(fingerprint)。单向散列函数可以根据消息的内容计算出散列值，而散列值就可以用来检查消息的完整性。</p>
<blockquote>
<h3 id="单向散列函数的性质"><a href="#单向散列函数的性质" class="headerlink" title="单向散列函数的性质"></a>单向散列函数的性质</h3></blockquote>
<ul>
<li><strong>根据任意长度的消息计算出固定长度的散列值</strong><br>首先，单向散列函数的输入必须能够是任意长度的消息。其次，无论输入多长的消息，必须都能够生成很短的散列值。如果消息越长生成的散列值也越长的话就不好用了，而且为了方便使用，散列值的长度最好是短且固定的。不管消息是1比特，还是100M，甚至是100G，单向散列函数都会计算出固定长度的散列值。比如，SHA-1计算出的散列值固定为160比特（20字节）。</li>
<li><strong>能够快速计算出散列值</strong><br>计算散列值所花费的时间必须要短。尽管消息越长，计算散列值的时间也会越长，但如果不能在现实的时间内完成计算就没有意义了。</li>
<li><strong>具备单向性</strong><br>单向散列函数必须具备单向性。单向性是指无法通过散列值反算出消息的性质。就如同将玻璃砸得粉碎很容易，但却无法将碎片还原成完整的玻璃一样，根据消息计算出散列值很容易，但根据散列值却无法反算出消息。</li>
<li><strong>消息不同散列值也不同</strong><br>为了能够确认完整性，消息中哪怕只有 1 比特的改变，也必须有很高的概率产生不同的散列值。为什么说有很高的概率呢？这是因为消息很长，而散列值很短，那就肯定会存在不同消息产生相同散列值的情况，这种情况称为<strong>碰撞</strong>(collision)。因此，单向散列函数没法完全避免碰撞，只能减低碰撞发生的概率。而且，更重要的是，要避免被人为地发现碰撞。难以发现碰撞的性质称为<strong>抗碰撞性</strong>(collision resistance)。单向散列函数必须具备抗碰撞性。另外，抗碰撞性还分为两种：弱抗碰撞性和强抗碰撞性。<strong>弱抗碰撞性</strong>是指要找到和给定的消息具有相同散列值的另外一条消息是非常困难的。<strong>强抗碰撞性</strong>则是指要找到散列值相同的两条不同的消息是非常困难的。单向散列函数必须既具备弱抗碰撞性，也必须具备强抗碰撞性。</li>
</ul>
<blockquote>
<h3 id="单向散列函数的例子"><a href="#单向散列函数的例子" class="headerlink" title="单向散列函数的例子"></a>单向散列函数的例子</h3></blockquote>
<p>单向散列函数有很多种，MD4、MD5、SHA-1、SHA-256、SHA-384、SHA-512、SHA-3等等。</p>
<p>MD4是由Rivest于1990年设计的，MD是消息摘要(message digest)的缩写，两者都能够产生128比特的散列值。不过，第二年，即1991年，就已经有人提出了MD4的漏洞，很容易就寻找到了MD4散列碰撞的方法。因此，Rivest又设计了更为成熟的MD5。MD5到现在依然有着广泛的应用，例如很多网站和应用的登录密码都使用了MD5。但MD5的强抗碰撞性已经被攻破，也就是说，现在已经能够产生具备相同散列值的两条不同的消息。所以，其实MD5已经不安全了。</p>
<p>SHA是NSA(美国国家安全局)设计，NIST(美国国家标准与技术研究院)发布的一系列单向散列函数。SHA是以MD4和MD5类似的原理为基础来设计的。SHA-1能够产生160比特的散列值，不过消息长度是有上限的，上限为2^64比特(准备地说是2^64-1)。当然这个数已经非常巨大，所以在实际应用中没有问题。不过，SHA-1的强抗碰撞性已于2005年被攻破。所以，SHA-1也和MD5一样没那么安全了。不过，貌似SHA-1依然是目前使用最广泛的单向散列函数。</p>
<p>SHA-256、SHA-384和SHA-512的散列值长度分别为256比特、384比特和512比特。它们的消息长度也存在上限，SHA-256的上限和SHA-1一样，而SHA-384和SHA-512的消息上限则为2^128比特(确切值为2^128-1)。这些单向散列函数合起来称为SHA-2。目前，SHA-2还没有被攻破。</p>
<p>在2005年SHA-1被攻破的背景下，促进了SHA-3的产生。SHA-3与AES一样采用了公开竞赛的方式进行标准化，最后胜出的是Keccak算法。</p>
<blockquote>
<h3 id="单向散列函数SHA-1"><a href="#单向散列函数SHA-1" class="headerlink" title="单向散列函数SHA-1"></a>单向散列函数SHA-1</h3></blockquote>
<p>SHA-1作为一个具有代表性的单向散列函数，让我们看看它的算法流程是怎样的。整体流程如下图：</p>
<img src="/post/reading/20160705/17-51-46.jpg">

<p>可以分为四个步骤：</p>
<ol>
<li><p><strong>填充</strong><br>对消息进行填充处理，使其长度为512比特的整数。这里的512比特称为一个输入分组。具体填充的步骤也分为三步：第一步在消息末尾添加一个1比特的数值“1”；第二步在添加了“1”之后的消息末尾不断添加0，直到消息的长度达到512比特的整数倍，但最后一个分组的最后64比特需要空出来；第三步将消息的长度换成二进制后添加到上一步空出来的最后一个分组的最后64比特中。</p>
</li>
<li><p><strong>计算 W0 ~ W79</strong><br>对每一个输入分组分别计算80个32比特的值，这80个值将用于“单步处理“中。计算流程如下图：</p>
<img src="/post/reading/20160705/21-27-07.jpg">

</li>
</ol>
<p>首先，将输入分组的512比特分成16组，每组32比特。然后，剩下的 W16 ~ W79 使用如下的公式进行计算：</p>
<img src="/post/reading/20160705/21-30-51.jpg">

<ol start="3">
<li><strong>分组处理</strong><br>接下来，对输入分组进行80个步骤的处理，目的是根据输入分组的信息来改变内部状态。流程如下图，其中，160比特的内部状态是通过名为A~E的5个32比特的缓冲区来表示的：<img src="/post/reading/20160705/21-39-08.jpg">

</li>
</ol>
<p>将5个缓冲区的值与输入分组的信息进行混合，然后再执行80个步骤的处理。从结果来看，这80个步骤所完成的操作，就是将输入分组的512比特的数据，也SHA-1所保持的160比特的内部状态(5个缓冲区)进行混合。通过80个步骤的反复执行，SHA-1就能够将已经过填充的消息全部混入这160比特的内部状态中，而SHA-1所输出的散列值，就是所有处理结束之后最终的内部状态(160比特)。</p>
<ol start="4">
<li><strong>单步处理</strong><br>单步处理是指上面的80个步骤中的每一步的处理，处理过程如下图：<img src="/post/reading/20160705/21-55-03.jpg">

</li>
</ol>
<p>在一个步骤完成之后，缓冲区A、B、C、D的内容会被分别复制到B、C、D、E中(其中B要循环左移30比特之后再复制)，而缓冲区 E 的内容则会与其他缓冲区的内容以及Wt、Kt相加之后再被复制到缓冲区A中。<br>由于上述处理要循环80个步骤，因此输入分组中 1 比特的变化，就会影响到散列值中几乎所有的比特，通过这样的方式，就能够实现单向散列函数所应具备的性质。</p>
<blockquote>
<h3 id="对单向散列函数的攻击"><a href="#对单向散列函数的攻击" class="headerlink" title="对单向散列函数的攻击"></a>对单向散列函数的攻击</h3></blockquote>
<p>对单向散列函数的攻击主要就是对单向散列函数的”抗碰撞性“的攻击。</p>
<p>对“弱抗碰撞性”的攻击主要是利用消息的冗余性生成具有相同散列值的另一个消息，这种攻击也是<strong>暴力破解</strong>，每次都稍微改变一下消息的值，然后对这些消息求散列值。在这种情况下，暴力破解需要尝试的次数可以根据散列值的长度计算出来。以SHA-1为例，由于它的散列值长度为160比特，因此最多只要尝试2^160次就能够找到目标消息。由于尝试次数纯粹是由散列值长度决定的，因此散列值长度越长的单向散列函数，其抵御暴力破解的能力也就越强。</p>
<p>对“强抗碰撞性”的攻击一般称为<strong>生日攻击</strong>。生日攻击不是寻找生成特定散列值的消息，而是要找到相同散列值的两条消息，而散列值则可以是任何值。生日攻击的原理来自生日悖论，也就是利用了“任意散列值一致的概率比想象中高”这样的特性。相对于暴力破解，生日攻击所需尝试的次数要少得多，一般只需要是暴力破解的一半。</p>
<blockquote>
<h3 id="单向散列函数无法解决的问题"><a href="#单向散列函数无法解决的问题" class="headerlink" title="单向散列函数无法解决的问题"></a>单向散列函数无法解决的问题</h3></blockquote>
<p>单向散列函数可以实现完整性的检查，但却识别不了“伪装”，即无法解决认证问题。认证问题需要使用消息认证码和数字签名来解决。</p>
<p>单向散列函数在实际应用中很少单独使用，而是和其他密码技术结合使用。后面要讲的消息认证码和数字签名都使用了单向散列函数，而下一篇要讲的密钥、伪随机数和应用技术也都使用了单向散列函数。</p>
<h2 id="消息认证码"><a href="#消息认证码" class="headerlink" title="消息认证码"></a>消息认证码</h2><p><strong>消息认证码</strong>(message authentication code)是一种确认完整性并进行认证的技术，简称为 <strong>MAC</strong>。消息认证码的输入包括任意长度的<strong>消息</strong>和一个发送者与接受者之间<strong>共享的密钥</strong>，它可以输出固定长度的数据，这个数据称为 <strong>MAC 值</strong>。</p>
<p>消息认证码与单向散列函数很类似，都是根据任意长度的消息输出固定长度的数据，不同的是，消息认证码比单向散列函数多了一个共享密钥。没有共享密钥的人就无法计算出 MAC 值，消息认证码正是利用这一性质来完成认证的。此外，和单向散列函数一样，哪怕消息中发生 1 比特的变化，MAC 值也会发生变化，消息认证码正是利用这一性质来确认完整性的。</p>
<blockquote>
<h3 id="消息认证码的使用步骤"><a href="#消息认证码的使用步骤" class="headerlink" title="消息认证码的使用步骤"></a>消息认证码的使用步骤</h3></blockquote>
<p>消息认证码的使用步骤如下图：</p>
<img src="/post/reading/20160705/23-48-57.jpg">

<p>发送者与接收者需要事先共享密钥，然后发送者使用共享密钥对消息计算 MAC 值，接着将消息和 MAC值一起发送给接收者。接收者收到消息和 MAC 值后，使用同一个共享密钥对消息计算 MAC 值，当计算出来的 MAC 值和接收到的 MAC 值一致的，就证明认证成功了。</p>
<p>而既然是使用共享密钥，那就和对称密码一样，存在密钥配送问题。要解决密钥配送问题，同样可以使用事先共享密钥、密钥配送中心、Diffie-Hellman密钥交换、公钥密码等方法。具体请看<a href="http://keeganlee.me/post/reading/20160629">前一篇</a>文章的<strong>密钥配送问题</strong>部分。</p>
<blockquote>
<h3 id="消息认证码的实现"><a href="#消息认证码的实现" class="headerlink" title="消息认证码的实现"></a>消息认证码的实现</h3></blockquote>
<p>消息认证码有很多种实现方法。可以使用SHA-1、MD5之类的<strong>单向散列函数</strong>来实现，其中有一种实现方法叫 <strong>HMAC</strong>，后面我们再讲它实现的具体步骤。</p>
<p>也可以使用DES、AES之类的<strong>分组密码</strong>来实现消息认证码，将分组密码的密钥作为消息认证码的共享密钥来使用，并用 CBC 模式将消息全部加密。由于消息认证码不需要解密，因此，可以只保留最后一个分组的密文作为 MAC 值，而其他密文则全部丢弃。由于 CBC 模式的最后一个分组会收到整个消息以及密钥的双重影响，因此可以将它用作消息认证码。</p>
<p>此外，使用流密码和公钥密码等也可以实现消息认证码。</p>
<blockquote>
<h3 id="HMAC"><a href="#HMAC" class="headerlink" title="HMAC"></a>HMAC</h3></blockquote>
<p><strong>HMAC</strong> 是一种使用单向散列函数来构造消息认证码的方法，其中，HMAC 中的 H 就是 Hash 的意思。HMAC 中所使用的单向散列函数并不仅限于一种，任何高强度的单向散列函数都可以被用于 HMAC，也就是说，HMAC 所使用的单向散列函数是可以被替换的。</p>
<p>HMAC 是按照下列步骤来计算 MAC 值的：</p>
<img src="/post/reading/20160705/18-16-52.jpg">

<ol>
<li>密钥填充<br>如果密钥比单向散列函数的分组长度要短，就需要在末尾填充0，直到其长度达到单向散列函数的分组长度为止。如果密钥比分组长度要长，则要用单向散列函数求出密钥的散列值，然后将这个散列值用作 HMAC 的密钥。</li>
<li>填充后的密钥与 ipad 的 XOR<br>将填充后的密钥与被称为 ipad 的比特序列进行 XOR 运算。<strong>ipad</strong> 是将 00110110 这一比特序列(即16进制的36）不断循环反复直到达到分组长度所形成的比特序列，其中 ipad 的 i 是 inner 的意思。XOR 运算后得到的值，就是一个和单向散列函数分组长度相同，且和密钥相关的比特序列。这里将这个比特序列称为 <strong>ipadkey</strong>。</li>
<li>与消息组合<br>随后，将 ipadkey 与消息进行组合，ipadkey 一般附加在消息开头。</li>
<li>计算散列值<br>将上一步组合的结果输入单向散列函数，计算出散列值。</li>
<li>填充后的密钥与 opad 的 XOR<br>将填充后的密钥与被称为 opad 的比特序列进行 XOR 运算。<strong>opad</strong> 是将 01011100 这一比特序列(即16进制的5C）不断循环反复直到达到分组长度所形成的比特序列，其中 opad 的 o 是 outer 的意思。XOR 运算后得到的值，也是一个和单向散列函数分组长度相同，且和密钥相关的比特序列。这里将这个比特序列称为 <strong>opadkey</strong>。 </li>
<li>与散列值组合<br>将第4步计算出来的散列值拼在 opadkey 的后面。</li>
<li>计算散列值<br>将上一步的结果输入单向散列函数，计算出散列值。这个散列值就是 MAC 值。</li>
</ol>
<blockquote>
<h3 id="对消息认证码的攻击"><a href="#对消息认证码的攻击" class="headerlink" title="对消息认证码的攻击"></a>对消息认证码的攻击</h3></blockquote>
<p>对消息认证码可以发起<strong>重放攻击</strong>，即攻击者可以通过将事先拦截保存的正确 MAC 值不断重放来发动攻击。有几种方法可以防御重放攻击：</p>
<ul>
<li>序号<br>每次发送消息时都赋予一个递增的序号，并在计算 MAC 值时将序号也包含在消息中。这样，由于攻击者无法计算序号递增之后的 MAC 值，因此就可以防御重放攻击。这种方法虽然有效，但对每个通信对象都需要记录最后一个消息的序号。</li>
<li>时间戳<br>发送消息时可以包含进当前时间，如果收到以前的消息，即便 MAC 值正确也将其视为错误的消息来处理，这样就可以防御重放攻击。这种方法虽然也有效，但发送者与接收者的时钟必须一致，而且考虑到通信的延迟，必须在时间的判断上留下缓冲，于是多多少少还是会存在可以进行重放攻击的。</li>
<li>nonce<br>在通信之前，接收者先向发送者发送一个一次性的随机数，这个随机数一般称为 <strong>nonce</strong>。发送者在消息中包含这个 nonce 并计算 MAC 值。由于每次通信时 nonce 的值都会发生变化，因此无法进行重放攻击。这种方法虽然有效，但通信的数据量会有所增加。</li>
</ul>
<p>另外，除了重放攻击，对消息认证码也可以进行暴力破解和生日攻击，这和对单向散列函数的攻击一样。对消息认证码来说，应保证不能根据 MAC 值推测出通信双方所使用的密钥。例如 HMAC 就是利用单向散列函数的单向性和抗碰撞性来保证无法根据 MAC 值推测出密钥的。</p>
<blockquote>
<h3 id="消息认证码无法解决的问题"><a href="#消息认证码无法解决的问题" class="headerlink" title="消息认证码无法解决的问题"></a>消息认证码无法解决的问题</h3></blockquote>
<p>使用消息认证码可以对消息进行认证并确认完整性，即能够识别出消息的篡改和伪装。但却解决不了“对第三方证明”和“防止否认”。</p>
<p>假如接收者在收到发送者的消息之后，想要向第三方证明这条消息的确是发送者发送的，但是用消息认证码无法进行这样的证明，为什么呢？首先，第三方要校验 MAC 值，就需要知道发送者与接收者之间共享的密钥。但知道密钥后，也校验出 MAC 值是正确的，依然无法证明消息就是发送者发的，因为也有可能是接收者发的。</p>
<p>既然第三方无法做出证明，那么，如果发送者事后否认自己发送过消息，而谎称是接收者自己发送给自己的消息，对于这种情况也是无法证明，即无法防止否认。</p>
<p>后面要讲的数字签名就可以解决这两个问题。</p>
<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>消息认证码之所以无法对第三方证明和防止否认，就是因为发送者和接收者使用了同一个共享密钥。那么，如果发送者和接收者不使用共享密钥，而各自使用不同密钥呢？假如发送者使用的密钥是一个只有自己知道的私钥，在这里可称为“签名密钥”，当发送者发送消息时，用她的签名密钥生成一个“签名”。相对地，接收者使用另一个密钥，称为“验证密钥”，可对签名进行验证。但是，使用验证密钥是无法生成签名的。也就是说，只有签名密钥可以生成签名，而用相应的验证密钥可以对该签名进行验证。这种技术就是<strong>数字签名</strong>(digital signature)，也称为<strong>电子签名</strong>，或简称为<strong>签名</strong>。另外，签名密钥只能由签名的人持有，而验证密钥则是任何需要验证签名的人都可以持有。</p>
<p>上面讲的内容，和公钥密码很像吧？其实，数字签名就是通过将公钥密码反过来用而实现的。</p>
<blockquote>
<h3 id="公钥密码与数字签名"><a href="#公钥密码与数字签名" class="headerlink" title="公钥密码与数字签名"></a>公钥密码与数字签名</h3></blockquote>
<p>下图是使用公钥加密(即公钥密码)的简单流程图：</p>
<img src="/post/reading/20160705/22-31-41.jpg">
<p>而下图则是使用私钥加密(即数字签名)的简单流程图：</p>
<img src="/post/reading/20160705/22-29-08.jpg">

<p>那么，为什么用私钥加密就相当于生成签名，而用公钥解密就相当于验证签名呢？这是因为组成密钥对的两个密钥之间存在严密的数学关系，使用公钥加密的密文，只能用与该公钥配对的私钥才能解密；同样地，使用私钥加密的密文，也只能用与该私钥配对的公钥才能解密。也就是说，如果用某个公钥成功解密了密文，那么就能够证明这段密文是用与该公钥配对的私钥进行加密所得到的。用私钥进行加密这一行为只能由持有私钥的人完成，正是基于这一事实，才可以将用私钥加密的密文作为签名来对待。而由于公钥是对外公开的，因此任何人都可以用公钥进行解密，即任何人都能够对签名进行验证。</p>
<blockquote>
<h3 id="数字签名的方法"><a href="#数字签名的方法" class="headerlink" title="数字签名的方法"></a>数字签名的方法</h3></blockquote>
<p>有两种生成和验证数字签名的方法：</p>
<ul>
<li><strong>直接对消息签名的方法</strong><br>直接对消息签名的方法很容易理解，但实际上很少使用。签名和验证的过程如下图：<img src="/post/reading/20160705/12-28-14.jpg">

</li>
</ul>
<p>我们知道，公钥密码算法本来就非常慢。用这种方法需要对整个消息进行加密，就会非常耗时。因此，在实际应用中，基本不会使用直接对消息签名的方法。</p>
<ul>
<li><strong>对消息的散列值签名的方法</strong><br>对消息先使用单向散列函数计算出散列值，再对散列值进行签名，这种方法的过程如下图：<img src="/post/reading/20160705/12-34-17.jpg">

</li>
</ul>
<p>因为散列值比较短，因此对其进行加密签名就会快很多。</p>
<blockquote>
<h3 id="数字签名的实现"><a href="#数字签名的实现" class="headerlink" title="数字签名的实现"></a>数字签名的实现</h3></blockquote>
<p>数字签名的实现也有很多种，基本也是使用单向散列函数和公钥密码技术相结合。而公钥密码部分常用的就是使用RSA，另外也有使用EIGamal、Rabin。还有一种数字签名算法叫DSA(Digital Signature Algorithm)。而使用最广泛的应该就是使用RSA的数字签名了。</p>
<p>使用RSA实现数字签名很简单。而为了更加简单起见，这里不使用单向散列函数，而是直接对消息进行签名。首先，需要将文本的消息先编码为数字，因为在RSA中，被签名的消息、密钥以及最终生成的签名都是以数字形式表示的。接着，使用下列公式生成签名：</p>
<ul>
<li>签名 = 消息^D mod N  (用RSA生成签名)</li>
</ul>
<p>D 和 N 就是签名者的私钥。生成签名后，发送者就可以将消息和签名一起发送给接收者了。</p>
<p>而验证签名时则使用下列公式：</p>
<ul>
<li>由签名求得的消息 = 签名^E mod N  (用RSA验证签名)</li>
</ul>
<p>E 和 N 就是签名者的公钥。接收者计算出“由签名求得的消息”后，与发送者直接发送过来的“消息”内容进行对比(如果使用了单向散列函数那就是对比消息的散列值)。如果两者一致则签名验证成功，否则签名验证失败。</p>
<blockquote>
<h3 id="对数字签名的攻击"><a href="#对数字签名的攻击" class="headerlink" title="对数字签名的攻击"></a>对数字签名的攻击</h3></blockquote>
<p>因为数字签名结合了单向散列函数和公钥密码，因此，对单向散列函数和公钥密码的攻击也同样对数字签名有效。比如，针对公钥密码的中间人攻击对数字签名来说就颇具威胁。要防止中间人攻击，就需要确认自己所得到的公钥是否真的属于自己的通信对象。而解决此问题的方案也和公钥密码一样，一般可以使用公钥证书。</p>
<p>对单向散列函数的攻击也是对“抗碰撞性”的攻击，使用高强度的单向散列函数就可以增大被破解的难度。</p>
<p>另外，还可以利用数字签名攻击公钥密码。因为对消息签名，从另一方面来说，也是对消息解密。利用这一点，攻击者就可以发动一种巧妙的攻击，即利用数字签名来破译密文。</p>
<p>假设攻击者拦截到发送者发给接收者的密文后将其保存了下来，并给接收者写了一封邮件，谎称自己是密码学研究者，正在进行关于数字签名的实验，请求接收者对附件中的数据进行签名并回复，说附件中的数据只是随机数据，不会造成任何问题。而实际上，附件的数据就是刚才保存下来的密文。如果接收者中计而对附近进行了签名并回复给了攻击者，那攻击者不费吹灰之力就可以破译密文了。</p>
<p>对于这种攻击，应该采取怎样的对策呢？首先，不要直接对消息进行签名，对散列值进行签名比较安全；其次，公钥密码和数字签名最好分别使用不同的密钥对。然而，最重要的就是绝对不要对意思不清楚的消息进行签名，尤其是不要对看起来只是随机数据的消息进行签名。</p>
<blockquote>
<h3 id="数字签名无法解决的问题"><a href="#数字签名无法解决的问题" class="headerlink" title="数字签名无法解决的问题"></a>数字签名无法解决的问题</h3></blockquote>
<p>用数字签名既可以识别出篡改和伪装，还可以防止否认。即是说，数字签名同时实现了确认消息的完整性、进行认证以及否认防止。</p>
<p>然而，数字签名存在和公钥密码一样的问题，那就是公钥问题。公钥必须属于真正的发送者，要确认公钥是否合法，就需要使用证书。这就是后面要讲到的内容了。</p>
<h2 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h2><p>无论是公钥密码还是数字签名，都存在需要验证公钥是否合法的问题。而证书，就是用来对公钥合法性提供证明的技术。</p>
<p><strong>公钥证书</strong>(Public-Key Certificate，PKC)和驾照类似，一般会记有姓名、组织、邮箱地址等个人信息，以及属于本人的公钥，并由<strong>认证机构</strong>(Certification Authority、Certifying Authority，CA)施加数字签名。</p>
<p>认证机构就是能够认定“公钥确实属于此人”并能够生成数字签名的个人或组织。认证机构中有国际性组织和政府所设立的组织，也有通过提供认证服务来盈利的一般企业，此外个人也可以成立认证机构哦。世界上最有名的认证机构当属VeriSign公司。</p>
<blockquote>
<h3 id="证书的应用场景"><a href="#证书的应用场景" class="headerlink" title="证书的应用场景"></a>证书的应用场景</h3></blockquote>
<p>通过认证机构使用证书的过程如下图所示：</p>
<img src="/post/reading/20160705/10-22-29.jpg">

<ol>
<li>接收者生成密钥对；</li>
<li>接收者在认证机构注册自己的公钥；</li>
<li>认证机构用自己的私钥对接收者的公钥施加数字签名并生成证书；</li>
<li>发送者得到带有认证机构数字签名的属于接收者的公钥证书；</li>
<li>发送者使用认证机构的公钥验证数字签名，验证通过则证明证书中包含的公钥的确属于接收者的；</li>
<li>发送者用接收者的公钥加密消息并发送给接收者；</li>
<li>接收者用自己的私钥解密密文得到消息。</li>
</ol>
<blockquote>
<h3 id="公钥基础设施-PKI"><a href="#公钥基础设施-PKI" class="headerlink" title="公钥基础设施(PKI)"></a>公钥基础设施(PKI)</h3></blockquote>
<p><strong>公钥基础设施</strong>(Public-Key Infrastructure)是为了能够更有效地运用公钥而制定的一系列规范和规格的总称。公钥基础设施一般根据其英语缩写而简称为PKI。PKI只是一个总称，而并非指某一个单独的规范或规格。比如，使用最广泛的 X.509 规范也是PKI的一种。</p>
<p>PKI的组成要素主要有3个：</p>
<ul>
<li><strong>用户</strong>：使用PKI的人</li>
<li><strong>认证机构</strong>：颁发证书的人</li>
<li><strong>仓库</strong>：保存证书的数据库</li>
</ul>
<p>这三者的关系如下图：</p>
<img src="/post/reading/20160705/10-54-39.jpg">

<p>另外，认证机构会有层级的关系，处于最顶层的认证机构一般就称为<strong>根CA</strong>(Root CA)。上层认证机构可以验证下层认证机构的证书，即是说，下层认证机构的证书是经过上层认证机构签名的。而根CA则会对自己的证书进行签名，这叫<strong>自签名</strong>。认证机构的层级关系如下图：</p>
<img src="/post/reading/20160705/10-59-23.jpg">

<p>当发送者需要对最底层的Bob的数字签名进行验证时，首先从最顶层的根CA开始，然后获得下层的公钥证书，这个证书上面会带有上层的数字签名，因此需要用上层的公钥对数字签名进行验证。这样逐层向下验证，一直验证到最底层的Bob。</p>
<blockquote>
<h3 id="对证书的攻击"><a href="#对证书的攻击" class="headerlink" title="对证书的攻击"></a>对证书的攻击</h3></blockquote>
<p>由于证书使用的就是数字签名技术，因此针对数字签名的所有攻击方法对证书都有效。</p>
<p>另外，在公钥注册之前也可以进行攻击。用户准备在认证机构注册自己的公钥时，攻击者可以把消息拦截，然后将公钥替换成自己的。这样一来，认证机构就会对“接收者的个人信息”和“攻击者的公钥”这个组合进行数字签名。要防止这种攻击，接收者可以在将自己的公钥发送给认证机构进行注册时，使用认证机构的公钥对自己的公钥进行加密。此外，认证机构在确认接收者的身份时，也可以将公钥的指纹(即散列值)一并发送给接收者请他进行确认。</p>
<p>攻击者还可以利用注册相似人名进行攻击。证书是认证机构对公钥及其持有者的信息加上数字签名的产物，对于一些相似的身份信息，计算机可以进行区别，但人类往往很容易认错，而这就可以被用来进行攻击。比如，假设用户信息中名字的部分是：</p>
<ul>
<li>Name = Bob  (首字母大写)</li>
</ul>
<p>而攻击者用另一个类似的用户信息注册了另一个不同的公钥：</p>
<ul>
<li>Name = BOB (所有字母大写)</li>
</ul>
<p>随后，攻击者伪装成Bob，将 Name = BOB 的公钥发送给通信对象Alice，Alice看到证书中的用户信息，很可能会将BOB误认为是自己要发送消息的对象Bob。</p>
<p>要防止这种攻击，认证机构必须确认证书中所包含的信息是否真的是其持有者的个人信息，当本人身份确认失败时则不向其颁发证书。</p>
<p>攻击者也可以窃取认证机构的私钥，不过认证机构对私钥的保护是非常严密的，所以一般比较难窃取。如果认证机构的私钥泄露了，认证机构就需要将私钥泄露一事通过 CRL 通知用户。CRL(Certificate Revocation List)为证书作废清单，是认证机构宣布作废的证书一览表，具体来说，是一张已作废的证书序列号的清单，并由认证机构加上了数字签名。</p>
<p>利用钻上面提到的 CRL 的空子也可以进行攻击。因为从公钥失效到发送者收到 CRL 需要经过一段时间，攻击者就可以利用这段时间差来发动攻击。</p>
<blockquote>
<h3 id="关于证书的-Q-amp-A"><a href="#关于证书的-Q-amp-A" class="headerlink" title="关于证书的 Q&amp;A"></a>关于证书的 Q&amp;A</h3></blockquote>
<ul>
<li><strong>为什么需要证书</strong><br>如果从认证机构获取公钥，就可以降低遭到中间人攻击的风险。因为带有证书的公钥是经过认证机构进行数字签名的，事实上无法被篡改。</li>
</ul>
<p>其实，如果能够取得可信的公钥，比如通信双方在同一个办公室，很容易取得可信的公钥，这种情况下则不需要认证机构。否则，认证机构和证书的存在就有意义了。当持有可信的认证机构公钥，并相信认证机构所进行的身份确认的情况下，则可以信任该认证机构颁发的证书以及通过该途径取得的公钥。</p>
<ul>
<li><strong>通过自己的方法进行认证是不是更安全</strong><br>有些人对使用公开的技术总觉得不放心，使用公开的技术等于为攻击者提供了用于攻击的信息，相比之下，还是使用公司自己开发的保密的认证方法更安全吧？</li>
</ul>
<p>其实这是错误的。自己开发保密的方法是犯了典型的<strong>隐蔽式安全</strong>(security by obscurity)错误。私下开发安全相关的技术其实是危险的，仅靠一家公司的力量无法开发出足以抵御攻击的安全技术。这也是为什么 AES 和 RSA 算法要采用公开竞赛的方式，让全世界的安全专家一起来验证这些技术的安全性。</p>
<ul>
<li><strong>为什么要相信认证机构</strong></li>
</ul>
<p>其实，这个问题关系到“信任是如何产生的”这一本质性问题。为什么我们要把钱存进银行呢？认证机构是否让人感到可信，和银行是一样的。</p>
<p>也有不依赖于认证机构的，PGP 软件就是。PGP 是通过<strong>信任网</strong>的方法来建立每个人之间的信任关系的。下一篇文章再具体讲 PGP。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>本篇文章总结了四部分内容：单向散列函数、消息认证码、数字签名和证书。数字签名的安全性最高，既能确保完整性，也能进行认证和防止否认。另外，数字签名也是将单向散列函数和公钥密码技术相结合在了一起。<a href="http://keeganlee.me/post/reading/20160629">前一篇</a>文章所讲的混合密码系统也是结合了多种技术。其实，实用性的安全产品，都是多种密码技术组合在一起实用的。例如，PGP、SSL\TLS等。下一篇就会讲如何将多种密码技术组合在一起。</p>
<hr>
<p>扫描以下二维码即可关注订阅号。</p>
<img src="/post/reading/20160705/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/reading/20160629/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/reading/20160629/" class="post-title-link" itemprop="url">读《图解密码技术》(一):密码</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-06-29 10:50:00" itemprop="dateCreated datePublished" datetime="2016-06-29T10:50:00+08:00">2016-06-29</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-02 12:15:18" itemprop="dateModified" datetime="2019-07-02T12:15:18+08:00">2019-07-02</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/reading/" itemprop="url" rel="index"><span itemprop="name">reading</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/reading/20160629"><strong>http://keeganlee.me/post/reading/20160629</strong></a><br>微信订阅号：<strong>keeganlee_me</strong><br>写于2016-06-29</p>
<hr>
<p><a href="http://keeganlee.me/post/reading/20160629">读《图解密码技术》(一):密码</a><br><a href="http://keeganlee.me/post/reading/20160705">读《图解密码技术》(二):认证</a><br><a href="http://keeganlee.me/post/reading/20160722">读《图解密码技术》(三):密钥、随机数和应用技术</a></p>
<hr>
<p>以前，对一些密码技术，虽然懂得怎么用，但对其原理却一直不甚了解，比如，用公钥加密后，为什么用私钥就可以解密？DES和AES加密时为什么需要一个初始化向量？想要了解这些密码技术的基本原理，而最近买书时看到了《图解密码技术》这本书，刚好可以解答到我的这些问题，于是，就买回来看了。</p>
<p>而从现在开始，每读一本书，我都会尽量分享我的读书笔记，有两个目的：一是为自己做总结整理，加强记忆和理解；二是可以给还没看过该书的读者提供摘要和指引。好了，接下来进入正文。</p>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>《图解密码技术》的目标读者主要包括以下人群：</p>
<ul>
<li>对密码相关知识感兴趣的人</li>
<li>希望理解公钥密码、数字签名等密码技术原理的人（我就属于此类）</li>
<li>对信息安全感兴趣的人</li>
</ul>
<p>本书的结构分为三部分：</p>
<ul>
<li>密码：内容主要包括对密码技术整体性的讲解，以及历史密码、对称密码、公钥密码等保证机密性的密码技术。</li>
<li>认证：内容包括单向散列函数、消息认证码、数字签名、证书等密码技术。</li>
<li>密钥、随机数和应用技术：内容包括密钥、随机数相关的知识，以及PGP、SSL/TLS等应用技术。</li>
</ul>
<p>本篇文章是关于第一部分的笔记。</p>
<h2 id="密码技术"><a href="#密码技术" class="headerlink" title="密码技术"></a>密码技术</h2><p>密码技术的目的很明确，就是为了解决信息安全问题。信息安全可分为四类特性：</p>
<ul>
<li><strong>机密性</strong>：为了防止信息被窃听，对应的密码技术有<strong>对称密码</strong>和 <strong>公钥密码</strong>。</li>
<li><strong>完整性</strong>：为了防止信息被篡改，对应的密码技术有<strong>单向散列函数</strong>、 <strong>消息认证码</strong>、 <strong>数字签名</strong>。</li>
<li><strong>认证</strong>：为了防止攻击者伪装成真正的发送者，对应的密码技术有<strong>消息认证码</strong>和 <strong>数字签名</strong>。</li>
<li><strong>不可否认性</strong>：为了防止发送者事后否认自己没有做过，对应的密码技术为<strong>数字签名</strong>。</li>
</ul>
<p>信息安全和密码技术之间的关系可以用下图来表示：</p>
<img src="/post/reading/20160629/09-38-10.jpg">

<p>接下来就简单了解下这些密码技术：</p>
<ul>
<li><strong>对称密码</strong>：也称为共享密钥密码、私钥密码等，是指在加密和解密时使用同一密钥的方式。</li>
<li><strong>公钥密码</strong>：也称为非对称密码，是指在加密和解密时使用不同密钥的方式。对称密码和公钥密码可以保证数据的机密性。</li>
<li><strong>单向散列函数</strong>：MD5、SHA-1，就是单向散列函数的例子，使用单向散列函数可以计算出散列值，散列值也称为哈希值、密码校验和、指纹、消息摘要。使用单向散列函数可以保证数据的完整性。</li>
<li><strong>消息认证码</strong>：消息认证码是一种确认完整性并进行认证的技术，英文名称为message authentication code，简称为MAC。</li>
<li><strong>数字签名</strong>：数字签名相当于现实世界中的盖章、签字的功能，使用数字签名可以识别篡改和伪装，还可以防止否认。</li>
<li><strong>伪随机数生成器</strong>：伪随机数生成器并不直接解决信息安全问题，但它承担了密钥生成的重要职责。而密钥的重要性就不用多说了。</li>
</ul>
<h2 id="一次性密码本"><a href="#一次性密码本" class="headerlink" title="一次性密码本"></a>一次性密码本</h2><p>曾经以为，理论上应该没有任何密码是无法破译的。只要通过暴力破解法，无论任何密文总有一天都能够被破译。如今才知道，特例是存在的。这个特例就是<strong>一次性密码本</strong>。即使用暴力破解法，就算破解到世界末日，也破译不了一次性密码本。</p>
<p>一次性密码本其实非常简单，它的原理就是：<strong>将明文与一串随机的比特序列进行XOR运算，即异或运算</strong>。随机的比特序列也称为<strong>密钥</strong>，密钥的长度需与明文等长。而解密时，则将密文与密钥再进行一次XOR运算，就可以得到明文了。</p>
<p>举例，现在要对midnight这个字符串进行加密，对其进行ASCII编码后得到一串比特序号：</p>
<img src="/post/reading/20160629/11-09-16.jpg">

<p>以上为64比特，然后，随机生成一个同样64比特长的密钥：</p>
<img src="/post/reading/20160629/11-10-14.jpg">

<p>接着，将明文和密钥进行XOR运算：</p>
<img src="/post/reading/20160629/11-11-45.jpg">

<p>这样，密文就产生了。而解密则是反向运算，即将密文与密钥进行XOR运算：</p>
<img src="/post/reading/20160629/11-13-39.jpg">

<p>一次性密码本，就是这么简单。那么，为什么它不可破译呢？用暴力破解，尝试所有可能的密钥组合，总能得到midnight啊。问题就在于，即使解密出了midnight这个字符串，也无法判断它是否是正确的明文。因为，所有64比特的排列组合都会出现，那么，解密出来的，除了midnight，还会有onenight、lastnight，以及aaaaaaaa、abcdefgh、ZZZZZZZZ等各种字符串，根本无法判断哪个才是正确的明文。</p>
<p>虽然一次性密码本无法被破译，但它并不实用。最大的缺点就在于每一次通信都需要使用不同的密钥，所以密钥就无法重用了，“一次性”也正是由此而来。而且，每次密钥的生成都必须是无重现性的真正随机数，而不是伪随机数。其他的，密钥的配送、保存、同步也都是比较麻烦。所以，能够使用一次性密码本的，只有机密性重于一切，且可以花费大量财力和人力来生成并配送密钥的场合。据说，大国之间的热线就用了一次性密码本，密钥应该是通过特工直接送到对方手上的。</p>
<h2 id="对称密码"><a href="#对称密码" class="headerlink" title="对称密码"></a>对称密码</h2><p>对称密码使用相同的密钥进行加密和解密，作为标准的对称密码主要有<strong>DES</strong>、 <strong>三重DES</strong>和 <strong>AES</strong>，它们都属于<strong>分组密码</strong>，即以分组为单位进行处理的密码算法。DES和三重DES的分组长度都是64比特，而AES的分组长度可以为128比特、192比特和256比特中的一种。那么，如果要加密的明文比较长，就需要对密码算法进行迭代，而迭代的方法就称为分组密码的<strong>模式</strong>。具体有哪些模式，后面再说。</p>
<blockquote>
<h3 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h3></blockquote>
<p>DES(Data Encryption Standard)是一种将64比特的明文加密成64比特的密文的对称密码算法，它的密钥长度是56比特，即7个字节。DES的结构采用的是<strong>Feistel网络</strong>。Feistel网络中，加密的各个步骤称为<strong>轮</strong>(round)，整个加密过程就是进行若干次轮的循环。下图是Feistel网络中一轮的计算流程。DES是一种16轮循环的Feistel网络。</p>
<img src="/post/reading/20160629/21-44-33.jpg">

<p>一轮的具体计算步骤如下：</p>
<ol>
<li>将输入的数据等分为左右两部分；</li>
<li>将输入的右侧直接发送到输出的右侧；</li>
<li>将输入的右侧发送到轮函数；</li>
<li>轮函数根据右侧数据和子密钥，计算出一串看上去是随机的比特序列；</li>
<li>将上一步得到的比特序列与左侧数据进行XOR运算，并将结果作为加密后的左侧。</li>
</ol>
<p>其中，<strong>子密钥</strong>指的是本轮加密使用的密钥。每一轮的子密钥都是不同的。<strong>轮函数</strong>的作用则是根据“右侧”和子密钥生成对“左侧”进行加密的比特序列，它是密码系统的核心。</p>
<p>但是，这样一来“右侧”根据没有被加密，因此需要用不同子密钥对一轮的处理重复若干次，并在没两轮之间将左侧和右侧的数据对调。下图展示了一个3轮的Feistel网络：</p>
<img src="/post/reading/20160629/22-01-06.jpg">

<p>那么，Feistel如何解密呢？很简单，只要按照相同的顺序来使用子密钥就可以完成解密了。即将上图中的子密钥1换成了子密钥3，而子密钥3则换成子密钥1，输入的为密文，输出的则为明文了。</p>
<p>无论是任何轮数、任何轮函数，Feistel网络都可以用相同的结构实现加密和解密，且加密的结果必定能够正确解密。因为Feistel网络具有如此方便的特性，因此，被许多分组密码算法使用，包括5个AES最终候选算法中的其中3个算法：MARS、RC6、Twofish。</p>
<blockquote>
<h3 id="三重DES"><a href="#三重DES" class="headerlink" title="三重DES"></a>三重DES</h3></blockquote>
<p>现在DES已经可以在短时间内被暴力破解，因此，其强度大不如前了。为了增强DES的强度，因此出现了三重DES(triple-DES)，将DES重复3次所得到的一种密码算法，通常缩写为3DES，其机制如下图所示：</p>
<img src="/post/reading/20160629/22-28-53.jpg">

<p>明文经过三次DES处理才能变成最后的密文，而由于DES的密钥长度为56比特，因此三重DES的密钥长度则为56<em>3=128比特。另外，从图中也可以发现，三重DES并不是进行3次DES加密，而是加密-&gt;*</em>解密**-&gt;加密的过程。这是为了向下兼容，即使用DES加密的密文，也可以通过三重DES进行解密。</p>
<p>三重DES的解密过程和加密相反，是以密钥3、密钥2、密钥1的顺序执行解密-&gt;加密-&gt;解密的操作。即将上图从明文到密文的箭头反过来就是解密的流程了。</p>
<blockquote>
<h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3></blockquote>
<p>AES(Advanced Encryption Standard)是取代其前任标准(DES)而成为新标准的一种对称密码算法。AES最终候选算法名单中，总共有5种算法，分为为：MARS、RC6、Rijndael、Serpent、Twofish。但最终被选定为AES的是<strong>Rijndael</strong>算法。</p>
<p>Rijndael使用的并不是Feistel网络，而是<strong>SPN结构</strong>。Rijndael加密中的一轮如下图所示，其分组为128比特，即16字节，加密过程经过4个步骤：SubBytes、ShiftRows、MixColumns、AddRoundKey。</p>
<img src="/post/reading/20160629/22-48-28.jpg">

<p><strong>SubBytes</strong>就是根据一张替换表(S-Box)，将输入中每个字节的值替换成另一个字节的值。<strong>ShiftRows</strong>即将SubBytes的输出以字节为单位进行打乱出路，当然，这种打乱处理也是有规律的。<strong>MixColumns</strong>即对一个4字节的值进行比特运算，将其变成另外一个4字节的值。<strong>AddRoundKey</strong>就是将MixColumns的输出与轮密钥进行XOR处理。至此，一轮就结束了。实际上，在Rijndael中需要重复进行10~14轮计算。</p>
<p>而下图则是一轮解密的流程图，基本也是反向操作，加密时的SubBytes、ShiftRows、MixColumns，解密时分别为反向运算的InvSubBytes、InvShiftRows、InvMixColumns。这是因为Rijndael不像Feistel网络一样能够用同一种结构实现加密和解密。</p>
<img src="/post/reading/20160629/23-30-28.jpg">

<p>对于三种对称密码，DES因为已经很容易被暴力破解，因此不建议再使用；三重DES目前还被银行等机构使用，但其处理速度不高，而且在安全性方面也逐渐显现出了一些问题；AES作为最新标准，安全、快速，而且可以在各种平台上工作，可以算是目前最佳的选择。另外，其他AES最终候选算法也可以作为AES的备份。和Rijndael一样，这些密码算法也都经过了严格的测试，且没有发现任何弱点。</p>
<h2 id="分组模式"><a href="#分组模式" class="headerlink" title="分组模式"></a>分组模式</h2><p>DES、AES都属于分组密码，它们只能加密固定长度的明文。如果需要加密任意长度的明文，就需要对分组密码进行迭代，而迭代方法就称为分组密码的“模式”。分组密码有很多种模式，主要有：ECB、CBC、CFB、OFB、CTR。如果模式选择不恰当，就无法保证机密性。</p>
<blockquote>
<h3 id="ECB模式"><a href="#ECB模式" class="headerlink" title="ECB模式"></a>ECB模式</h3></blockquote>
<p><strong>ECB</strong>全称为Electronic CodeBook，<strong>电子密码本模式</strong>，是最简单的一种模式，它直接将明文分割成多个分组并逐个加密，如下图，其中，加密和解密是指用分组密码算法加密和解密，其中也省略了密钥的描述。</p>
<img src="/post/reading/20160629/21-42-05.jpg">

<p>当最后一个明文分组的内容小于分组长度时，需要用一些特定的数据进行填充。</p>
<p>这种模式的优点就是简单、快速，加密和解密都支持并行计算。而缺点也比较明显，因为每个明文分组都各自独立地进行加密和解密，如果明文中存在多个相同的明文分组，则这些分组最终会被转换为相同的密文分组。这样一来，只要观察一下密文，就可以知道明文中存在怎样的重复组合，并可以以此为线索来破译密码。另外，攻击者可以通过改变密文分组的顺序，或删除密文分组，或替换掉密文分组，就可以达到对明文操纵的目的，而无需破译密码。</p>
<blockquote>
<h3 id="CBC模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h3></blockquote>
<p><strong>CBC</strong>全称为Cipher Block Channing，<strong>密文分组链接模式</strong>，是将前一个密文分组与当前明文分组的内容混合起来进行加密的。在CBC模式中，首先将明文分组与前一个密文分组进行XOR运算，然后再进行加密。加密第一个明文分组时，由于不存在“前一个密文分组”，因此需要事先准备一个长度为一个分组的比特序列来代替“前一个密文分组”，这个比特序列称为<strong>初始化向量</strong>(initialization vector)，通常缩写为IV。一般来说，每次加密时都会随机产生一个不同的比特序列来作为初始化向量。CBC模式的加解密流程如下图：</p>
<img src="/post/reading/20160629/21-43-28.jpg">

<p>CBC模式避免了ECB模式的弱点，明文的重复排列不会反映在密文中。这是推荐使用的一种模式。</p>
<blockquote>
<h3 id="CFB模式"><a href="#CFB模式" class="headerlink" title="CFB模式"></a>CFB模式</h3></blockquote>
<p><strong>CFB</strong>全称为Cipher FeedBack，<strong>密文反馈模式</strong>，前一个密文分组会被送回到密码算法的输入端，如下图：</p>
<img src="/post/reading/20160629/13-13-14.jpg">

<p>CFB模式中，由密码算法所生成的比特序列称为<strong>密钥流</strong>(key stream)。需要注意的是，CFB模式解密时，密码算法执行的是加密操作，因为密钥流是通过加密操作来生成的。</p>
<p>CFB模式无法抵御重放攻击。因此，一般不建议使用了，推荐用CTR模式代替。</p>
<blockquote>
<h3 id="OFB模式"><a href="#OFB模式" class="headerlink" title="OFB模式"></a>OFB模式</h3></blockquote>
<p><strong>OFB</strong>全称为Output-FeedBack，<strong>输出反馈模式</strong>，密码算法的输出会反馈到密码算法的输入中，如下图：</p>
<img src="/post/reading/20160629/13-24-29.jpg">

<p>OFB模式有个缺陷，如果对密钥流的一个分组进行加密后其结果碰巧和加密前是相同的，那么这一分组之后的密钥流就会变成同一值的不断反复。因此，一般不建议使用了，推荐用CTR模式代替。</p>
<blockquote>
<h3 id="CTR模式"><a href="#CTR模式" class="headerlink" title="CTR模式"></a>CTR模式</h3></blockquote>
<p><strong>CTR</strong>全称为CountTeR，<strong>计数器模式</strong>，是一种通过逐次累加的计数器进行加密来生成密钥流的流密码，如下图：</p>
<img src="/post/reading/20160629/13-28-45.jpg">

<p>CTR模式中，每个分组对应一个逐次累加的计数器，并通过对计数器进行加密来生成密钥流。计数器分为两部分，前部分为<strong>nonce</strong>，这和初始化向量一样，也是一个随机比特序列；后部分为分组序号。</p>
<p>从图中还可以知道，CTR模式对每个分组的处理是相对独立的，这就意味着加密和解密都能够实现并行计算。</p>
<p>CTR模式在错误和机密性方面都具有不错的性质，也没有上面提到的CFB和OFB的弱点，因此，现在都推荐使用CTR了。</p>
<blockquote>
<h3 id="关于初始化向量问题"><a href="#关于初始化向量问题" class="headerlink" title="关于初始化向量问题"></a>关于初始化向量问题</h3></blockquote>
<p>前面讲到的几种模式中，CBC、CFB、OFB都用到了初始化向量IV，而CTR则使用了计数器，计数器的<strong>nonce</strong>部分和初始化向量IV是一样的，只是叫法不同而已。关于初始化向量IV，是一个随机比特序列，为了提高安全性，建议每次加密时都使用不同的值，这样的话，即使有两条相同的明文信息，加密后的密文也是不同的。但是，每一次发送端使用IV对明文加密后，接收端也需要使用同样的IV才能够解密，那么，发送端和接收端如何同步这个IV呢？关于这个问题，书中没有提到。于是，只好自己寻找解决方案。</p>
<p>最简单的方式可能就是，发送端每次发送信息时，将IV和加密后的密文一起发送给接收端。接收端收到信息后，就可以将收到的IV用于解密收到的密文了。而这种方式最明显的缺陷就是IV直接暴露给攻击者了，攻击者就可以利用IV发起攻击，比如使用CBC模式时，攻击者将IV进行比特反转，就可达到操纵明文的目的。攻击者将IV中的任意比特进行反转(1变0，0变1)，则解密后的明文分组中相应的比特也会被反转。</p>
<p>为了避免将IV直接暴露，那将IV进行加密后再发送呢？因为IV的长度和一个分组的长度是等长的，这就不需要考虑分组迭代的问题，即不需要考虑使用什么模式了，直接用密码算法进行加密即可。加密后，攻击者再想通过比特反转IV来操纵明文就困难多了。</p>
<h2 id="密钥配送问题"><a href="#密钥配送问题" class="headerlink" title="密钥配送问题"></a>密钥配送问题</h2><p>对称密码中，由于加密和解密都使用同一个密钥，因此就必须向接收者配送密钥，这个问题就称为密钥配送问题。而解决密钥配送问题的方法有几种：</p>
<ul>
<li>通过事先共享密钥来解决</li>
<li>通过密钥分配中心来解决</li>
<li>通过Diffie-Hellman密钥交换来解决</li>
<li>通过公钥密码来解决</li>
</ul>
<blockquote>
<h3 id="通过事先共享密钥来解决"><a href="#通过事先共享密钥来解决" class="headerlink" title="通过事先共享密钥来解决"></a>通过事先共享密钥来解决</h3></blockquote>
<p>事先用安全的方式将密钥交给对方，就称为密钥的事先共享。这是密钥配送问题最简单的一种解决方法，但有其局限性。公司内部开发的应用产品，客户端和服务端都是自己开发的，事先共享密钥就很简单，服务端人员生成密钥后直接给到客户端的开发人员就可以了。但这种情况又会带来其他问题，比如密钥在客户端如何才能安全的保存。一般，密钥都是通过硬编码或存为文件的形式保存在客户端的，那么客户端应用一旦被反编译，就很容易窃取到密钥了。</p>
<p>而如果是开放性平台，像微博开放平台、微信开放平台等，要做到事先共享密钥就很有难度了。开发者在开放平台注册的应用，其密钥都是通过平台的管理端给到开发者的，也就是通过了网络，那就存在被窃听的风险了。</p>
<blockquote>
<h3 id="通过密钥分配中心来解决"><a href="#通过密钥分配中心来解决" class="headerlink" title="通过密钥分配中心来解决"></a>通过密钥分配中心来解决</h3></blockquote>
<p>当使用密钥分配中心时，需要通信的双方可以事先在密钥分配中心注册，然后密钥分配中心给每个注册方发送一个密钥，不同注册方的密钥是不同的。那么，当某个发送端需要向某个接收端发送消息时，通信流程如下：</p>
<ol>
<li>发送端向密钥分配中心发起希望与接收端通信的请求；</li>
<li>密钥分配中心随机生成一个会话密钥，该会话密钥是供发送端和接收端在本次通信中使用的临时密钥，我们简称为<strong>TempKey</strong>；</li>
<li>密钥分配中心查询出发送端的密钥，即发送端注册时分配的密钥，我们简称为<strong>SenderKey</strong>；</li>
<li>密钥分配中心使用<strong>SenderKey</strong>对<strong>TempKey</strong>进行加密，加密后的密文称为<strong>CipherTempKeyToSender</strong>，并发送给发送端；</li>
<li>密钥分配中心用同样的方式查询出接收端的密钥，简称为<strong>ReceiverKey</strong>；</li>
<li>密钥分配中心再用<strong>ReceiverKey</strong>对<strong>TempKey</strong>进行加密，加密后的密文称为<strong>CipherTempKeyToReceiver</strong>，并发送给接收端；</li>
<li>发送端对来自密钥分配中心的<strong>CipherTempKeyToSender</strong>，用自己的密钥即<strong>SenderKey</strong>进行解密，得到<strong>TempKey</strong>；</li>
<li>发送端将要发送给接收端的消息用<strong>TempKey</strong>进行加密，然后发送给接收端；</li>
<li>接收端对来自密钥分配中心的<strong>CipherTempKeyToReceiver</strong>，用自己的密钥即<strong>ReceiverKey</strong>进行解密，也得到<strong>TempKey</strong>；</li>
<li>接收端收到发送端的密文后，用<strong>TempKey</strong>对密文进行解密；</li>
<li>通信完毕，发送端和接收端都删除<strong>TempKey</strong>。</li>
</ol>
<p>这个通信过程还挺复杂的，总的来说就是，发送端和接收端通信时是使用密钥分配中心分配的临时密钥进行加密和解密的。这种方案，密钥分配中心的安全性就显得非常重要了。如果攻击者入侵了密钥分配中心，盗取到所有密钥，则后果很严重。</p>
<blockquote>
<h3 id="通过Diffie-Hellman密钥交换来解决"><a href="#通过Diffie-Hellman密钥交换来解决" class="headerlink" title="通过Diffie-Hellman密钥交换来解决"></a>通过Diffie-Hellman密钥交换来解决</h3></blockquote>
<p>在Diffie-Hellman密钥交换中，进行加密通信的双方需要交换一些信息，而这些信息即便被窃听者窃听到也没有问题。根据所交换的信息，双方可以各自生成相同的密钥，而窃听者却无法生成相同的密钥。</p>
<p>虽然这种方法叫“密钥交换”，但实际上双方并没有真正交换密钥，而是通过计算生成出了一个相同的共享密钥。因此，这种方法也称为<strong>Diffie-Hellman密钥协商</strong>。支撑Diffie-Hellman密钥交换算法的是有限群的离散对数问题的复杂度。</p>
<blockquote>
<h3 id="通过公钥密码来解决"><a href="#通过公钥密码来解决" class="headerlink" title="通过公钥密码来解决"></a>通过公钥密码来解决</h3></blockquote>
<p>公钥密码类似于投币寄物柜。首先，将物品放入寄物柜中。然后，投入硬币并拔出钥匙，就可以将寄物柜关闭了。关闭后的寄物柜，没有钥匙是无法打开的。只要有硬币，任何人都可以关闭寄物柜，但寄物柜一旦被关闭，再怎么投币也无法打开。要打开寄物柜只能使用钥匙，而不是硬币。因此可以说，硬币是<strong>关闭寄物柜的密钥</strong>，而钥匙是<strong>打开寄物柜的密钥</strong>。</p>
<p>在公钥密码中，加密和解密的密钥是不同的。只要拥有加密密钥，任何人都可以进行加密，但没有解密密钥是无法解密的。接收者事先将加密密钥发送给发送者，这个加密密钥即便被窃听者获取也没有问题。发送者使用加密密钥对通信内容进行加密并发送给接收者，而只有拥有解密密钥的人（即接收者本人）才能够进行解密。这样一来，就用不着将解密密钥配送给接收者了，也就是说，不存在密钥配送问题了。</p>
<h2 id="公钥密码"><a href="#公钥密码" class="headerlink" title="公钥密码"></a>公钥密码</h2><p>公钥密码中，密钥分为加密密钥和解密密钥两种。加密密钥一般是公开的，因此也被称为<strong>公钥</strong>(public key)。解密密钥则绝对不能公开，因此也称为<strong>私钥</strong>(private key)。公钥和私钥是一一对应的，一对公钥和私钥统称为<strong>密钥对</strong>(key pair)。由公钥加密的密文，只有配对的私钥才能够解密。</p>
<p>使用公钥密码通信时，流程如下：</p>
<img src="/post/reading/20160629/14-53-35.jpg">

<p>那么，密钥对是如何生成的呢？为什么用公钥加密的密文能用私钥解密呢？要理解公钥密码的原理，需要先理解一些数学上的问题，mod运算是基础。</p>
<p>公钥密码是基于数学上困难的问题来保证机密性的，比如利用质因数分解的困难度、mod运算下求离散对数的困难度、mod运算下求平方根的困难度，等等。现在使用最广泛的公钥密码算法RSA就是利用了大整数质因数分解问题的困难度。</p>
<blockquote>
<h3 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h3></blockquote>
<p>要理解RSA算法的原理，就要先理解一些mod运算方面的知识。mod运算，其实就是“除法求余数的运算”，比如：</p>
<ul>
<li>27 mod 12 = 3  表示27除以12的余数等于3</li>
</ul>
<p>加法和乘法都非常简单，比如：</p>
<ul>
<li>(6 + 7) mod 12 = 13 mod 12 = 1</li>
<li>7 * 7 mod 12 = 49 mod 12 = 1 </li>
</ul>
<p>减法和除法则可以看成加法和乘法的逆运算，比如：</p>
<ul>
<li>(7 + N) mod 12 = 0  7加上几除以12的余数为0？</li>
<li>7 * M mode 12 = 1  7乘以几除以12的余数为1？</li>
</ul>
<p>这里，N 和 M 都要求大于等于 0 小于 12。N 还是很容易算出来的，答案是5。而 M 一下子就比较难算出来，可以用暴力破解把0~11都代入 M 计算一下结果，最终可以得到 M = 7。接着，看另一个算式：</p>
<ul>
<li>N * M mod 12 = 1</li>
</ul>
<p>如果没有 mod 12，那 N 和 M 就是互为倒数。此处的话，我们还要加上“在以12为模的世界中”这个条件。在一般的算术中，互为倒数可以写成：</p>
<ul>
<li>N * 1/N = 1</li>
</ul>
<p>那么，在以12为模的世界中，在0到11的数字中，是不是每一个数都存在相应的倒数呢？实际上，mod运算中“某个数是否存在倒数”这个问题，与RSA中“一个公钥是否存在相对应的私钥”这个问题是直接相关的。下表列出了结果：</p>
<img src="/post/reading/20160629/21-54-45.jpg">

<p>存在倒数的只有1、5、7、11，这些数有怎样的性质呢？其实，在 mod 12 的世界中，存在倒数的数，它们和12之间的最大公约数都是1，也可以说是和12互质的数。那么，如果是在 mod 14 的世界中，存在倒数的则有1、3、5、9、11、13。</p>
<p>接着，看看乘方的mod运算又是怎样的。比如，现在要求 7^4 mod 12，最笨的方法就是将7^4直接算出结果，然后除以12求余。而快速的计算方法则是在计算的中间步骤求mod，如下：</p>
<ul>
<li>7^4 mod 12 = 7<em>7</em>7<em>7 mod 12 = ((7*7 mod 12)</em>(7<em>7 mod 12)) mod 12 = ((49 mod 12)</em>(49 mod 12)) mod 12 = 1*1 mod 12 = 1</li>
</ul>
<p>在中间步骤求mod，可以避免计算大整数的乘积。这种在计算过程中求mod来计算乘方的方法，也是RSA的加密和解密算法中所使用的方法。</p>
<p>接着，再看看对数，即乘方的逆运算。mod运算中的对数称为离散对数，比如：</p>
<ul>
<li>7^N mod 13 = 8</li>
</ul>
<p>这里N应该等于几呢？像下面这样依次尝试一遍，可以得到 N = 9：</p>
<img src="/post/reading/20160629/22-17-21.jpg">

<p>当数字很大时，求离散对数就会非常困难，而且非常耗时。到现在也还没有发现能够快速求出离散对数的算法。也因此，有很多公钥算法都运用了离散对数。</p>
<blockquote>
<h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3></blockquote>
<p>RSA是现在使用最广泛的公钥密码算法，但RSA不只用于公钥密码，也用于数字签名。关于数字签名下一篇文章再讲。</p>
<p>在RSA中，明文、密钥和密文都是数字。RSA的加密过程可以用下列公式来表达，其中，Plaintext 指明文，Cipher 指密文：</p>
<ul>
<li><strong>Cipher = Plaintext^E mod N （RSA加密）</strong></li>
</ul>
<p>RSA的密文是对明文的数字的 E 次方求 mod N 的结果。换句话说，就是将明文和自己做 E 次乘法，然后将其结果除以 N 求余数，这个余数就是密文。因此，只要知道 E 和 N 这两个数，任何人都可以完成加密的运算。所以说，E 和 N 是RSA加密的密钥，也就是说，E 和 N 的组合就是密钥。另外，E 是加密(Encryption)的首字母，N 是数字(Number)的首字母。</p>
<p>RSA的解密和加密一样简单，可以用下面的公式来表达，其中，Plaintext 指明文，Cipher 指密文：</p>
<ul>
<li><strong>Plaintext = Cipher^D mod N （RSA解密）</strong></li>
</ul>
<p>对表示密文的数字的 D 次方求 mod N 就可以得到明文。换句话说，将密文和自己做 D 次乘法，再对其结果除以 N 求余数，就可以得到明文。这里的数字 N 和加密时的 N 是相同的。D 和 N 组合起来就是RSA的解密密钥，因此，D 和 N 的组合就是私钥。另外，D 是解密(Decryption)的首字母。</p>
<p>整理一下，RSA的加密和解密如下图：</p>
<img src="/post/reading/20160629/17-04-34.jpg">

<p>由于 E 和 N 是公钥，D 和 N 是私钥，因此求 E、D 和 N 这三个数就是生成密钥对。密钥对的生成步骤如下：</p>
<ol>
<li>求N：N = p * q<br>其中，p、q 是需要事先准备的两个很大的质数。p 和 q 太小的话，密码会变得容易破译，但太大的话计算时间又会变得很长。一般来说，p 和 q 的长度都是512比特以上，N 的长度为1024以上。</li>
<li>求L：L = lcm(p-1, q-1)<br>L 是仅在生成密钥对的过程中使用的数，它是 p-1 和 q-1 的最小公倍数。</li>
<li>求E：1 &lt; E &lt; L &amp;&amp; gcd(E, L) = 1<br>E 是一个比 1 大、比 L 小的数。此外，E 和 L 的最大公约数必须为 1，即 E 和 L 互质，这样可以保证一定存在解密时需要使用的数 D。</li>
<li>求D：1 &lt; D &lt; L &amp;&amp; E * D mod L = 1<br>D 也是是一个比 1 大、比 L 小的数，而且是由数 E 计算得到的。从 E * D mod L = 1 这条公式得知，要保证存在满足条件的 D，就需要保证 E 和 L 的最大公约数为 1。简单来说，E * D mod L = 1 保证了对密文进行解密时能够得到原来的明文。</li>
</ol>
<blockquote>
<h3 id="公钥密码的问题"><a href="#公钥密码的问题" class="headerlink" title="公钥密码的问题"></a>公钥密码的问题</h3></blockquote>
<p>公钥密码虽然可以避免密钥配送问题，但也存在两个很大的问题：</p>
<ol>
<li>公钥密码的处理速度远远低于对称密码；</li>
<li>公钥密码难以抵御中间人攻击。</li>
</ol>
<p>如果用公钥密码去处理很长的消息，那么，公钥密码速度慢的缺点就会显露无疑。所以，一般，不会用公钥密码直接处理消息。而是和对称密码相结合，采用混合密码系统。关于混合密码系统，下面再说。</p>
<p>对于第二个问题，是因为公钥是公开的，任何人都可以获取，也包括攻击者。所谓中间人攻击，就是攻击者混入发送者和接收者中间，对发送者伪装成接收者，对接收者伪装成发送者的攻击方式。如下图所示：</p>
<img src="/post/reading/20160629/09-55-25.jpg">

<p>在这种情况下，就没有机密性可言了，因为发送者用来加密的其实是攻击者的公钥，攻击者拦截到信息后就可以用自己的私钥解密出来，再用之前拦截到的接收者的公钥对伪造的消息加密后发给接收者。</p>
<p>仅靠公钥密码本身，是无法防御中间人攻击的。要防御中间人攻击，还需要一种手段来确认所收到的公钥是否真的属于接收者，这种手段称为认证。针对上面的情况，我们可以使用公钥的证书。关于认证和证书，下一篇文章再讲。</p>
<h2 id="混合密码系统"><a href="#混合密码系统" class="headerlink" title="混合密码系统"></a>混合密码系统</h2><p>混合密码系统是将对称密码和公钥密码的优势相结合的方法，加密消息使用快速的对称密码，而用公钥密码来加密对称密码的密钥。因为对称密码的密钥一般比消息本身要短，因此公钥密码速度慢的问题就可以忽略了。另外，对称密码使用的密钥是临时生成的会话密钥。混合密码系统的加密过程如下图：</p>
<img src="/post/reading/20160629/10-18-43.jpg">

<p>从图中就可得知：</p>
<ol>
<li>会话密钥是随机生成的，因此，每次加密的会话密钥都会不同；</li>
<li>混合密码系统的明文是用对称密码加密的，而加密使用的密钥就是上一步生成的会话密钥；</li>
<li>用公钥密码对会话密钥进行加密，形成了加密后的会话密钥；</li>
<li>将加密后的会话密钥和加密后的消息组合在一起，就是混合密码系统的密文。</li>
</ol>
<p>而解密过程则如下图所示：</p>
<img src="/post/reading/20160629/10-25-49.jpg">

<p>从图中也可得知：</p>
<ol>
<li>将已加密的会话密钥和消息进行分离；</li>
<li>用公钥密码对已加密的会话密钥进行解密，得到会话密钥明文；</li>
<li>用对称密码对已加密的消息进行解密，而解密密钥就是上一步解密出来的会话密钥。</li>
</ol>
<p>那么，怎样才算是一个高强度的混合密码系统呢？混合密码系统运用了伪随机数生成器、对称密码和公钥密码，因此其中每一种技术要素的强度都必须很高，而且，这些技术要素之间的强度平衡也非常重要。</p>
<p>如果伪随机数生成器的算法很差，生成的会话密钥就有可能被攻击者推测出来。会话密钥中哪怕只有部分比特被推测出来也是很危险的，因为会话密钥的密钥空间不大，很容易通过暴力破解来发动攻击。</p>
<p>对称密码被用于加密消息，我们需要使用高强度的对称密码算法，并确保密钥具有足够的长度。此外，还要选择使用合适的分组密码模式。</p>
<p>公钥密码被用于加密会话密钥，同样需要使用高强度的公钥密码算法，并确保密钥具有足够的长度。</p>
<p>另外，公钥密码的强度应该要高于对称密码，因为对称密码的会话密钥被破译只会影响本次通信的内容，而公钥密码一旦被破译，从过去到未来的（用相同公钥加密的）所以通信内容就都能够被破译了。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>本篇文章只是本书第一部分的读书笔记，虽然也有加入了一点自己的看法。第一部分的内容主要是关于保证机密性的密码技术。但信息安全还包括消息完整性、进行认证以及防止否认的技术，这些下面的文章再做总结。</p>
<hr>
<p>扫描以下二维码即可关注订阅号。</p>
<img src="/post/reading/20160629/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Keegan小钢</p>
              <div class="site-description motion-element" itemprop="description">分享钢哥人生路上的点点滴滴</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">21</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Keegan小钢</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.1.2</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/affix.js?v=7.1.2"></script>

  <script src="/js/schemes/pisces.js?v=7.1.2"></script>




  

  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
