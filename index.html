<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="分享钢哥人生路上的点点滴滴">
<meta name="keywords" content="个人成长 全栈 区块链">
<meta property="og:type" content="website">
<meta property="og:title" content="Keegan小钢">
<meta property="og:url" content="https://keeganlee.me/index.html">
<meta property="og:site_name" content="Keegan小钢">
<meta property="og:description" content="分享钢哥人生路上的点点滴滴">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Keegan小钢">
<meta name="twitter:description" content="分享钢哥人生路上的点点滴滴">





  
  
  <link rel="canonical" href="https://keeganlee.me/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Keegan小钢</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Keegan小钢</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">钢哥的个人博客</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/matching/20191203/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/matching/20191203/" class="post-title-link" itemprop="url">撮合引擎开发:日志输出</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-03 10:32:34 / 修改时间：16:24:56" itemprop="dateCreated datePublished" datetime="2019-12-03T10:32:34+08:00">2019-12-03</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/matching/" itemprop="url" rel="index"><span itemprop="name">matching</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/matching/20191203"><strong>http://keeganlee.me/post/matching/20191203</strong></a><br>微信公众号：名称：Keegan小钢；微信号：keeganlee_me<br>写于2019-12-03</p>
<hr>
<p><a href="http://keeganlee.me/post/matching/20191117">撮合引擎开发：开篇</a><br><a href="http://keeganlee.me/post/matching/20191118">撮合引擎开发：MVP版本</a><br><a href="http://keeganlee.me/post/matching/20191119">撮合引擎开发：数据结构设计</a><br><a href="http://keeganlee.me/post/matching/20191121">撮合引擎开发：对接黑箱</a><br><a href="http://keeganlee.me/post/matching/20191127">撮合引擎开发：解密黑箱流程</a><br><a href="http://keeganlee.me/post/matching/20191130">撮合引擎开发：流程的代码实现</a><br><a href="http://keeganlee.me/post/matching/20191202">撮合引擎开发：缓存和MQ</a><br><a href="http://keeganlee.me/post/matching/20191203">撮合引擎开发：日志输出</a></p>
<hr>
<h2 id="日志需求"><a href="#日志需求" class="headerlink" title="日志需求"></a>日志需求</h2><p>我们都知道日志在一个程序中有着重要的作用，撮合引擎也同样需要一个完善的日志输出功能，以方便调试和查询数据。</p>
<p>对一个撮合引擎来说，需要输出的日志主要有以下几类：</p>
<ol>
<li>程序启动的日志，包括连接 Redis 成功的日志、Web 服务启动成功的日志；</li>
<li>接口请求和响应数据的日志；</li>
<li>启动了某引擎的日志；</li>
<li>关闭了某引擎的日志；</li>
<li>订单被添加到 orderBook 的日志；</li>
<li>成交记录的日志；</li>
<li>撤单结果的日志。</li>
</ol>
<p>另外，撮合引擎产生的日志会非常多，所以还应该做日志分割，按日期分割是最常用的日志分割方式，所以我们也同样将不同日期的日志分割到不同日志文件保存。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>首先，我们都知道日志是有分级别的，多的比如 log4j 定义了 8 种级别的日志。不过，最常用的就 4 种级别，优先级从低到高分别为：<strong>DEBUG、INFO、WARN、ERROR</strong>。一般，不同环境会设置不同的日志级别，如 DEBUG 级别一般只在开发和测试环境才设置，生产环境则会设置为 INFO 或更高级别。当设置为高级别时，低级别的日志消息是不会打印出来的。那为了打印不同级别的日志消息，可以提供不同级别的打印函数，比如提供 <strong>log.Debug()、log.Info()</strong> 等函数。</p>
<p>其次，日志需要输出到文件保存，因此，就需要指定文件保存的目录、文件名和文件对象。一般，保存的文件目录和运行程序应该放在一起，所以，指定的文件目录最好是相对路径。</p>
<p>另外，文件还要根据日期做分割，即不同日期的日志消息要保存到不同的日志文件，那么，自然要记录下当前日志的日期。以及需要定时监控，当检测到最新日期跟当前日志的日期相比已经跨日了，说明需要进行日志分割了，那就将当前的日志文件进行备份，并创建新文件用来保存新日期的日志消息。</p>
<p>最后，日志消息写入文件的话，那就少不了耗时的 I/O 操作，如果用同步方式写日志，无疑会减低撮合性能，因此，最好选用异步方式写日志，可以用带缓冲的通道实现。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>我重新自定义了一个 log 包，并创建了 log.go 文件，所有代码都写在该文件中。</p>
<p>第一步，先定义几种日志等级，直接定义成枚举类型，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LEVEL <span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	DEBUG LEVEL = <span class="literal">iota</span></span><br><span class="line">	INFO</span><br><span class="line">	WARN</span><br><span class="line">	ERROR</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>第二步，定义日志的结构体，其包含的字段比较多，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FileLogger <span class="keyword">struct</span> &#123;</span><br><span class="line">	fileDir        <span class="keyword">string</span>         <span class="comment">// 日志文件保存的目录</span></span><br><span class="line">  fileName       <span class="keyword">string</span>         <span class="comment">// 日志文件名（无需包含日期和扩展名）</span></span><br><span class="line">	prefix         <span class="keyword">string</span>         <span class="comment">// 日志消息的前缀</span></span><br><span class="line">  logLevel       LEVEL          <span class="comment">// 日志等级</span></span><br><span class="line">  logFile        *os.File       <span class="comment">// 日志文件</span></span><br><span class="line">	date           *time.Time     <span class="comment">// 日志当前日期</span></span><br><span class="line">	lg             *log.Logger    <span class="comment">// 系统日志对象</span></span><br><span class="line">	mu             *sync.RWMutex  <span class="comment">// 读写锁，在进行日志分割和日志写入时需要锁住</span></span><br><span class="line">	logChan        <span class="keyword">chan</span> <span class="keyword">string</span>    <span class="comment">// 日志消息通道，以实现异步写日志</span></span><br><span class="line">  stopTickerChan <span class="keyword">chan</span> <span class="keyword">bool</span>      <span class="comment">// 停止定时器的通道</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步，为了能将日志应用到程序中任何地方，就需要定义一个全局的日志对象，并要对该日志对象进行初始化。初始化操作有一点复杂，我们先来看代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> DATE_FORMAT = <span class="string">"2006-01-02"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fileLog *FileLogger</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">(fileDir, fileName, prefix, level <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	CloseLogger()</span><br><span class="line"></span><br><span class="line">	f := &amp;FileLogger&#123;</span><br><span class="line">		fileDir:       fileDir,</span><br><span class="line">		fileName:      fileName,</span><br><span class="line">		prefix:        prefix,</span><br><span class="line">		mu:            <span class="built_in">new</span>(sync.RWMutex),</span><br><span class="line">		logChan:       <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">5000</span>),</span><br><span class="line">		stopTikerChan: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> strings.ToUpper(level) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"DEBUG"</span>:</span><br><span class="line">		f.logLevel = DEBUG</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"WARN"</span>:</span><br><span class="line">		f.logLevel = WARN</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"ERROR"</span>:</span><br><span class="line">		f.logLevel = ERROR</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		f.logLevel = INFO</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	t, _ := time.Parse(DATE_FORMAT, time.Now().Format(DATE_FORMAT))</span><br><span class="line">	f.date = &amp;t</span><br><span class="line"></span><br><span class="line">	f.isExistOrCreateFileDir()</span><br><span class="line"></span><br><span class="line">	fullFileName := filepath.Join(f.fileDir, f.fileName+<span class="string">".log"</span>)</span><br><span class="line">	file, err := os.OpenFile(fullFileName, os.O_RDWR|os.O_APPEND|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	f.logFile = file</span><br><span class="line"></span><br><span class="line">	f.lg = log.New(f.logFile, prefix, log.LstdFlags|log.Lmicroseconds)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> f.logWriter()</span><br><span class="line">	<span class="keyword">go</span> f.fileMonitor()</span><br><span class="line"></span><br><span class="line">	fileLogger = f</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个初始化的逻辑有点多，我来进行拆分讲解。首先，第一步，调用了 <strong>CloseLogger()</strong> 函数，该函数主要是关闭文件、关闭通道等操作。为了停止一个不断循环的 goroutine，关闭通道是一个常用的方案，这在之前的文章也有说过。那么，由于初始化函数可以会被调用多次，以实现配置的变更，那如果不先结束旧的 goroutine ，那同样功能的 goroutine 将不止一个在同时运行，这无疑将会出问题。因此，需要先关闭 Logger，关闭 Logger 的代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CloseLogger</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> fileLogger != <span class="literal">nil</span> &#123;</span><br><span class="line">		fileLogger.stopTikerChan &lt;- <span class="literal">true</span></span><br><span class="line">		<span class="built_in">close</span>(fileLogger.stopTikerChan)</span><br><span class="line">		<span class="built_in">close</span>(fileLogger.logChan)</span><br><span class="line">		fileLogger.lg = <span class="literal">nil</span></span><br><span class="line">		fileLogger.logFile.Close()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关闭 Logger 之后，就是对一些字段的初始化赋值了，其中，<strong>f.date</strong> 设置为了当前日期，后面判断是否需要分割就以这个日期为条件。<strong>f.isExistOrCreateFileDir()</strong> 则会判断日志目录是否存在，如果不存在则会创建该目录。接着，将目录、设置的文件名和添加的 .log 文件扩展名拼接在一起，拼接出文件的完整名字并打开文件。之后就是用该文件来初始化系统日志对象 <strong>f.lg</strong> 了，将日志消息写入文件时其实就是调用该对象的 <strong>Output()</strong> 函数。后面启动了两个 goroutine：一个用来监听 logChan，实现将日志消息写入文件；一个用来定时监听文件是否需要分割，需要分割时则实现分割。 </p>
<p>接着，我们就来看看这两个 goroutine 的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FileLogger)</span> <span class="title">logWriter</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="built_in">recover</span>() &#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		str, ok := &lt;-f.logChan</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		f.mu.RLock()</span><br><span class="line">		f.lg.Output(<span class="number">2</span>, str)</span><br><span class="line">		f.mu.RUnlock()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FileLogger)</span> <span class="title">fileMonitor</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="built_in">recover</span>() &#125;()</span><br><span class="line">	ticker := time.NewTicker(<span class="number">30</span> * time.Second)</span><br><span class="line">	<span class="keyword">defer</span> ticker.Stop()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">			<span class="keyword">if</span> f.isMustSplit() &#123;</span><br><span class="line">				<span class="keyword">if</span> err := f.split(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					Error(<span class="string">"Log split error: %v\n"</span>, err)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> &lt;-f.stopTikerChan:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <strong>logWriter()</strong> 循环从 logChan 通道读取日志消息，当通道被关闭则退出，否则就调用 <strong>f.lg.Output()</strong> 将日志输出。<strong>fileMonitor()</strong> 里则创建了一个每隔 30 秒发送一次的 <strong>ticker</strong>，当从 <strong>ticker.C</strong> 接收到数据之后，就判断是否需要分割，如果需要则调用分割函数 <strong>f.split()</strong>。而从 <strong>f.stopTikerChan</strong> 收到数据时，说明该定时器也要结束了。</p>
<p>接着，再来看看 <strong>isMustSplit()</strong> 和 <strong>split()</strong> 函数了。isMustSplit() 非常简单，就两行代码，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FileLogger)</span> <span class="title">isMustSplit</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	t, _ := time.Parse(DATE_FORMAT, time.Now().Format(DATE_FORMAT))</span><br><span class="line">	<span class="keyword">return</span> t.After(f.date)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>split() 则复杂些，首先对日志要先加写锁，避免分割时依然有日志写入，接着对当前的日志文件进行重命名备份，然后生成新文件用来记录新的日志消息，并将当前的全局日志对象指向新文件、新日期和新的系统日志对象。实现代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FileLogger)</span> <span class="title">split</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	f.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> f.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	logFile := filepath.Join(f.fileDir, f.fileName)</span><br><span class="line">	logFileBak := logFile + <span class="string">"-"</span> + f.date.Format(DATE_FORMAT) + <span class="string">".log"</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> f.logFile != <span class="literal">nil</span> &#123;</span><br><span class="line">		f.logFile.Close()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err := os.Rename(logFile, logFileBak)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	t, _ := time.Parse(DATE_FORMAT, time.Now().Format(DATE_FORMAT))</span><br><span class="line">	f.date = &amp;t</span><br><span class="line"></span><br><span class="line">	f.logFile, err = os.OpenFile(logFile, os.O_RDWR|os.O_APPEND|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	f.lg = log.New(f.logFile, f.prefix, log.LstdFlags|log.Lmicroseconds)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，就剩下定义一些接收日志消息的函数了，实现都很简单，以 <strong>Info()</strong> 为例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Info</span><span class="params">(format <span class="keyword">string</span>, v ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	_, file, line, _ := runtime.Caller(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">if</span> fileLogger.logLevel &lt;= INFO &#123;</span><br><span class="line">		fileLogger.logChan &lt;- fmt.Sprintf(<span class="string">"[%v:%v]"</span>, filepath.Base(file), line) + fmt.Sprintf(<span class="string">"[INFO]"</span>+format, v...)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Debug()、Warn()、Error() 等函数都类似的，照猫画虎即可。</p>
<p>至此，我们这个能够实现按日期分割日志文件的日志包就完成了，剩下的，就在对应需要添加日志输出的地方调用响应的日志等级函数即可。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本小结的核心其实是增加了一个通用的日志包，该日志包不仅可以用在我们的撮合引擎，也能用于其他项目。如果再将其扩展，还可以改为按其他条件分割，比如按小时分割，或按文件大小分割。有兴趣的小伙伴可以自己去尝试一下。</p>
<p>今日的思考题：要实现接口的请求和响应数据进行统一的日志输出，有哪些方案？</p>
<hr>
<p>扫描以下二维码即可关注公众号（公众号名称：Keegan小钢）</p>
<img src="/post/matching/20191203/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/matching/20191202/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/matching/20191202/" class="post-title-link" itemprop="url">撮合引擎开发:缓存和MQ</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-02 15:06:14" itemprop="dateCreated datePublished" datetime="2019-12-02T15:06:14+08:00">2019-12-02</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-03 10:40:58" itemprop="dateModified" datetime="2019-12-03T10:40:58+08:00">2019-12-03</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/matching/" itemprop="url" rel="index"><span itemprop="name">matching</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/matching/20191202"><strong>http://keeganlee.me/post/matching/20191202</strong></a><br>微信公众号：名称：Keegan小钢；微信号：keeganlee_me<br>写于2019-12-02</p>
<hr>
<p><a href="http://keeganlee.me/post/matching/20191117">撮合引擎开发：开篇</a><br><a href="http://keeganlee.me/post/matching/20191118">撮合引擎开发：MVP版本</a><br><a href="http://keeganlee.me/post/matching/20191119">撮合引擎开发：数据结构设计</a><br><a href="http://keeganlee.me/post/matching/20191121">撮合引擎开发：对接黑箱</a><br><a href="http://keeganlee.me/post/matching/20191127">撮合引擎开发：解密黑箱流程</a><br><a href="http://keeganlee.me/post/matching/20191130">撮合引擎开发：流程的代码实现</a><br><a href="http://keeganlee.me/post/matching/20191202">撮合引擎开发：缓存和MQ</a><br><a href="http://keeganlee.me/post/matching/20191203">撮合引擎开发：日志输出</a></p>
<hr>
<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>先来回顾下我们撮合程序项目中关于中间件的目录结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├── middleware               # 中间件的包</span><br><span class="line">│   ├── cache                # 缓存包</span><br><span class="line">│   │   └── cache.go         # 缓存操作</span><br><span class="line">│   ├── mq                   # 消息队列包</span><br><span class="line">│   │   └── mq.go            # MQ操作</span><br><span class="line">│   └── redis.go             # 主要做Redis初始化操作</span><br></pre></td></tr></table></figure>

<p>虽然现在只用到了 Redis 一个中间件，但设计个 middleware 包，会方便以后扩展添加其他中间件，如 Kafka 或 RocketMQ 等。</p>
<p>再将缓存和消息队列分包，职责上就很分明，应用时也很明确。</p>
<p><strong>redis.go</strong> 就只是做初始化的连接，我们来看看代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> middleware</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"matching/log"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/go-redis/redis"</span></span><br><span class="line">	<span class="string">"github.com/spf13/viper"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> RedisClient *redis.Client</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	addr := viper.GetString(<span class="string">"redis.addr"</span>)</span><br><span class="line">	RedisClient = redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">		Addr:     addr,</span><br><span class="line">		Password: <span class="string">""</span>, <span class="comment">// no password set</span></span><br><span class="line">		DB:       <span class="number">0</span>,  <span class="comment">// use default DB</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	_, err := RedisClient.Ping().Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">"Connected to redis: %s"</span>, addr)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，viper 是前文说过的第三方配置库，通过 <strong>viper.GetString(“redis.addr”)</strong> 从配置文件读取出要连接的 Redis 的地址，之后就新建一个 Redis 客户端并连接上 Redis 服务器了。</p>
<h2 id="缓存的设计"><a href="#缓存的设计" class="headerlink" title="缓存的设计"></a>缓存的设计</h2><p>讲数据结构设计时，我们已经说过，使用缓存的目的主要有两个：</p>
<ol>
<li><strong>请求去重</strong>，避免重复提交相同订单；</li>
<li><strong>恢复数据</strong>，即程序重启后能恢复所有数据。</li>
</ol>
<p>还记得上一篇文章讲 Dispatch 的实现时，有个判断订单是否存在的逻辑吗？就是读取缓存中是否已经存在该订单，从而判别是否为重复请求或无效请求。以及，还记得 process 包的初始化？就是从缓存中恢复数据的过程。</p>
<p>先了解下，我们总共缓存了哪些数据：</p>
<ul>
<li><p>开启撮合的交易标的 symbol；</p>
</li>
<li><p>这些交易标的的最新价格；</p>
</li>
<li><p>所有有效的订单请求，包括下单和撤单请求。</p>
</li>
</ul>
<h3 id="1-缓存symbol"><a href="#1-缓存symbol" class="headerlink" title="1. 缓存symbol"></a>1. 缓存symbol</h3><p>开启撮合的交易标的 symbol 会有多个，且不能重复，那其实就可以保存为集合 set 类型。我将该 set 的 key 设计为 <strong>matching:symbols</strong>，之后，每有一个 symbol 开启撮合时，就可以用 Redis 的 <strong>sadd</strong> 命令将该 symbol 添加进这个集合里去了。而关闭撮合时，则需用 <strong>srem</strong> 命令将关闭撮合的 symbol 从集合中移除。读取所有 symbol 则可用 <strong>smembers</strong> 命令操作。</p>
<p>程序里对 symbol 的操作提供了三个函数，分别用来保存 symbol、移除 symbol 和获取所有 symbol，以下是实现的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SaveSymbol</span><span class="params">(symbol <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	key := <span class="string">"matching:symbols"</span></span><br><span class="line">	RedisClient.SAdd(key, symbol)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RemoveSymbol</span><span class="params">(symbol <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	key := <span class="string">"matching:symbols"</span></span><br><span class="line">	RedisClient.SRem(key, symbol)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetSymbols</span><span class="params">()</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	key := <span class="string">"matching:symbols"</span></span><br><span class="line">	<span class="keyword">return</span> RedisClient.SMembers(key).Val()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-缓存价格"><a href="#2-缓存价格" class="headerlink" title="2. 缓存价格"></a>2. 缓存价格</h3><p>交易标的的最新价格则是每个 symbol 会有一个价格，且无需缓存历史价格，那我就直接用字符串类型来保存价格，而每个价格的 key 则包含有各自的 symbol，key 的格式设计为 <strong>matching:price:{symbol}</strong>，假如要保存的 symbol = “BTCUSD”，那对应的 key 值就是 <strong>matching:price:BTCUSD</strong>，保存的 value 值就是 BTCUSD 的最新价格。</p>
<p>我们也同样提供了保存价格、获取价格和删除价格的三个函数，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SavePrice</span><span class="params">(symbol <span class="keyword">string</span>, price decimal.Decimal)</span></span> &#123;</span><br><span class="line">	key := <span class="string">"matching:price:"</span> + symbol</span><br><span class="line">	RedisClient.Set(key, price.String(), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetPrice</span><span class="params">(symbol <span class="keyword">string</span>)</span> <span class="title">decimal</span>.<span class="title">Decimal</span></span> &#123;</span><br><span class="line">	key := <span class="string">"matching:price:"</span> + symbol</span><br><span class="line">	priceStr := RedisClient.Get(key).Val()</span><br><span class="line">	result, err := decimal.NewFromString(priceStr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		result = decimal.Zero</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RemovePrice</span><span class="params">(symbol <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	key := <span class="string">"matching:price:"</span> + symbol</span><br><span class="line">	RedisClient.Del(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-缓存订单"><a href="#3-缓存订单" class="headerlink" title="3. 缓存订单"></a>3. 缓存订单</h3><p>对订单的缓存设计则没那么简单了，需要满足两点要求：</p>
<ol>
<li>既能缓存下单请求，也能缓存撤单请求；</li>
<li>订单要符合定序要求。</li>
</ol>
<p>先说下第一点，为什么需要缓存订单？且为什么下单和撤单请求都需要缓存？</p>
<p>先来解答第一个问题，我们是在内存中撮合的，每个交易标的引擎里各自维护了一个交易委托账本，程序运行时，这些账本是直接保存在程序内存里的。那如果程序退出了，这些账本都被清空了。如果没有缓存，那程序重启后就无法恢复账本数据。要满足该需求，就需要缓存账本里的所有委托单。</p>
<p>关于第二个问题，我们来考虑这样一个场景：假如订单通道里有撤单请求在排队，而程序并没有对撤单请求做缓存，这时程序重启了，那么订单通道里的所有订单还没被引擎接收处理之前就被清空了，撤单请求也就无法恢复了。</p>
<p>因此，程序需要缓存好订单，且下单和撤单都需要缓存。</p>
<p>再来看第二个要求，为什么要符合定序？我们知道，订单通道里的订单是定序的，交易委托账本里同价格的订单也是按时间排序的，那缓存时如果不定序，程序重启后就难以保证按原有的顺序恢复订单。</p>
<p>那具体要怎么来设计这个订单的缓存呢？我的方案是分两类缓存，第一类保存每个独立的订单请求，包括下单和撤单；第二类分交易标的保存对应 symbol 所有订单请求的订单 ID 和 action。</p>
<p>第一类，我设计的 Key 格式为 <strong>matching:order:{symbol}:{orderId}:{action}</strong>，symbol、orderId 和 action 则是对应订单的三个变量值。比如，某订单 symbol = “BTCUSD”，orderId = “12345”，action = “cancel”，那该订单保存到 Redis 的 Key 值就是 <strong>matching:order:BTCUSD:12345:cancel</strong>。该 Key 对应的 Value 则是保存整个订单对象，可以用 <strong>hash</strong> 类型存储。</p>
<p>第二类，我设计的 Key 格式为 <strong>matching:orderids:{symbol}</strong>，Value 保存的是 <strong>sorted set</strong> 类型的数据，保存对应 symbol 的所有订单请求，每条记录保存的值为 <strong>{orderId}:{action}</strong>，而 <strong>score</strong> 值设为对应订单的 <strong>{timestamp}</strong>。用订单时间作为 score 就可以保证定序了。还记得之前文章我们将订单时间的单位设为 100 纳秒，保证时间戳长度刚好为 16 位吗？这是因为，如果超过 16 位，那 score 将转为科学计数法表示，那将会导致数字失真。</p>
<p>根据这样的设计，那保存订单时的实现逻辑就如以下代码所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SaveOrder</span><span class="params">(order <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	symbol := order[<span class="string">"symbol"</span>].(<span class="keyword">string</span>)</span><br><span class="line">	orderId := order[<span class="string">"orderId"</span>].(<span class="keyword">string</span>)</span><br><span class="line">	timestamp := order[<span class="string">"timestamp"</span>].(<span class="keyword">float64</span>)</span><br><span class="line">	action := order[<span class="string">"action"</span>].(<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">	key := <span class="string">"matching:order:"</span> + symbol + <span class="string">":"</span> + orderId + <span class="string">":"</span> + action</span><br><span class="line">	RedisClient.HMSet(key, order)</span><br><span class="line"></span><br><span class="line">	key = <span class="string">"matching:orderids:"</span> + symbol</span><br><span class="line">	z := &amp;redis.Z&#123;</span><br><span class="line">		Score:  timestamp,</span><br><span class="line">		Member: orderId + <span class="string">":"</span> + action,</span><br><span class="line">	&#125;</span><br><span class="line">	RedisClient.ZAdd(key, z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，还提供了 GetOrder()、UpdateOrder()、RemoveOrder()、OrderExist()、GetOrderIdsWithAction() 等函数。再给大伙看看 GetOrderIdsWithAction() 函数的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetOrderIdsWithAction</span><span class="params">(symbol <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	key := <span class="string">"matching:orderids:"</span> + symbol</span><br><span class="line">	<span class="keyword">return</span> RedisClient.ZRange(key, <span class="number">0</span>, <span class="number">-1</span>).Val()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数得到的结果是根据 score 值排好序的，这就是我们想要的结果。理解了这个设计之后，再翻回去看看 process 包的初始化，你就会明白那些代码的逻辑了。</p>
<h2 id="MQ的设计"><a href="#MQ的设计" class="headerlink" title="MQ的设计"></a>MQ的设计</h2><p>我们选择了使用 Redis 的 Stream 数据结构来作为 MQ 输出，Stream 数据结构采用了类似 Kafka 的设计，应用起来很方便。但由于 Redis 运行于内存的特性，相比 Kafka 快速很多，这也是我选择它来作为撮合程序的输出 MQ 的主要原因。</p>
<p>我们只有两类 MQ，撤单结果和成交记录，发送消息的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendCancelResult</span><span class="params">(symbol, orderId <span class="keyword">string</span>, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	values := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">"orderId"</span>: orderId, <span class="string">"ok"</span>: ok&#125;</span><br><span class="line">	a := &amp;redis.XAddArgs&#123;</span><br><span class="line">		Stream:       <span class="string">"matching:cancelresults:"</span> + symbol,</span><br><span class="line">		MaxLenApprox: <span class="number">1000</span>,</span><br><span class="line">		Values:       values,</span><br><span class="line">	&#125;</span><br><span class="line">	RedisClient.XAdd(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendTrade</span><span class="params">(symbol <span class="keyword">string</span>, trade <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	a := &amp;redis.XAddArgs&#123;</span><br><span class="line">		Stream:       <span class="string">"matching:trades:"</span> + symbol,</span><br><span class="line">		MaxLenApprox: <span class="number">1000</span>,</span><br><span class="line">		Values:       trade,</span><br><span class="line">	&#125;</span><br><span class="line">	RedisClient.XAdd(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<strong>matching:cancelresults:{symbol}</strong> 就是撤单结果的 MQ 所属的 Key，<strong>matching:trades:{symbol}</strong> 则是成交记录的 MQ 所属的 Key。可以看到，我们还根据不同 symbol 分不同 MQ，这样还方便下游服务可以根据需要实现分布式订阅不同 symbol 的 MQ。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本小节讲解了缓存和 MQ 的设计与实现，理解了这部分的设计之后，对整个撮合引擎的核心设计也基本能理解了。</p>
<p>最后，依然留几个思考题：是否可以不用缓存？如果不用缓存可以如何解决去重和数据恢复的问题？</p>
<hr>
<p>扫描以下二维码即可关注公众号（公众号名称：Keegan小钢）</p>
<img src="/post/matching/20191202/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/matching/20191130/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/matching/20191130/" class="post-title-link" itemprop="url">撮合引擎开发:流程的代码实现</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-30 12:19:26" itemprop="dateCreated datePublished" datetime="2019-11-30T12:19:26+08:00">2019-11-30</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-03 10:42:18" itemprop="dateModified" datetime="2019-12-03T10:42:18+08:00">2019-12-03</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/matching/" itemprop="url" rel="index"><span itemprop="name">matching</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/matching/20191130"><strong>http://keeganlee.me/post/matching/20191130</strong></a><br>微信公众号：名称：Keegan小钢；微信号：keeganlee_me<br>写于2019-11-30</p>
<hr>
<p><a href="http://keeganlee.me/post/matching/20191117">撮合引擎开发：开篇</a><br><a href="http://keeganlee.me/post/matching/20191118">撮合引擎开发：MVP版本</a><br><a href="http://keeganlee.me/post/matching/20191119">撮合引擎开发：数据结构设计</a><br><a href="http://keeganlee.me/post/matching/20191121">撮合引擎开发：对接黑箱</a><br><a href="http://keeganlee.me/post/matching/20191127">撮合引擎开发：解密黑箱流程</a><br><a href="http://keeganlee.me/post/matching/20191130">撮合引擎开发：流程的代码实现</a><br><a href="http://keeganlee.me/post/matching/20191202">撮合引擎开发：缓存和MQ</a><br><a href="http://keeganlee.me/post/matching/20191203">撮合引擎开发：日志输出</a></p>
<hr>
<h2 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h2><p>我们要开始聊代码实现逻辑了，如果不记得之前讲的目录结构，请回去翻看<a href="http://keeganlee.me/post/matching/20191121">前文</a>。聊代码实现的第一步自然从程序入口开始，核心就两个函数：<strong>init()</strong> 和 <strong>main()</strong>，其代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line">... <span class="comment">//other codes</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	initViper()</span><br><span class="line">	initLog()</span><br><span class="line"></span><br><span class="line">	engine.Init()</span><br><span class="line">	middleware.Init()</span><br><span class="line">	process.Init()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mux := http.NewServeMux()</span><br><span class="line">	mux.HandleFunc(<span class="string">"/openMatching"</span>, handler.OpenMatching)</span><br><span class="line">	mux.HandleFunc(<span class="string">"/closeMatching"</span>, handler.CloseMatching)</span><br><span class="line">	mux.HandleFunc(<span class="string">"/handleOrder"</span>, handler.HandleOrder)</span><br><span class="line"></span><br><span class="line">	log.Printf(<span class="string">"HTTP ListenAndServe at port %s"</span>, viper.GetString(<span class="string">"server.port"</span>))</span><br><span class="line">	<span class="keyword">if</span> err := http.ListenAndServe(viper.GetString(<span class="string">"server.port"</span>), mux); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>init() 函数做了一些初始化的操作，我来简单介绍这几个初始化函数：</p>
<ul>
<li><strong>initViper()</strong>：配置文件初始化，使用了第三方配置库 viper，这是一个被广泛使用的配置库，其 github 地址为 <a href="https://github.com/spf13/viper" target="_blank" rel="noopener">https://github.com/spf13/viper</a>。</li>
<li><strong>initLog()</strong>：日志初始化，程序主要使用自己定义的日志包用来输出日志文件，该日志包的实现后续文章再单独讲。</li>
<li><strong>engine.Init()</strong>：引擎包的初始化，只是初始化了一个 map，用来保存不同交易标的的订单 channel，作为各交易标的的定序队列来用。</li>
<li><strong>middleware.Init()</strong>：中间件的初始化，我们用到的中间件就只有 Redis，所以这里其实就是初始化 Redis 连接。Redis 客户端库方面我选择的是 <a href="https://github.com/go-redis/redis" target="_blank" rel="noopener">go-redis/redis</a>。</li>
<li><strong>process.Init()</strong>：这一步主要是从缓存加载和恢复各交易标的引擎的启动和所有订单数据。</li>
</ul>
<p>viper 和 redis 的初始化都是参照官方 demo 写的，这里就不展开说明了。log 后续再单独讲。engine 包和 process 包的初始化就需要好好讲讲。</p>
<p>其中，引擎包的初始化虽然非常简单，但很关键，其代码写在 <strong>engine/init.go</strong> 文件中，完整代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> engine</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ChanMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">chan</span> Order</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ChanMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">chan</span> Order)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个保存通道的 map，其 Key 是各交易标的的 symbol，即是说每个交易标的各有一个订单通道，这些订单通道将作为每个交易标的的定序队列。</p>
<p>process 包的初始化则如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	symbols := cache.GetSymbols()</span><br><span class="line">	<span class="keyword">for</span> _, symbol := <span class="keyword">range</span> symbols &#123;</span><br><span class="line">		price := cache.GetPrice(symbol)</span><br><span class="line">		NewEngine(symbol, price)</span><br><span class="line"></span><br><span class="line">		orderIds := cache.GetOrderIdsWithAction(symbol)</span><br><span class="line">		<span class="keyword">for</span> _, orderId := <span class="keyword">range</span> orderIds &#123;</span><br><span class="line">			mapOrder := cache.GetOrder(symbol, orderId)</span><br><span class="line">			order := engine.Order&#123;&#125;</span><br><span class="line">			order.FromMap(mapOrder)</span><br><span class="line">			engine.ChanMap[order.Symbol] &lt;- order</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单讲解下实现逻辑：</p>
<ol>
<li>从缓存读取所有 symbol，即程序重启之前，已经开启了撮合的所有交易标的的 symbol；</li>
<li>从缓存读取每个 symbol 对应的价格，这是程序重启前的最新成交价格；</li>
<li>启动每个 symbol 的撮合引擎；</li>
<li>从缓存读取每个 symbol 的所有订单，这些订单都是按时间顺序排列的；</li>
<li>按顺序将这些订单添加到对应 symbol 的订单通道里去。</li>
</ol>
<p>如果对这里面有些设计逻辑还不太明白的话，也没关系，后面讲到对应模块时会再详细说明。</p>
<p>main() 函数里，定义了我们之前所说的三个接口，分别交由对应的 handler 去处理具体的请求，之后就启动 http 服务了。</p>
<h2 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h2><p>因为只有几个接口，而且也很简单，因此，并没有引入第三方 web 框架，handler 都是用原生实现的。先来看看 <strong>OpenMatching</strong> 的完整实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> handler</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"matching/errcode"</span></span><br><span class="line">	<span class="string">"matching/process"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/shopspring/decimal"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> openMatchingParams <span class="keyword">struct</span> &#123;</span><br><span class="line">	Symbol <span class="keyword">string</span>          <span class="string">`json:"symbol"`</span></span><br><span class="line">	Price  decimal.Decimal <span class="string">`json:"price"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenMatching</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">	<span class="keyword">if</span> r.Method != http.MethodPost &#123;</span><br><span class="line">		w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	body, err := ioutil.ReadAll(r.Body)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		w.WriteHeader(http.StatusBadRequest)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> params openMatchingParams</span><br><span class="line">	<span class="keyword">if</span> err := json.Unmarshal(body, &amp;params); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		w.WriteHeader(http.StatusBadRequest)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> strings.TrimSpace(params.Symbol) == <span class="string">""</span> &#123;</span><br><span class="line">		w.Write(errcode.BlankSymbol.ToJson())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> params.Price.IsNegative() &#123;</span><br><span class="line">		w.Write(errcode.InvalidPrice.ToJson())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> e := process.NewEngine(params.Symbol, params.Price); !e.IsOK() &#123;</span><br><span class="line">		w.Write(e.ToJson())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	w.Write(errcode.OK.ToJson())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑非常简单，先判断是否为 POST 请求，再读取 body 里的数据并转为结构体对象，接着对参数做个简单的检查，最后就调用 <strong>process.NewEngine(symbol, price)</strong> 进入下一步的业务逻辑，如果结果返回是 OK，也返回 OK 作为请求的响应。</p>
<p>另外，用到了第三方的 <strong>decimal.Decimal</strong> 类型用来表示价格，整个程序都统一用 decimal 来表示浮点数和做精确计算。</p>
<p><strong>CloseMatching</strong> 和 <strong>HandleOrder</strong> 的实现逻辑也是同理，CloseMatching 最后会调用 <strong>process.CloseEngine(symbol)</strong> 函数进入下一步的处理，HandleOrder 最后则调用 <strong>process.Dispatch(order)</strong> 进入下一步。不过，Order 结构体是定义在 engine 包的，其结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Order <span class="keyword">struct</span> &#123;</span><br><span class="line">	Action    enum.OrderAction <span class="string">`json:"action"`</span></span><br><span class="line">	Symbol    <span class="keyword">string</span>           <span class="string">`json:"symbol"`</span></span><br><span class="line">	OrderId   <span class="keyword">string</span>           <span class="string">`json:"orderId"`</span></span><br><span class="line">	Side      enum.OrderSide   <span class="string">`json:"side"`</span></span><br><span class="line">	Type      enum.OrderType   <span class="string">`json:"type"`</span></span><br><span class="line">	Amount    decimal.Decimal  <span class="string">`json:"amount"`</span></span><br><span class="line">	Price     decimal.Decimal  <span class="string">`json:"price"`</span></span><br><span class="line">	Timestamp <span class="keyword">int64</span>            <span class="string">`json:"timestamp"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，其中的字段，除了有 Decimal 类型，还有 enum 包的几个类型，这几个其实是我们程序中自己定义的枚举类型。Golang 语言本身并没有提供和其他语言一样的 enum 关键字来定义枚举类型，所以一般采用<strong>类型定义+常量</strong>来模拟枚举类型，以 enum.OrderAction 为例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> OrderAction <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	ActionCreate OrderAction = <span class="string">"create"</span></span><br><span class="line">	ActionCancel OrderAction = <span class="string">"cancel"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>其他几个枚举类型也是这样定义的。</p>
<p>另外，为了方便转为字符串和检验参数是否有效，程序中还为每个枚举类型分别提供了两个函数，还是以 OrderAction 为例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o OrderAction)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> o &#123;</span><br><span class="line">	<span class="keyword">case</span> ActionCreate:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"create"</span></span><br><span class="line">	<span class="keyword">case</span> ActionCancel:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"cancel"</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"unknown"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o OrderAction)</span> <span class="title">Valid</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> o.String() == <span class="string">"unknown"</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他几个枚举类型也都定义了类似的两个函数，就不再贴代码了。</p>
<h2 id="process-包"><a href="#process-包" class="headerlink" title="process 包"></a>process 包</h2><p>来回顾下 process 包有哪些文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">└── process                  #</span><br><span class="line">    ├── close_engine.go      # 关闭引擎</span><br><span class="line">    ├── dispatch.go          # 分发订单</span><br><span class="line">    ├── init.go              # 初始化</span><br><span class="line">    └── new_engine.go        # 启动新引擎</span><br></pre></td></tr></table></figure>

<p>init.go 就一个初始化函数，上文已经讲了。其他三个文件分别定义了上文三个 handler 对应的下一步逻辑实现。</p>
<h3 id="启动新引擎"><a href="#启动新引擎" class="headerlink" title="启动新引擎"></a>启动新引擎</h3><p>先来看看 <strong>new_engine.go</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> process</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"matching/engine"</span></span><br><span class="line">	<span class="string">"matching/errcode"</span></span><br><span class="line">	<span class="string">"matching/middleware/cache"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/shopspring/decimal"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEngine</span><span class="params">(symbol <span class="keyword">string</span>, price decimal.Decimal)</span> *<span class="title">errcode</span>.<span class="title">Errcode</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> engine.ChanMap[symbol] != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errcode.EngineExist</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	engine.ChanMap[symbol] = <span class="built_in">make</span>(<span class="keyword">chan</span> engine.Order, <span class="number">100</span>)</span><br><span class="line">	<span class="keyword">go</span> engine.Run(symbol, price)</span><br><span class="line"></span><br><span class="line">	cache.SaveSymbol(symbol)</span><br><span class="line">	cache.SavePrice(symbol, price)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> errcode.OK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑也是比较简单的，第一步先判断 ChanMap[symbol] 是否为空，该 ChanMap 就是上文所说的引擎包初始化时用来保存订单通道的 map。如果 ChanMap[symbol] 不为空，说明该 symbol 的撮合引擎已经启动过了，那就返回错误。如果为空，那就初始化这个 symbol 的通道，从代码可知，ChanMap[symbol] 初始化为一个缓冲大小为 100 的订单通道。</p>
<p>接着，就调用 engine.Run() 启动一个 goroutine 了，这行代码即表示用 goroutine 的方式启动指定 symbol 的撮合引擎了。</p>
<p>然后，就将 symbol 和 price 都缓存起来了。</p>
<p>最后，返回 OK，搞定。</p>
<h3 id="2-分发订单"><a href="#2-分发订单" class="headerlink" title="2. 分发订单"></a>2. 分发订单</h3><p>接着，来看看 Dispatch 的实现又是怎样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dispatch</span><span class="params">(order engine.Order)</span> *<span class="title">errcode</span>.<span class="title">Errcode</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> engine.ChanMap[order.Symbol] == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errcode.EngineNotFound</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> order.Action == enum.ActionCreate &#123;</span><br><span class="line">		<span class="keyword">if</span> cache.OrderExist(order.Symbol, order.OrderId, order.Action.String()) &#123;</span><br><span class="line">			<span class="keyword">return</span> errcode.OrderExist</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !cache.OrderExist(order.Symbol, order.OrderId, enum.ActionCreate.String()) &#123;</span><br><span class="line">			<span class="keyword">return</span> errcode.OrderNotFound</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	order.Timestamp = time.Now().UnixNano() / <span class="number">1e3</span></span><br><span class="line">	cache.SaveOrder(order.ToMap())</span><br><span class="line">	engine.ChanMap[order.Symbol] &lt;- order</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> errcode.OK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一步，判断 ChanMap[order.Symbol] 是否为空，如果为空，表示引擎没开启，那就无法处理订单。</p>
<p>第二步，判断订单是否存在。如果是 create 订单，那缓存中就不应该查到订单，否则说明是重复请求。如果是 cancel 订单，那缓存中如果也查不到订单，那说明该订单已经全部成交或已经成功撤单过了。</p>
<p>第三步，将订单时间设为当前时间，时间单位是 100 纳秒，这可以保证时间戳长度刚好为 16 位，保存到 Redis 里就不会有精度失真的问题。这点后续文章讲到 Redis 详细设计时再说。</p>
<p>第四步，将订单缓存。</p>
<p>第五步，将订单传入对应的订单通道，对应引擎会从该通道中获取该订单进行处理。这一步就实现了订单的分发。</p>
<p>第六步，返回 OK。</p>
<h3 id="3-关闭引擎"><a href="#3-关闭引擎" class="headerlink" title="3. 关闭引擎"></a>3. 关闭引擎</h3><p>关闭引擎的实现就非常简单了，请看代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CloseEngine</span><span class="params">(symbol <span class="keyword">string</span>)</span> *<span class="title">errcode</span>.<span class="title">Errcode</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> engine.ChanMap[symbol] == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errcode.EngineNotFound</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>(engine.ChanMap[symbol])</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> errcode.OK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心代码就一行，将对应 symbol 的订单通道关闭。后续的处理其实是在引擎里完成的，待会我们再结合引擎里的代码来讲解这个设计。</p>
<h2 id="引擎入口的实现"><a href="#引擎入口的实现" class="headerlink" title="引擎入口的实现"></a>引擎入口的实现</h2><p>交易引擎 goroutine 的启动入口就是 <strong>engine.Run()</strong> 函数，来看看其代码实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(symbol <span class="keyword">string</span>, price decimal.Decimal)</span></span> &#123;</span><br><span class="line">	lastTradePrice := price</span><br><span class="line"></span><br><span class="line">	book := &amp;orderBook&#123;&#125;</span><br><span class="line">	book.init()</span><br><span class="line"></span><br><span class="line">	log.Info(<span class="string">"engine %s is running"</span>, symbol)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		order, ok := &lt;-ChanMap[symbol]</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			log.Info(<span class="string">"engine %s is closed"</span>, symbol)</span><br><span class="line">			<span class="built_in">delete</span>(ChanMap, symbol)</span><br><span class="line">			cache.Clear(symbol)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		log.Info(<span class="string">"engine %s receive an order: %s"</span>, symbol, order.ToJson())</span><br><span class="line">		<span class="keyword">switch</span> order.Action &#123;</span><br><span class="line">		<span class="keyword">case</span> enum.ActionCreate:</span><br><span class="line">			dealCreate(&amp;order, book, &amp;lastTradePrice)</span><br><span class="line">		<span class="keyword">case</span> enum.ActionCancel:</span><br><span class="line">			dealCancel(&amp;order, book)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一步，先定义和初始化了一个 book 变量，该变量就是用来保存整个<strong>交易委托账本</strong>。</p>
<p>接着，就是一个 <strong>for</strong> 循环了，for 循环里的第一行就是从对应 <strong>symbol</strong> 的订单通道里读取出一个订单，读取到订单时，<strong>order</strong> 变量就会有值，且 <strong>ok</strong> 变量为 <strong>true</strong>。如果通道里暂时没有订单，那就会阻塞在这行代码，直到从通道中获取到订单或通道已关闭的消息。</p>
<p>当通道被关闭之后，最后，从通道中读取到的 <strong>ok</strong> 变量则为 <strong>false</strong>，当然，在这之前，会先依序读取完通道里剩下的订单。当 ok 为 false 时，引擎里会执行两步操作：一是从 ChanMap 中删除该 symbol 对应的记录，二是清空该 symbol 对应的缓存数据。最后用 <strong>return</strong> 来退出 for 循环，这样，整个 Run() 函数就结束退出了，意味着该引擎也真正关闭了。</p>
<p>当每读取到一个订单，就会判断是下单还是撤单，然后进行相应的逻辑处理了。</p>
<p>我们先来看看撤单的逻辑，这个比较简单：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dealCancel</span><span class="params">(order *Order, book *orderBook)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ok <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">switch</span> order.Side &#123;</span><br><span class="line">	<span class="keyword">case</span> enum.SideBuy:</span><br><span class="line">		ok = book.removeBuyOrder(order)</span><br><span class="line">	<span class="keyword">case</span> enum.SideSell:</span><br><span class="line">		ok = book.removeSellOrder(order)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cache.RemoveOrder(order.ToMap())</span><br><span class="line">	mq.SendCancelResult(order.Symbol, order.OrderId, ok)</span><br><span class="line">	log.Info(<span class="string">"engine %s, order %s cancel result is %s"</span>, order.Symbol, order.OrderId, ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心就三个步骤：</p>
<ol>
<li>从委托账本中移除该订单；</li>
<li>从缓存中移除该订单；</li>
<li>发送撤单结果到 MQ。</li>
</ol>
<p>下单逻辑就比较复杂了，需要根据不同的订单类型做不同的逻辑处理，请看代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dealCreate</span><span class="params">(order *Order, book *orderBook, lastTradePrice *decimal.Decimal)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> order.Type &#123;</span><br><span class="line">	<span class="keyword">case</span> enum.TypeLimit:</span><br><span class="line">		dealLimit(order, book, lastTradePrice)</span><br><span class="line">	<span class="keyword">case</span> enum.TypeLimitIoc:</span><br><span class="line">		dealLimitIoc(order, book, lastTradePrice)</span><br><span class="line">	<span class="keyword">case</span> enum.TypeMarket:</span><br><span class="line">		dealMarket(order, book, lastTradePrice)</span><br><span class="line">	<span class="keyword">case</span> enum.TypeMarketTop5:</span><br><span class="line">		dealMarketTop5(order, book, lastTradePrice)</span><br><span class="line">	<span class="keyword">case</span> enum.TypeMarketTop10:</span><br><span class="line">		dealMarketTop10(order, book, lastTradePrice)</span><br><span class="line">	<span class="keyword">case</span> enum.TypeMarketOpponent:</span><br><span class="line">		dealMarketOpponent(order, book, lastTradePrice)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个类型再分买卖方向处理，以 dealLimit() 为例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dealLimit</span><span class="params">(order *Order, book *orderBook, lastTradePrice *decimal.Decimal)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> order.Side &#123;</span><br><span class="line">	<span class="keyword">case</span> enum.SideBuy:</span><br><span class="line">		dealBuyLimit(order, book, lastTradePrice)</span><br><span class="line">	<span class="keyword">case</span> enum.SideSell:</span><br><span class="line">		dealSellLimit(order, book, lastTradePrice)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，再来看看 dealBuyLimit() 的处理逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dealBuyLimit</span><span class="params">(order *Order, book *orderBook, lastTradePrice *decimal.Decimal)</span></span> &#123;</span><br><span class="line">LOOP:</span><br><span class="line">	headOrder := book.getHeadSellOrder()</span><br><span class="line">	<span class="keyword">if</span> headOrder == <span class="literal">nil</span> || order.Price.LessThan(headOrder.Price) &#123;</span><br><span class="line">		book.addBuyOrder(order)</span><br><span class="line">		log.Info(<span class="string">"engine %s, a order has added to the orderbook: %s"</span>, order.Symbol, order.ToJson())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		matchTrade(headOrder, order, book, lastTradePrice)</span><br><span class="line">		<span class="keyword">if</span> order.Amount.IsPositive() &#123;</span><br><span class="line">			<span class="keyword">goto</span> LOOP</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我来解析下这个处理流程：</p>
<ol>
<li>从委托账本中读取出卖单队列的头部订单；</li>
<li>如果头部订单为空，或新订单(买单)价格小于头部订单(卖单)，则无法匹配成交，那就将新订单添加到委托账本的买单队列中去；</li>
<li>如果头部订单不为空，且新订单(买单)价格大于等于头部订单(卖单)，则两个订单可以匹配成交，那就对这两个订单进行成交处理；</li>
<li>如果上一步的成交处理完之后，新订单的剩余数量还不为零，那就继续重复第一步。</li>
</ol>
<p>其中，匹配成交的记录会作为一条输出记录发送到 MQ。</p>
<p>对其他类型的处理也是类似的，就不再一一讲解了。</p>
<p>那引擎包的实现就先讲到这里，后续文章再聊其他部分的实现。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本小节主要还是通过代码梳理清楚整个数据流程，包括一些细节上的设计。理解了本文所列举的这些代码，也就对整个撮合服务的实现理解一大半了。</p>
<p>这次的思考题：ChanMap 保存的订单通道是否可以改用无缓冲的通道？用无缓冲的通道和用有缓冲的通道处理逻辑有哪些不同？两种方案各自的优缺点是什么？</p>
<hr>
<p>扫描以下二维码即可关注公众号（公众号名称：Keegan小钢）</p>
<img src="/post/matching/20191130/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/matching/20191127/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/matching/20191127/" class="post-title-link" itemprop="url">撮合引擎开发:解密黑箱流程</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-27 22:35:16" itemprop="dateCreated datePublished" datetime="2019-11-27T22:35:16+08:00">2019-11-27</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-03 10:41:11" itemprop="dateModified" datetime="2019-12-03T10:41:11+08:00">2019-12-03</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/matching/" itemprop="url" rel="index"><span itemprop="name">matching</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/matching/20191127"><strong>http://keeganlee.me/post/matching/20191127</strong></a><br>微信公众号：名称：Keegan小钢；微信号：keeganlee_me<br>写于2019-11-27</p>
<hr>
<p><a href="http://keeganlee.me/post/matching/20191117">撮合引擎开发：开篇</a><br><a href="http://keeganlee.me/post/matching/20191118">撮合引擎开发：MVP版本</a><br><a href="http://keeganlee.me/post/matching/20191119">撮合引擎开发：数据结构设计</a><br><a href="http://keeganlee.me/post/matching/20191121">撮合引擎开发：对接黑箱</a><br><a href="http://keeganlee.me/post/matching/20191127">撮合引擎开发：解密黑箱流程</a><br><a href="http://keeganlee.me/post/matching/20191130">撮合引擎开发：流程的代码实现</a><br><a href="http://keeganlee.me/post/matching/20191202">撮合引擎开发：缓存和MQ</a><br><a href="http://keeganlee.me/post/matching/20191203">撮合引擎开发：日志输出</a></p>
<hr>
<h2 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h2><p>前面的几篇文章已经陆续讲到了黑箱内部的一些设计，包括核心的软件结构、数据结构、目录结构等。而从本小节开始，我们将会更加深入，来解密黑箱内部的更多设计和实现细节。</p>
<p>解密黑箱的第一步就是要清楚其内部对数据的处理流程是怎样的。当我们要设计一个新系统的时候，也是一样的，第一步要梳理清楚业务流程和数据流向。对撮合引擎来说，就是要了解：<strong>从输入到输出，中间都经过了哪些处理流程</strong>。</p>
<p>前面的文章已经讲过，本撮合引擎定义了三种输入：<strong>开启撮合、处理订单、关闭撮合</strong>。后面就分别来看看这三种输入背后的流程。</p>
<h2 id="开启撮合"><a href="#开启撮合" class="headerlink" title="开启撮合"></a>开启撮合</h2><p>开启撮合即是开启某个交易标的（交易对）的撮合引擎，未开启撮合的交易标的是无法处理订单的，而已经开启了撮合的交易标的也无法再次开启，不然就会出现同时有两个引擎处理同个交易标的的订单，这是不合理的，同个交易标的的订单只能由一个引擎串行来处理。</p>
<p>为什么不能并行呢？如果同一交易标的的订单可以用多个引擎并行处理的话，那至少会产生几个问题：</p>
<ol>
<li><strong>成交价以哪个为准？</strong>理论上，每一时刻只能有一个成交价，那并行之后，就会产生多个成交价，那成交价就难以确定了。</li>
<li><strong>如何维护统一的委托账本？</strong>理论上，每个交易标的有一本保存了所有委托单的委托账本，那并行之后，如何在多个引擎之间维护这个统一的账本呢？如果用数据库统一维护，那无疑会减低撮合性能；如果分为多个子账本，那就很难保证价格优先、时间优先的原则。</li>
</ol>
<p>以上这两个问题都不好解决，因此，只能先对所有订单进行定序，然后丢入引擎进行串行处理。</p>
<p>说到定序，自然就需要一个定序队列，因此开启撮合时需要初始化对应交易标的的订单定序队列。初始化好定序队列后，就可以真正启动对应交易标的的引擎了。在 Go 程序中，每个交易标的的引擎是以独立 goroutine 运行的；而在其他语言，比如 Java，则是以独立线程来运行。</p>
<p>引擎启动之后，需要先初始化交易委托账本，用来保存委托单。之后就等待定序队列有订单的时候逐个取出来处理了。</p>
<p>另外，再考虑一个场景，撮合程序重启时会发生什么？对于开启了撮合的交易标的，重启后是否需要恢复呢？需要的话，那如何恢复呢？最简单的方案当然是使用缓存，用 Redis 将开启了撮合的交易标的缓存起来，重启时从 Redis 加载并重新开启这些交易标的即可。</p>
<p>因此，触发开启撮合的场景其实有两个，一是接口的主动调用触发的，二是程序重启后从 Redis 缓存自动加载启动的。</p>
<p>最后，开启撮合的结果是同步返回的，因此，它没有异步的输出。</p>
<p>总结下，开启撮合的内部流程大致如下：</p>
<img src="/post/matching/20191127/开启撮合流程图.png">

<h2 id="处理订单"><a href="#处理订单" class="headerlink" title="处理订单"></a>处理订单</h2><p>开启撮合之后，就可以接收处理订单的输入了。撮合程序接收到处理订单的请求时，第一步需要做一些检查，包括每个参数是否有效、订单是否重复或存在、对应交易标的的引擎是否已经开启等。通过了检查之后，就可以将整个订单缓存到 Redis，接着添加到对应交易标的的定序队列中去，等待对应交易标的的引擎消费它进行撮合处理。这个流程如下图：</p>
<img src="/post/matching/20191127/处理订单接口流程.png">

<p>当订单成功添加到定序队列中后，接口就可以同步返回成功的响应结果了。后续的处理结果则是通过异步的 MQ 进行输出了。交易标的的引擎接收到订单后，根据不同情况会产生不同的输出结果。</p>
<p>我们知道，处理订单有两种 <strong>action</strong>：<strong>下单</strong>和<strong>撤单</strong>。撤单的业务逻辑很简单，就是从交易委托账本中查询该订单是否存在，若存在则从委托账本中删除该订单，然后输出撤单成功的撤单结果；若不存在则输出撤单失败的撤单结果。下单的业务逻辑则比较复杂，还要根据不同的订单类型作不同处理。写作此文时的撮合程序版本支持 6 种不同的 <strong>type</strong>，包括两种<strong>限价</strong>类型和四种<strong>市价</strong>类型。下面就来分别讲解不同订单类型的下单在不同条件下会有怎样的结果。</p>
<ul>
<li><strong>limit</strong>：普通限价。当委托账本里存在能与该订单匹配成交的委托单时，则可能生成一条或多条成交记录，每条成交记录都将产生异步输出；当委托账本里没有可匹配的委托单时，则将该订单(全部数量或剩余数量)添加到委托账本中，这时不会产生任何输出。</li>
<li><strong>limit-ioc</strong>：IOC限价-即时成交剩余撤销。当委托账本里存在能与该订单匹配成交的委托单时，则可能生成一条或多条成交记录，每条成交记录都将产生异步输出；当委托账本里没有可匹配的委托单时，则将该订单(全部或剩余数量)进行撤单处理，这时会产生一条撤单成功的输出。</li>
<li><strong>market</strong>：默认市价-即时成交剩余撤销。和 IOC 限价一样，当委托账本里与该订单相反方向的订单队列里（也称对手方）存在委托单时，则可能生成一条或多条成交记录，每条成交记录都将产生异步输出；当委托账本里对手方没有委托单时，则将该订单(全部或剩余数量)进行撤单处理，这时会产生一条撤单成功的输出。与 IOC 限价不同的在于：IOC 限价订单是由用户指定了委托价格的，而市价则无需指定委托价格，会直接与对手方的头部委托单成交，直到该订单已全部成交或对手方再无委托单为止。</li>
<li><strong>market-top5</strong>：市价-最优五档即时成交剩余撤销。market 可以与对手方所有价格档位的订单成交，但 market-top5 最多只会和对手方的五个价格档位内的订单成交，超出五档外的订单将不会成交。剩余未成交的都将做撤单处理并产生一条撤单成功的输出。</li>
<li><strong>market-top10</strong>：市价-最优十档即时成交剩余撤销。最多只会和对手方的十个价格档位内的订单成交。</li>
<li><strong>market-opponent</strong>：市价-对手方最优价。如果对手方没有订单，则直接对该订单进行撤单处理并产生一条撤单成功的输出；如果对手方有订单，那最多只会成交一档，如果还剩有未成交的量，那将以对手方一档的价格转为限价单并添加到委托账本中，此时不会产生输出。</li>
</ul>
<p>用图可表示如下：</p>
<img src="/post/matching/20191127/引擎处理订单流程.png">

<p>另外，每个处理订单的请求——不管是下单还是撤单，也都会缓存到 Redis 里，产生变更时还会更新缓存。这样，程序重启后就可以恢复订单了。</p>
<h2 id="关闭撮合"><a href="#关闭撮合" class="headerlink" title="关闭撮合"></a>关闭撮合</h2><p>当某个交易标的准备下架、或取消交易、或暂停交易时，都需要关闭引擎。关闭引擎之前，上游服务最好先停止调用处理订单的接口，不然可能会出现一些非预期的错误，虽然程序已经做了容错处理。</p>
<p>关闭引擎时，同样也有些简单的判断，比如判断该交易标的的引擎是否已经开启，未开启的引擎自然无法关闭。</p>
<p>关闭引擎时，如果定序队列中还存在未处理的订单，那应该等这些订单处理完才真正关闭引擎。</p>
<p>最后，也要清除缓存，将该交易标的的所有订单都从缓存中清除。</p>
<p>关闭引擎的结果也是同步返回的，所有也没有异步的输出。</p>
<p>流程图也比较简答：</p>
<img src="/post/matching/20191127/关闭引擎.png">

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本小节讲解了撮合黑箱内部的核心业务流程，包括开启撮合、处理订单、关闭撮合三个输入各自的内部逻辑。理解了这些流程之后，下一篇我们开始来讲代码实现。</p>
<p>惯例留几个思考题：如果关闭撮合的同时还有下单的并发请求，是否容易产生问题？如果有，哪里会产生？什么问题？能如何解决？</p>
<hr>
<p>扫描以下二维码即可关注公众号（公众号名称：Keegan小钢）</p>
<img src="/post/matching/20191127/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/matching/20191121/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/matching/20191121/" class="post-title-link" itemprop="url">撮合引擎开发:对接黑箱</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-21 22:41:26" itemprop="dateCreated datePublished" datetime="2019-11-21T22:41:26+08:00">2019-11-21</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-03 10:40:45" itemprop="dateModified" datetime="2019-12-03T10:40:45+08:00">2019-12-03</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/matching/" itemprop="url" rel="index"><span itemprop="name">matching</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/matching/20191121"><strong>http://keeganlee.me/post/matching/20191121</strong></a><br>微信公众号：名称：Keegan小钢；微信号：keeganlee_me<br>写于2019-11-21</p>
<hr>
<p><a href="http://keeganlee.me/post/matching/20191117">撮合引擎开发：开篇</a><br><a href="http://keeganlee.me/post/matching/20191118">撮合引擎开发：MVP版本</a><br><a href="http://keeganlee.me/post/matching/20191119">撮合引擎开发：数据结构设计</a><br><a href="http://keeganlee.me/post/matching/20191121">撮合引擎开发：对接黑箱</a><br><a href="http://keeganlee.me/post/matching/20191127">撮合引擎开发：解密黑箱流程</a><br><a href="http://keeganlee.me/post/matching/20191130">撮合引擎开发：流程的代码实现</a><br><a href="http://keeganlee.me/post/matching/20191202">撮合引擎开发：缓存和MQ</a><br><a href="http://keeganlee.me/post/matching/20191203">撮合引擎开发：日志输出</a></p>
<hr>
<h2 id="黑箱引擎"><a href="#黑箱引擎" class="headerlink" title="黑箱引擎"></a>黑箱引擎</h2><p>我们的撮合引擎作为一个相对通用的组件，其实就是一个黑箱，如果想将它应用到各种不同的交易系统，只要有标准的输入和输出，对接是很容易的。</p>
<p>写作此文时的撮合引擎为 1.3 版本，我将其编译构建成可在 Linux amd64 环境运行的可执行文件，并与依赖的配置文件一起压缩成一个压缩包 <strong>matching.zip</strong>。这就成为一个黑箱引擎了。</p>
<p>不过，该黑箱引擎除了对运行系统有要求，还对 Redis 有要求。由于使用了 Redis 的新版 MQ 功能，即 stream 数据结构，要求 Redis 至少是 5.0 版本。</p>
<p>其实，我也可以编译构建成其他系统环境的可执行文件，如 Windows 或 Mac 系统。但作为一款商业软件以及对性能的一些要求，运行在 Linux 环境更合适。</p>
<p>后面，我们就来看看，如果要将这个黑箱引擎应用到自己的交易系统中，如何对接？</p>
<h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><p>安装部署的系统环境需是 Linux amd64 的，另外，如果要让撮合性能更快，建议 Redis 与撮合引擎可以使用同一服务器，这可以减少不同服务器之前的传输耗时。</p>
<p>按照以下步骤操作就可以将撮合引擎安装部署到运行环境了：</p>
<ol>
<li>将 <strong>matching.zip</strong> 压缩包上传到运行环境；</li>
<li>在运行环境解压 <strong>matching.zip</strong> 压缩包，解压后有一个可执行文件和一个文件夹：<ul>
<li><strong>matching</strong>：这是撮合引擎程序的可执行文件</li>
<li><strong>conf</strong>：存放配置文件的目录，里面就一个配置文件 <strong>config.yaml</strong></li>
</ul>
</li>
<li>修改配置文件为自己想要的配置值：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="string">:9466</span>  <span class="string">//撮合引擎程序启动监听的端口</span></span><br><span class="line"><span class="attr">log:</span>                 <span class="string">//输出日志配置</span></span><br><span class="line"><span class="attr">  fileDir:</span> <span class="string">logs</span>      <span class="string">//输出日志存放的目录</span></span><br><span class="line"><span class="attr">  fileName:</span> <span class="string">matching</span> <span class="string">//日志文件名，会按日期分割</span></span><br><span class="line"><span class="attr">  prefix:</span>            <span class="string">//日志消息前缀</span></span><br><span class="line"><span class="attr">  level:</span> <span class="string">debug</span>       <span class="string">//日志级别，由低到高为：debug、info、warn、error</span></span><br><span class="line"><span class="attr">redis:</span></span><br><span class="line"><span class="attr">  addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379</span>  <span class="string">//Redis地址</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>如果使用默认配置，请确认运行环境本地已安装并启动了Redis并运行在6379端口；</li>
<li>如果不用默认配置，依然需要确认Redis能正确连接；</li>
<li>运行以下命令，后台启动撮合引擎程序：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./matching &amp;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>运行以下命令，检查程序是否启动成功：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux|grep matching</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>程序启动成功后，会在配置的日志目录生成日志文件，默认为与 <strong>matching</strong> 可执行文件同目录下的 logs/matching.log；</li>
<li>至此，撮合引擎程序安装部署成功。</li>
</ol>
<h2 id="对接输入"><a href="#对接输入" class="headerlink" title="对接输入"></a>对接输入</h2><p>接入撮合引擎只需要对接三个 HTTP 接口，接口统一采用 POST 方法，参数统一用 json 格式，传 body。</p>
<h3 id="1-开启撮合"><a href="#1-开启撮合" class="headerlink" title="1. 开启撮合"></a>1. 开启撮合</h3><p>开启指定交易标的（交易对）的撮合功能。</p>
<h4 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h4><ul>
<li>POST  <em>/openMatching</em></li>
</ul>
<h4 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h4><ul>
<li><strong>symbol</strong>：字符串类型，必传字段，交易标的(交易对)的标识，如 BTC_USDT</li>
<li><strong>price</strong>：数字类型，非必传字段，默认为 0，开盘价</li>
</ul>
<h4 id="请求示例"><a href="#请求示例" class="headerlink" title="请求示例"></a>请求示例</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST  /openMatching</span><br><span class="line">Body：</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"symbol"</span>: <span class="string">"BTC_USDT"</span>,</span><br><span class="line">  <span class="attr">"price"</span>: <span class="number">8219.85</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"code"</span>:<span class="number">0</span>,<span class="attr">"msg"</span>:<span class="string">"OK"</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-关闭撮合"><a href="#2-关闭撮合" class="headerlink" title="2. 关闭撮合"></a>2. 关闭撮合</h3><p>关闭指定交易标的（交易对）的撮合功能。</p>
<h4 id="HTTP请求-1"><a href="#HTTP请求-1" class="headerlink" title="HTTP请求"></a>HTTP请求</h4><ul>
<li>POST  <em>/closeMatching</em></li>
</ul>
<h4 id="请求参数-1"><a href="#请求参数-1" class="headerlink" title="请求参数"></a>请求参数</h4><ul>
<li><strong>symbol</strong>：字符串类型，必传字段，交易标的(交易对)的标识，如 BTC_USDT</li>
</ul>
<h4 id="请求示例-1"><a href="#请求示例-1" class="headerlink" title="请求示例"></a>请求示例</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST  /closeMatching</span><br><span class="line">Body：</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"symbol"</span>: <span class="string">"BTC_USDT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="响应数据-1"><a href="#响应数据-1" class="headerlink" title="响应数据"></a>响应数据</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"code"</span>:<span class="number">0</span>,<span class="attr">"msg"</span>:<span class="string">"OK"</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-处理订单"><a href="#3-处理订单" class="headerlink" title="3. 处理订单"></a>3. 处理订单</h3><p>接收下单和撤单请求。</p>
<h4 id="HTTP请求-2"><a href="#HTTP请求-2" class="headerlink" title="HTTP请求"></a>HTTP请求</h4><ul>
<li>POST  <em>/handleOrder</em></li>
</ul>
<h4 id="请求参数-2"><a href="#请求参数-2" class="headerlink" title="请求参数"></a>请求参数</h4><ul>
<li><strong>symbol</strong>：字符串类型，必传字段，交易标的(交易对)的标识，如 BTC_USDT</li>
<li><strong>action</strong>：字符串类型，必传字段，订单动作，下单=create，撤单=cancel</li>
<li><strong>orderId</strong>：字符串类型，必传字段，订单ID</li>
<li><strong>side</strong>：字符串类型，必传字段，买卖方向，买入=buy，卖出=sell</li>
<li><strong>type</strong>：字符串类型，必传字段，订单类型，包括：limit、limit-ioc、market、market-top5、market-top10、market-opponent，说明见下文</li>
<li><strong>amount</strong>：数字类型，非必传字段，默认为 0，订单交易量，下单时必传，撤单时可不传</li>
<li><strong>price</strong>：数字类型，非必传字段，默认为 0，委托价格，订单类型为市价时可不传</li>
</ul>
<p>订单类型说明：</p>
<ul>
<li><strong>limit</strong>：普通限价</li>
<li><strong>limit-ioc</strong>：IOC限价-即时成交剩余撤销</li>
<li><strong>market</strong>：默认市价-即时成交剩余撤销</li>
<li><strong>market-top5</strong>：市价-最优五档即时成交剩余撤销</li>
<li><strong>market-top10</strong>：市价-最优十档即时成交剩余撤销</li>
<li><strong>market-opponent</strong>：市价-对手方最优价</li>
</ul>
<h4 id="请求示例-2"><a href="#请求示例-2" class="headerlink" title="请求示例"></a>请求示例</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST  /handleOrder</span><br><span class="line">Body：</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"symbol"</span>: <span class="string">"BTC_USDT"</span>,</span><br><span class="line">  <span class="attr">"action"</span>: <span class="string">"create"</span>,</span><br><span class="line">  <span class="attr">"orderId"</span>: <span class="string">"a0001"</span>,</span><br><span class="line">  <span class="attr">"side"</span>: <span class="string">"buy"</span>,</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"limit"</span>,</span><br><span class="line">  <span class="attr">"amount"</span>: <span class="number">0.012</span>,</span><br><span class="line">  <span class="attr">"price"</span>: <span class="number">8230.74</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="响应数据-2"><a href="#响应数据-2" class="headerlink" title="响应数据"></a>响应数据</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"code"</span>:<span class="number">0</span>,<span class="attr">"msg"</span>:<span class="string">"OK"</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对接输出"><a href="#对接输出" class="headerlink" title="对接输出"></a>对接输出</h2><p>撮合引擎有两种输出：<strong>撤单结果</strong>和<strong>成交记录</strong>。统一用 MQ 的方式进行输入，MQ 是保存为 Redis 5.0 版本之后引入的新数据结构 Stream 类型。每个消息队列其实就是一条 stream，关于 stream 的具体用法我就不展开了，大伙自行去网上搜索学习即可。</p>
<h3 id="1-撤单结果"><a href="#1-撤单结果" class="headerlink" title="1. 撤单结果"></a>1. 撤单结果</h3><p>每个不同的 symbol 设置一个 stream，其 key 的格式为：<strong>matching:cancelresults:{symbol}</strong>，value 包含两个字段：</p>
<ul>
<li><strong>orderId</strong>：订单号</li>
<li><strong>ok</strong>：1=成功；0=失败</li>
</ul>
<h3 id="2-成交记录"><a href="#2-成交记录" class="headerlink" title="2. 成交记录"></a>2. 成交记录</h3><p>每个不同的 symbol 也设置一个 MQ，key 的格式为：<strong>matching:trades:{symbol}</strong>，value 包含的字段如下：</p>
<ul>
<li><strong>makerId</strong>：maker订单ID</li>
<li><strong>takerId</strong>：taker订单ID</li>
<li><strong>takerSide</strong>：taker买卖方向</li>
<li><strong>amount</strong>：成交数量</li>
<li><strong>price</strong>：成交价格</li>
<li><strong>timestamp</strong>：成交时间</li>
</ul>
<p>下游服务就可以通过订阅监听这两种输出，之后做后续的处理，比如 K 线行情服务订阅监听成交记录来生成 K 线数据。等撮合引擎完成之后，我下一个要开发的组件就是 K 线行情服务。</p>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>最后，先给大伙看看我们这个黑箱内部的整个 Go 项目的文件目录结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">├── conf                     # 配置文件存放目录，在1.1版本时增加</span><br><span class="line">│   ├── config.yaml          # 配置文件，在1.1版本时增加</span><br><span class="line">├── engine                   # 引擎包</span><br><span class="line">│   ├── init.go              # 初始化</span><br><span class="line">│   ├── order.go             # 委托单</span><br><span class="line">│   ├── order_book.go        # 交易委托账本</span><br><span class="line">│   ├── order_queue.go       # 订单队列</span><br><span class="line">│   ├── run.go               # 具体交易对的撮合引擎启动入口</span><br><span class="line">│   └── trade.go             # 成交记录</span><br><span class="line">├── enum                     # 枚举类型的包</span><br><span class="line">│   ├── order_action.go      # 订单行为，create为下单，cancel为撤单</span><br><span class="line">│   ├── order_side.go        # 买卖方向，buy为买入，sell为卖出</span><br><span class="line">│   ├── order_type.go        # 订单类型，MVP版本(1.0版本)只支持limit，1.3版本共支持7种类型 </span><br><span class="line">│   └── sort_direction.go    # 排序方向，asc为升序，desc为降序</span><br><span class="line">├── errcode                  #</span><br><span class="line">│   ├── code.go              # 定义了各种不同的错误码</span><br><span class="line">│   └── errcode.go           # 错误码的数据结构，包括code和msg两个字段</span><br><span class="line">├── handler                  #</span><br><span class="line">│   ├── close_matching.go    # 接收关闭撮合的请求</span><br><span class="line">│   ├── handle_order.go      # 接收处理订单的请求</span><br><span class="line">│   └── open_matching.go     # 接收开启撮合的请求</span><br><span class="line">├── log                      # 日志包，在1.2版本增加</span><br><span class="line">│   ├── log.go               # 日志输出，在1.2版本增加</span><br><span class="line">├── main.go                  # Go程序唯一入口</span><br><span class="line">├── middleware               # 中间件的包</span><br><span class="line">│   ├── cache                # 缓存包</span><br><span class="line">│   │   └── cache.go         # 缓存操作</span><br><span class="line">│   ├── mq                   # 消息队列包</span><br><span class="line">│   │   └── mq.go            # MQ操作</span><br><span class="line">│   └── redis.go             # 主要做Redis初始化操作</span><br><span class="line">└── process                  #</span><br><span class="line">    ├── close_engine.go      # 关闭引擎</span><br><span class="line">    ├── dispatch.go          # 分发订单</span><br><span class="line">    ├── init.go              # 初始化</span><br><span class="line">    └── new_engine.go        # 启动新引擎</span><br></pre></td></tr></table></figure>

<p>包括 main 包，整个项目总共划分为了 10 个包和 1 个配置文件目录：</p>
<ul>
<li><strong>conf</strong>：存放配置文件的目录。</li>
<li><strong>main</strong>：main 包只有一个 main.go 文件，定义了程序入口函数。</li>
<li><strong>enum</strong>：枚举包实现了几个枚举类型的数据结构，包括订单行为、买卖方向、订单类型和排序方向。</li>
<li><strong>errcode</strong>：存放错误码的包，errcode.go 定义了错误码的数据结构，有 code 和 msg 两个属性；code.go 则定义了一些错误码对象。</li>
<li><strong>handler</strong>：接收 HTTP 请求的函数都放在这个包里，目前也就只有三个 handler 函数。</li>
<li><strong>process</strong>：启动、关闭引擎和分发订单的处理过程都在这个包里，包里还维护着不同交易对的订单通道，用来分发不同交易对的订单。</li>
<li><strong>engine</strong>：引擎包，包含了委托单、交易委托账本、订单队列、成交记录这几个核心的数据结构，以及用于处理交易对撮合的入口函数。</li>
<li><strong>middleware</strong>：存放中间件的包，目前只用到了 Redis 一个中间件。</li>
<li><strong>cache</strong>：缓存包，只有一个 cache.go 文件，缓存操作都在这个文件里定义。</li>
<li><strong>mq</strong>：消息队列包，也只有一个 mq.go 文件，消息的发送就定义在这里。</li>
<li><strong>log</strong>：日志包，实现了日志消息按日期分割并输出到文件。</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本节我们了解到撮合引擎作为一个通用组件，有标准的输入和输出，而且这输入和输出都非常简单。也开始给大家展示了黑箱内部的文件目录结构，开始探究黑箱的内部逻辑，后续章节将陆续揭露这些内部实现逻辑。</p>
<p>本节预留的思考题：揣测下为什么我要将下单和撤单定义到同一个接口？而不是分开两个接口？分两个接口和用一个接口各有何优劣？</p>
<hr>
<p>扫描以下二维码即可关注公众号（公众号名称：Keegan小钢）</p>
<img src="/post/matching/20191121/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/matching/20191119/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/matching/20191119/" class="post-title-link" itemprop="url">撮合引擎开发:数据结构设计</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-19 20:21:14" itemprop="dateCreated datePublished" datetime="2019-11-19T20:21:14+08:00">2019-11-19</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-03 10:42:39" itemprop="dateModified" datetime="2019-12-03T10:42:39+08:00">2019-12-03</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/matching/" itemprop="url" rel="index"><span itemprop="name">matching</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/matching/20191119"><strong>http://keeganlee.me/post/matching/20191119</strong></a><br>微信公众号：名称：Keegan小钢；微信号：keeganlee_me<br>写于2019-11-19</p>
<hr>
<p><a href="http://keeganlee.me/post/matching/20191117">撮合引擎开发：开篇</a><br><a href="http://keeganlee.me/post/matching/20191118">撮合引擎开发：MVP版本</a><br><a href="http://keeganlee.me/post/matching/20191119">撮合引擎开发：数据结构设计</a><br><a href="http://keeganlee.me/post/matching/20191121">撮合引擎开发：对接黑箱</a><br><a href="http://keeganlee.me/post/matching/20191127">撮合引擎开发：解密黑箱流程</a><br><a href="http://keeganlee.me/post/matching/20191130">撮合引擎开发：流程的代码实现</a><br><a href="http://keeganlee.me/post/matching/20191202">撮合引擎开发：缓存和MQ</a><br><a href="http://keeganlee.me/post/matching/20191203">撮合引擎开发：日志输出</a></p>
<hr>
<h2 id="交易委托账本"><a href="#交易委托账本" class="headerlink" title="交易委托账本"></a>交易委托账本</h2><p><strong>交易委托账本(OrderBook)</strong>是整个撮合引擎里最核心也是最复杂的数据结构，每个交易对都需要维护一份交易委托账本，账本里保存着指定交易对所有待撮合的委托单。每份账本都有两个队列，一个卖单队列和一个买单队列，两个队列都需要按照<strong>价格优先、时间优先</strong>的原则进行排序。</p>
<p>所谓价格优先、时间优先，即是说：卖单队列的委托单是按价格由低到高排序，买单队列则相反，按价格由高到低排序；相同价格的委托单，则是按下单时间的先后来排序。</p>
<img src="/post/matching/20191119/orderbook.png">

<p>如上图，每个小方格表示一个委托单，标 <strong>H</strong> 的是排在头部的委托单，<strong>N</strong>则是与 H 同价格但下单时间上排在 H 后面的委托单，<strong>S</strong>则是下一档位价格的第一个委托单。可以从图中明显看出，横向上，委托单是按时间排序的，竖向上，又是按价格排序的。</p>
<p>撮合的时候，都是先取出 <strong>H</strong> 委托单与新委托单进行匹配。如果新委托单是<strong>买单</strong>，则获取<strong>卖单队列</strong>的 H 单出来匹配；如果新委托单是<strong>卖单</strong>，则获取<strong>买单队列</strong>的 H 单。如果 <strong>H</strong> 单全部匹配成交了，那标识为 <strong>N</strong> 的委托单就变成了新的 <strong>H</strong> 单。如果第一排的全部委托单都匹配完了，那就 <strong>S</strong> 单会变成新的 <strong>H</strong> 单。</p>
<p>交易委托账本可支持一些操作方法，包括初始化、增加买卖委托单、移除买卖委托单、获取头部委托单等。交易委托账本的类图大概如下：</p>
<img src="/post/matching/20191119/class-orderbook.png">

<p>其中，<strong>getHead</strong> 和 <strong>popHead</strong> 方法的区别是：get 只读头部委托单但不会移除它，而 pop 会将头部委托单从队列中移除。</p>
<h2 id="订单队列"><a href="#订单队列" class="headerlink" title="订单队列"></a>订单队列</h2><p>买单队列和卖单队列可以设计为使用统一的订单队列类型，两者只有价格排序方向不同，那订单队列就可以用一个属性来表示排序方向。队列里的所有订单可以采用二维数组或二维链表来保存，考虑到主要操作是插入和删除，用链表比用数组效率更高。如果想让操作效率更高，那就需要使用更复杂的数据结构了，比如再结合跳表。目前版本为了简单，采用简单的二维链表即可。</p>
<p>使用二维链表的话，那链表中的每个元素保存的就是横向上按时间排序的订单链表，这些订单链表又组成了竖向上按价格排序的链表。</p>
<p>另外，还可以保存一个 Map，将价格作为 Key，将同价格的订单链表作为 Value，这样就能加快同价格订单的查询。</p>
<p>订单队列可支持的操作方法也很简单，包括初始化、新增订单、移除订单、获取头部订单等。其类图大概如下：</p>
<img src="/post/matching/20191119/class-orderqueue.png">

<p><strong>sortBy</strong> 指定价格排序的方向，<strong>parentList **保存整个二维链表，第一维以价格排序，第二维以时间排序，</strong>elementMap** 则是 Key 为价格、Value 为第二维订单链表的键值对。</p>
<h2 id="委托单"><a href="#委托单" class="headerlink" title="委托单"></a>委托单</h2><p>委托单则是撮合引擎里最基本的数据结构了，其数据主要是从上游服务传输过来的，其类图大概如下：</p>
<img src="/post/matching/20191119/class-order.png">

<p><strong>action</strong> 声明对委托单要进行哪种操作，我们只需支持两种操作：<strong>下单(create)</strong>和<strong>撤单(cancel)</strong>。<strong>symbol</strong> 指定该委托单所属的交易对，<strong>orderId</strong> 是该委托单的唯一标识，<strong>side</strong> 指明是<strong>买入(buy)</strong>还是<strong>卖出(sell)</strong>。<strong>type **表示交易类型，即</strong>限价交易(limit)<strong>或</strong>市价交易(market)<strong>等，我们的 MVP 版本只支持限价交易。</strong>amount <strong>是购买数量，</strong>price** 是购买价格，<strong>timestamp</strong> 则是订单时间。</p>
<p><strong>toJson() *<em>和 *</em>fromJson()</strong> 方法是为了支持订单数据传输时的序列化和反序列化。</p>
<h2 id="成交记录"><a href="#成交记录" class="headerlink" title="成交记录"></a>成交记录</h2><p>撮合成交的委托单就会生成对应的成交记录，成交记录需要发布到 MQ 给下游服务消费。成交记录的数据结构如下图：</p>
<img src="/post/matching/20191119/class-trade.png">

<p><strong>maker</strong> 指挂单，是本来挂在交易委托账本里的订单，而 <strong>taker</strong> 则是吃单，是指吃掉 maker 的订单。<strong>makerId *<em>和 *</em>takerId</strong> 就是挂单和吃单的订单 ID。<strong>takerSide</strong> 就是吃单的买卖方向，我们在行情软件里看到的成交记录会有不同颜色，就是由这个 takerSide 决定的。<strong>amount **就是成交数量，</strong>price** 指成交价格，*<em>timestamp *</em>是成交时间。</p>
<h2 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h2><p>我们需要用 Redis 缓存委托单数据和撮合中的交易对数据，主要有两个作用，一是可以对请求做去重处理，二是程序重启后可以恢复数据。</p>
<p>由于网络中断或延迟，或其他异常情况，上游服务有可能会重复发送相同请求给到撮合引擎，因此，程序是需要做去重处理的，有了数据缓存就可以解决去重问题了。另外，由于我们采用的是内存撮合，撮合时的数据都是直接保存在程序内存里的，一旦程序退出了，那所有数据也都消失了，重启后就需要从其他地方重新加载数据，采用Redis缓存就可以很快速地缓存数据和加载数据。</p>
<p>开启一个交易对引擎时需要将交易对缓存，关闭时则从缓存中删除，保证缓存的都是运行中的交易对，当重启时，就可以重新启动这些交易对的撮合引擎了。需要缓存的交易对数据包括两个：<strong>symbol</strong> 和 <strong>price</strong>，即标识和价格。关于价格，每次产生新的成交记录时，价格也需要同步更新，因此价格的更新会非常频繁。而标识基本无需更新，因此两者最好分开缓存。</p>
<p>所有交易对的 symbol 可以统一缓存到一个 set 里。我们可以将 key 值设置为 <strong>matching:symbols</strong>，用 Redis 的 <strong>sadd</strong> 和 <strong>srem</strong> 命令将不同的 symbol 缓存到该 key 值里或从 key 中删除。而 price 则可以保存为 string 类型，为不同交易对的价格设置不同的 key，key 值可以设置为 <strong>matching:price:{symbol}</strong>，{symbol} 为具体交易对的 symbol 值。</p>
<p>每个委托单也需要缓存和更新，为了能够从缓存中最快地读取和更新委托单数据，最好为每个委托单都设置一个单独的 key，key 值可以设置为 <strong>matching:order:{symbol}:{orderId}:{action}</strong>，而 value 值建议设置为 hash 类型，因为 hash 类型特别适合存储结构化的对象。</p>
<p>交易对和委托单数据都缓存了，就能够解决去重问题和程序重启后重新启动各交易对的撮合引擎了，但其实还有一个问题，撮合引擎里的交易委托账本如何恢复？该问题先留给大伙去思考，后续章节我再来讲解我的方案。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>撮合引擎里涉及到的数据结构其实并不多，最复杂的也只有交易委托账本，其设计还会直接关系到撮合的速度。Redis 缓存的设计也有些学问在里面，设计得不好也一样会影响整体的撮合性能。本小节完成了数据结构的设计，下一小节我们就开始深入到代码实现。</p>
<p>最后，请抽时间研究下遗留的思考题：撮合引擎里的交易委托账本如何恢复？</p>
<hr>
<p>扫描以下二维码即可关注公众号（公众号名称：Keegan小钢）</p>
<img src="/post/matching/20191119/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/matching/20191118/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/matching/20191118/" class="post-title-link" itemprop="url">撮合引擎开发:MVP版本</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-18 20:21:14" itemprop="dateCreated datePublished" datetime="2019-11-18T20:21:14+08:00">2019-11-18</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-03 10:42:51" itemprop="dateModified" datetime="2019-12-03T10:42:51+08:00">2019-12-03</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/matching/" itemprop="url" rel="index"><span itemprop="name">matching</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/matching/20191118"><strong>http://keeganlee.me/post/matching/20191118</strong></a><br>微信公众号：名称：Keegan小钢；微信号：keeganlee_me<br>写于2019-11-18</p>
<hr>
<p><a href="http://keeganlee.me/post/matching/20191117">撮合引擎开发：开篇</a><br><a href="http://keeganlee.me/post/matching/20191118">撮合引擎开发：MVP版本</a><br><a href="http://keeganlee.me/post/matching/20191119">撮合引擎开发：数据结构设计</a><br><a href="http://keeganlee.me/post/matching/20191121">撮合引擎开发：对接黑箱</a><br><a href="http://keeganlee.me/post/matching/20191127">撮合引擎开发：解密黑箱流程</a><br><a href="http://keeganlee.me/post/matching/20191130">撮合引擎开发：流程的代码实现</a><br><a href="http://keeganlee.me/post/matching/20191202">撮合引擎开发：缓存和MQ</a><br><a href="http://keeganlee.me/post/matching/20191203">撮合引擎开发：日志输出</a></p>
<hr>
<p>开篇文章发出去之后，我的撮合引擎被一位超级大佬（曾担任上交所的首席架构师）定位为玩具，直接将我的撮合引擎和国家级撮合引擎作对比了。如果我的撮合引擎达到上交所级别，那就不止值5万了，估计至少值500万了。不过，我的撮合引擎随着不断升级迭代，以后能达到国家级别也说不定。为了避免再次出现这种尴尬，我还是先说明清楚对此撮合引擎的定位。</p>
<h2 id="MVP版本需求"><a href="#MVP版本需求" class="headerlink" title="MVP版本需求"></a>MVP版本需求</h2><p>《精益创业》有个核心概念叫 <strong>MVP</strong>(Minimum Viable Product)，即<strong>最小可行性产品</strong>。我的撮合引擎第一个版本也是一个 MVP，只实现最基础的功能。所谓最基础的功能，即是说，如果移除了该功能，整个系统都无法完成工作。当然，我们还要加上应用场景，应用于一个初创的小交易平台和应用于像火币、币安甚至深交所、上交所这样庞大的交易平台，对基础功能的定义范围是有很大区别的。我所要做的 MVP 版本，只要适用于小交易平台即可。</p>
<p>这里我要稍微展开聊下产品设计的问题，很多团队——尤其是初创团队，做第一版产品的时候，总觉得这个功能很重要、那个功能很重要，都往第一版的产品里面加。其实，做第一版的时候，更多的应该是做减法，而不是做加法。很多看起来很重要的功能，大部分都是属于那种有了它更好，但没有它也不是整个产品就运行不下去了。</p>
<p>下面我们就来讨论下 MVP 版本的撮合引擎具体要实现哪些功能。</p>
<p>我们知道，撮合有<strong>集合竞价</strong>和<strong>连续竞价</strong>两种方式，但对于我们的 MVP 版本来说，是否有必要两种撮合方式都支持呢？其实，在币圈，不管是小交易所还是大交易所，基本只采用连续竞价的方式。我以前从事的贵金属交易平台，也同样没有集合竞价这一步。这也说明，集合竞价对一个交易所来说，其实并不是必需的。既然如此，那第一版的撮合引擎其实就可以先把集合竞价功能砍掉。</p>
<p>支持下单和撤单则是必需的，这是一个交易所最最基础的功能，没有这两个功能，交易所就没意义了。下委托单一般还分有几种不同的类型，包括<strong>限价</strong>、<strong>市价</strong>、<strong>止盈止损</strong>等，最简单的就是限价，这也是所有交易所都必须支持的交易类型，初创交易所一般也只先支持限价交易，所以我们的 MVP 版本也只先支持限价交易即可。</p>
<p>下单和撤单的结果还需要通过事件的方式发送出去，其他服务会监听这些事件并做相应的后续处理。</p>
<p>维护<strong>交易委托账本(OrderBook)</strong>也是必需的，撮合就是和 OrderBook 里的订单进行匹配成交，暂时没成交的就会保存在 OrderBook 里。</p>
<p>另外，我们也要采用<strong>内存撮合</strong>技术，因此，OrderBook 其实是直接保存在程序的内存中的。那么，如果程序异常退出的话，那保存的数据也被清空了。所以，我们还需要引入缓存用来备份数据。当程序重启时，可以从缓存中重新加载数据。</p>
<p>MVP 版本还要支持多个交易标的的撮合，因为我们的 MVP 版本撮合引擎只是个单机版的程序，总不能只支持一个交易标的吧。</p>
<p>还要支持开启和关闭指定交易标的撮合的功能，开启撮合时需要做一些初始化的操作，包括初始化开盘价，而关闭撮合后则会删除数据、释放资源等。</p>
<p>汇总一下，我们的 MVP 版本要实现以下这些功能：</p>
<ol>
<li>支持连续竞价的撮合方式；</li>
<li>支持限价交易、支持撤单；</li>
<li>支持下单和撤单结果的下发；</li>
<li>采用内存撮合技术，在内存里维护交易委托账本；</li>
<li>需要缓存数据，当程序重启时，可以恢复数据；</li>
<li>支持多个交易标的的撮合；</li>
<li>支持开启和关闭指定交易标的的撮合功能。</li>
</ol>
<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>需求确定了，接下来就要确定技术方案了，先聊下一些技术选型吧。</p>
<p>首先是开发语言，我的选择是 <strong>Golang</strong>，原因很简单，Golang 有着接近 C/C++ 的执行性能，但比 C/C++ 有着更高的开发效率，既能满足撮合引擎对性能的要求，也能满足我们快速实现产品的需求。当然，用其他语言也能实现，毕竟，设计思路是通用的。</p>
<p>下单和撤单，开启和关闭撮合，以及结果的下发，都涉及到与其他服务的通信。服务间的通信主要就两种可选方案：同步调用的 <strong>RPC</strong> 和异步调用的 <strong>MQ</strong>。同步调用能使请求得到即时的响应，通信相对高效且可靠性较高，但只适用于一对一的通信，且如果并发请求出现超负荷时可能会引发大量的请求超时甚至服务宕机。而 MQ 支持一对多的通信，也因为有缓存队列，能避免并发请求达到峰值时出现服务不可用的情况，但也因为多了个消息中间件，传输有延迟，且请求无法得到即时的应答，还存在丢消息的可能，因此可靠性就比不上同步的 RPC 方式。</p>
<p>对于我们的应用场景来说，结果的下发只能使用 MQ，因为我们并不清楚有多少个下游服务会消费我们的结果消息，也无法要求下游服务提供统一的 RPC 接口供我们调用。下单和撤单请求，则最好采用 RPC 同步方式调用，一是可以对一些无效的请求即时返回响应，二是能减少 MQ 的传输延迟，三是能保证可靠性。对于并发请求超负荷的问题，应该在更上层的网关服务就做好负载均衡，而不应该丢给撮合引擎来处理。</p>
<p>不过，RPC 和 MQ 也有多种具体的实现方案。RPC 方案有 <strong>REST</strong>、<strong>gRPC</strong>、<strong>Thrift</strong>、<strong>rpcx</strong> 等，MQ 方案有 <strong>Kafka</strong>、<strong>RocketMQ</strong>、<strong>RabbitMQ</strong>、<strong>Redis</strong>等。这些不同的具体方案之间的差异性我就不展开了，感兴趣的读者们可以自己去百度或 Google。RPC 方案我们选择最简单的 REST 即可，开发、对接和测试都比较方便。MQ 方案则选定 Redis，因为 Redis 从 5.0 版本开始引入了 <strong>Stream</strong> 数据结构，提供了类似Kafka的消息队列功能，但由于 Redis 的数据是存储在内存中的，其处理速度相比其他 MQ 快很多。另外，我们还要用 Redis 做缓存，用同一个中间件也更方便。</p>
<h2 id="软件结构"><a href="#软件结构" class="headerlink" title="软件结构"></a>软件结构</h2><img src="/post/matching/20191118/v1.0-architecture.png">

<p>上图就是我们 MVP 版本的撮合服务的软件结构设计图，很简单吧。其实，就是按照业务流程进行了分层而已。分层是最简单的一种架构方式，其实任何庞大复杂的系统，第一步拆解都可以按业务流程进行分层。</p>
<p><strong>Handler</strong> 接收由上游服务发过来的 HTTP 请求，我们只需定义三个接口：</p>
<ul>
<li><strong>OpenMatching</strong>：开启撮合，只需接收两个参数：交易标的（交易对）和开盘价。</li>
<li><strong>CloseMatching</strong>：关闭撮合，只需一个参数：交易标的（交易对）。</li>
<li><strong>HandleOrder</strong>：接收委托单，会有一个参数 <strong>Action</strong> 表示动作是下单还是撤单，其他参数则是委托单的数据了，包括订单 ID、交易对、买卖方向、委托数量、委托价格等。</li>
</ul>
<p>Handler 对请求做一些常规的校验之后，就会转发给相应的 Process 做处理，我们也定义了对应的三个 <strong>Process</strong>：</p>
<ul>
<li><strong>NewEngine</strong>：创建一个新的协程/线程，作为指定交易对的撮合引擎。</li>
<li><strong>CloseEngine</strong>：将指定交易对的撮合引擎关闭。</li>
<li><strong>Dispatch</strong>：将不同交易对的委托单分发到相应的撮合引擎。</li>
</ul>
<p><strong>Engine</strong> 即是每个交易对的撮合引擎协程或线程了。由于每个交易对的撮合引擎对委托单的处理必须是串行的，因此，Dispatch 时需将委托单先扔到不同交易对的有序队列里去，再由 Engine 从各自的队列中消费取出委托单进行撮合处理。</p>
<p><strong>Redis</strong> 既用来做数据缓存，也用来做消息队列。缓存的数据主要是当前开启了撮合的交易对，以及撮合引擎里的交易委托账本。为了保证数据的一致性，账本里每个委托单的每一次变化，都需要更新到 Redis 中去。当撮合引擎重启时，就需要从 Redis 中读取缓存的委托单，重新初始化交易委托账本。这样，就能保证程序退出后重启，能恢复到退出前的状态。消息队列则可用 Redis 的新数据结构 Stream 实现，用来发送成交记录和撤单结果。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们第一版先做个 MVP，做个单体版的撮合服务，支持连续竞价、限价委托、撤单、开启和关闭撮合、支持多交易对等功能，采用内存撮合技术。软件结构上主要分为 Handler、Process、Engine 三个层级，底层用 Redis 做数据缓存和消息队列。下一篇我们来设计数据结构。</p>
<p>留一个思考题：Dispatch 分发委托单到 Engine 时，有序队列可以如何实现？</p>
<hr>
<p>扫描以下二维码即可关注公众号（公众号名称：Keegan小钢）</p>
<img src="/post/matching/20191118/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/matching/20191117/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/matching/20191117/" class="post-title-link" itemprop="url">撮合引擎开发:开篇</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-17 20:21:14" itemprop="dateCreated datePublished" datetime="2019-11-17T20:21:14+08:00">2019-11-17</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-03 10:41:22" itemprop="dateModified" datetime="2019-12-03T10:41:22+08:00">2019-12-03</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/matching/" itemprop="url" rel="index"><span itemprop="name">matching</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/matching/20191117"><strong>http://keeganlee.me/post/matching/20191117</strong></a><br>微信公众号：名称：Keegan小钢；微信号：keeganlee_me<br>写于2019-11-17</p>
<hr>
<p><a href="http://keeganlee.me/post/matching/20191117">撮合引擎开发：开篇</a><br><a href="http://keeganlee.me/post/matching/20191118">撮合引擎开发：MVP版本</a><br><a href="http://keeganlee.me/post/matching/20191119">撮合引擎开发：数据结构设计</a><br><a href="http://keeganlee.me/post/matching/20191121">撮合引擎开发：对接黑箱</a><br><a href="http://keeganlee.me/post/matching/20191127">撮合引擎开发：解密黑箱流程</a><br><a href="http://keeganlee.me/post/matching/20191130">撮合引擎开发：流程的代码实现</a><br><a href="http://keeganlee.me/post/matching/20191202">撮合引擎开发：缓存和MQ</a><br><a href="http://keeganlee.me/post/matching/20191203">撮合引擎开发：日志输出</a></p>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自从有人在微信群里开价5万求购Golang版的撮合引擎之后，我就想自己开发一款，毕竟，以我的经验来说，开发个高性能的撮合引擎并没什么难度。</p>
<p>说干就干，于是，利用业余时间慢慢开发出了一款<strong>Golang</strong>版的高性能撮合引擎，前前后后花了大概一个月的时间。再想想自己好久没更新文章了，我的个人IP都已经生锈了，也应该发大招磨一磨了。因此决定，干脆就以连载的方式，分享下我是如何设计与实现这款价值超5万的撮合引擎的。</p>
<p>本来，想发成掘金小册，收点稿费，毕竟这是个具有很大商业价值的软件，但问了掘金的人员，他们目前不接收这类主题。最终决定免费发布，还可以多发几个渠道，说不定还能给我多带来些关注量。</p>
<p>好了，下面开始进入撮合引擎系列的正题。</p>
<h2 id="撮合引擎简介"><a href="#撮合引擎简介" class="headerlink" title="撮合引擎简介"></a>撮合引擎简介</h2><p>撮合引擎是所有撮合交易系统的核心组件，不管是股票交易系统——包括现货交易、期货交易、期权交易等，还是数字货币交易系统——包括币币交易、合约交易、杠杆交易等，以及各种不同的贵金属交易系统、大宗商品交易系统等，虽然各种不同交易系统的交易标的不同，但只要都是采用撮合交易模式，都离不开撮合引擎。</p>
<p>撮合引擎是可以具有通用性的，一套具有通用性的撮合引擎实现理论上可以应用到任何撮合交易系统中，而无需做任何代码上的调整。即是说，同一套撮合引擎实现，既可以应用在股票交易系统，也可以应用在数字货币交易系统，可以用于现货交易，也可以用于合约交易等。</p>
<p>那么，一套具有通用性的撮合引擎应该具备哪些功能呢？确定该问题的答案之前，我们先简单梳理一下一个完整的交易流程是怎样的？一般会包括以下步骤：</p>
<ol>
<li>系统开放某个交易标的的交易功能。</li>
<li>用户提交该交易标的的买卖申报，即<strong>委托单</strong>。</li>
<li>系统验证委托单是否有效，包括交易标的是否处于可交易的状态、订单的价格和数量是否符合要求等。</li>
<li>确定该委托单的<strong>挂单(Maker)</strong>费率和<strong>吃单(Taker)</strong>费率。</li>
<li>检查用户的资产账户情况，包括账户状态是否交易受限，是否有足够资金用于下单等。</li>
<li>将详细的委托单数据持久化到数据库，并冻结用户账户中相应数量的资金。</li>
<li>将委托单进行撮合处理，即在<strong>交易委托账本(OrderBook)</strong>中寻找能与该委托单匹配成交的订单，匹配的结果可能是：全部成交、部分成交或无匹配。全部成交或部分成交时，可能在交易委托账本中存在一个或多个匹配的订单，即会产生一条或多条成交记录。当无匹配或部分成交时，委托单的部分数据包括剩余未成交的数量会暂时保存到交易委托账本中，等待与后续的委托单匹配撮合。</li>
<li>将撮合产生的成交记录持久化到数据库，并根据历史成交记录生成市场数据，如K线数据、今日涨跌幅等。</li>
<li>更新数据库中所有成交订单的委托单数据，以及更新订单用户的资产账户余额。</li>
<li>将更新的订单数据、市场数据等发送给到前台。</li>
</ol>
<p>整个交易流程中涉及到多个服务，包括用户服务、账户服务、订单服务、撮合服务、市场数据服务等。其中，只有第7步是撮合引擎处理的。从单一职责原则来说，撮合引擎就应该只做一件事，那就是<strong>负责撮合订单</strong>。撮合之前的委托单持久化、冻结资金等，以及撮合之后生成K线数据等，都不应该属于撮合引擎的职责。</p>
<h2 id="撮合竞价方式"><a href="#撮合竞价方式" class="headerlink" title="撮合竞价方式"></a>撮合竞价方式</h2><p>撮合竞价方式一般有两种，一是<strong>集合竞价</strong>，二是<strong>连续竞价</strong>。股票交易系统一般会在不同交易时间段采用不同的竞价方式，比如在开盘或收盘时采用集合竞价，从而产生<strong>开盘价</strong>或<strong>收盘价</strong>，其余时间采用连续竞价。而大多数字货币交易系统则没有集合竞价，只有连续竞价，开盘价一般是在开始交易之前就设定好的。</p>
<h3 id="集合竞价"><a href="#集合竞价" class="headerlink" title="集合竞价"></a>集合竞价</h3><p>所谓集合竞价，是指对一段时间内接收的买卖委托单一次性集中撮合的竞价方式。以深沪的股票交易系统为例，在每个交易日的 9:15~9:25 期间是集合竞价时间。在该时间段内，系统陆续接收到的委托单不会即时成交，而是先将所有委托单按照<strong>价格优先、时间优先</strong>的原则排序，并在此基础上，找出一个基准价格，使它能同时满足以下三个条件：</p>
<ol>
<li>可实现<strong>最大成交量</strong>的价格；</li>
<li>高于该价格的买单与低于该价格的卖单能全部成交的价格；</li>
<li>与该价格相同的买方或卖方至少有一方全部成交的价格。</li>
</ol>
<p>在 9:25 分结束的时候，该基准价格就被确定为<strong>成交价格</strong>，所有高于该价格的买单与低于该价格的卖单都将以该价格成交。未能成交的委托单，则自动转入连续竞价。</p>
<p>不过，如果满足以上三个条件的价格存在两个或两个以上呢？对此，深交所和上交所的处理方案有所不同，深交所会取距<strong>前收盘价</strong>最近的价格为成交价，而上交所则取使<strong>未成交量</strong>最小的价格为成交价，如果未成交量最小的价格仍不止一个，则取<strong>中间价</strong>为成交价。</p>
<p>集合竞价的主要目的就是为了确定开盘价或收盘价。</p>
<h3 id="连续竞价"><a href="#连续竞价" class="headerlink" title="连续竞价"></a>连续竞价</h3><p>所谓连续竞价，也是我们所熟悉的竞价方式，是指对买卖委托单逐笔连续撮合的竞价方式。用户的挂单，只要满足成交条件，就能即时成交。而集合竞价，则要等到最后一刻才会成交。</p>
<p>连续竞价时，依然要满足价格优先、时间优先的成交原则：</p>
<ol>
<li><strong>价格优先</strong>：买单则价格较高者能优先成交，卖单则是价格较低者能优先成交。</li>
<li><strong>时间优先</strong>：买卖方向和价格相同的委托单，先申报的委托单会比后申报的委托单优先成交。</li>
</ol>
<p>另外，买入价必须大于或等于卖出价才能撮合成交。当买入价等于卖出价时，成交价就是买入价或卖出价。当买入价大于卖出价时，则还要参考前一笔成交价来确定最新成交价。假设买入价为 B，卖出价为 S，前一笔成交价为 P，最新成交价为 N，那么：</p>
<ul>
<li>如果 P &gt;= B，则 N = B</li>
<li>如果 P &lt;= S，则 N = S</li>
<li>如果 B &gt; P &gt; S，则 N = P </li>
</ul>
<p>一套通用的撮合引擎应该两种竞价方式都支持，但对于同一交易标的来说，两种竞价方式不能同时进行，因此设计上需要考虑如何在两种竞价方式之间切换，具体的实现思路在后续章节我们再展开来讲。</p>
<h2 id="质量需求"><a href="#质量需求" class="headerlink" title="质量需求"></a>质量需求</h2><p>我们的撮合引擎除了要满足以上所说的功能需求，还应该满足一些质量需求，尤其对<strong>可用性</strong>、<strong>可伸缩性</strong>和<strong>性能</strong>的要求较高。另外，为了达到通用，也要满足<strong>可复用性</strong>的需求。</p>
<p>先说下可复用性，我们期望的是该撮合引擎既能用于股票交易系统，也能用于数字货币交易系统，既能用于币币交易，也能用于合约交易。因此，该撮合引擎要避免引入与具体系统强相关的业务逻辑，以加强它的可复用性。</p>
<p>再看看性能，要衡量一个撮合引擎的性能，就看它处理每个交易对的 <strong>TPS</strong> 有多高，即每秒钟能处理多少笔相同交易对的委托单。以前，基于数据库的撮合技术，TPS 一般只有10笔/秒。而现在基本都是采用内存撮合技术，TPS 很容易就能达到1000笔/秒，如果使用独占的高性能服务器，1万笔/秒甚至更高的 TPS 都不难达到。</p>
<p>接着谈谈可伸缩性，我们的每一个撮合引擎既可以同时处理多个交易标的，也可以只处理单个交易标的。当交易标的和并发量增多的时候，可以增加服务器，部署成撮合引擎集群，分别用来处理不同的交易标的，从而能够实现负载均衡。</p>
<p>最后聊聊可用性，高可用主要体现在两点，一是故障率要低，二是对故障维修的时间要短。要降低故障率，那撮合引擎就需要有较高的健壮性，对于可能导致引擎出故障的各种异常情况要考虑好并设计好解决方案。另外，还可以采用多机热备份技术来提高可用性，而且要保证互备服务器之间的数据一致，那就需要引入内存状态机复制方案，实现上会复杂很多。</p>
<p>不过，我们并非一下子就要达到很高的质量要求，因为要求越高，其架构和实现会越复杂。我们可以先从简单的版本开始，然后不断升级迭代。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们目的是实现一套通用的撮合引擎，要支持集合竞价和连续竞价，还要实现一些质量需求，提高系统的可复用性、性能、可伸缩性、可用性等。后续章节会对这些需求不断深入探讨其设计与实现。另外，我们将采用不断升级迭代的方式来设计和实现多个版本的撮合引擎。</p>
<p>留两个思考题：</p>
<ol>
<li>集合竞价结束的时候，如果不存在符合那三个条件的基准价格，那开盘价又将如何确定？</li>
<li>对于单个交易对，是否可通过横向增加服务器的方式提高其性能？</li>
</ol>
<hr>
<p>扫描以下二维码即可关注公众号（公众号名称：Keegan小钢）</p>
<img src="/post/matching/20191117/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/blockchain/20180425/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/blockchain/20180425/" class="post-title-link" itemprop="url">漫谈区块链共识机制</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-04-25 16:00:00" itemprop="dateCreated datePublished" datetime="2018-04-25T16:00:00+08:00">2018-04-25</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-02 11:18:29" itemprop="dateModified" datetime="2019-07-02T11:18:29+08:00">2019-07-02</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/blockchain/" itemprop="url" rel="index"><span itemprop="name">blockchain</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/blockchain/20180425"><strong>http://keeganlee.me/post/blockchain/20180425</strong></a><br>微信订阅号：<strong>keeganlee_me</strong><br>写于2018-04-25</p>
<hr>
<p>专栏地址：<a href="https://xiaozhuanlan.com/fullstack" target="_blank" rel="noopener">https://xiaozhuanlan.com/fullstack</a></p>
<hr>
<p>共识机制是区块链的一个核心特征，是保证区块链系统在分布式架构下的一致性方案。目前主流的也有好多种共识算法：POW、POS、DPOS、RCP、PBFT、DBFT 等等。网上已经充斥了很多对这些共识算法的简单介绍，但基本流于表面而缺少深入的讲解，从而读者们也很难理解到这些共识机制背后的核心原理。而本文将以深入浅出的方式讲解区块链共识机制，但由于篇幅有限，因此，只会讲解最重要的两种区块链的共识机制，即比特币和以太坊的共识机制。</p>
<h2 id="比特币共识机制"><a href="#比特币共识机制" class="headerlink" title="比特币共识机制"></a>比特币共识机制</h2><p>比特币是区块链的第一个应用，也是第一个实现了共识机制的，因此，要理解区块链共识机制，自然也要先从比特币共识机制开始。另外，虽然很多文章都提到比特币的共识机制为 <strong>POW（Proof of Work，工作量证明）</strong>，但实际上，POW 只是整个比特币共识机制中的一部分，虽然是核心的那部分，但却不是全部。其实，比特币的分布式共识是由网络节点的 4 种独立过程相互作用而达成的：</p>
<ul>
<li><strong>每个全节点基于一份长长的判断标准清单对每个交易进行独立验证</strong></li>
<li><strong>每个挖矿节点独立将多个交易打包进新区块，通过完成 POW 算法的验算</strong></li>
<li><strong>每个节点独立验证新区块并组装进区块链</strong></li>
<li><strong>每个节点独立选择最长链，即在 POW 机制下累计工作量最多的那条链</strong></li>
</ul>
<p>先说第一种过程，对交易的独立验证。每个节点收到每一个交易之后，都会先根据一份很长的判断标准清单对该交易进行有效性校验，包括但不限于校验交易的语法和数据结构是否正确、输入和输出是否为空、输入总额是否小于输出总额、每一个输入所引用的输出是否已经被消费，等等。如果该交易通过所有验证，则可以说明该交易是有效的，那么，该节点就会将该交易放入本地的<strong>交易池</strong>（或称<strong>内存池</strong>），并将该交易广播给其他相临的节点。如果没通过验证，则会废弃该交易，也不会将其广播出去。其他节点接收到该交易后，也各自做同样的独立校验，校验为交易有效之后，同样也放入各节点自己的<strong>交易池</strong>，并继续广播给其他节点。所以，理论上来说，无效的交易一开始就会被废弃，而有效的交易最终会到达整个网络所有节点，并被每个全节点所保存，即全网达成了“该交易有效”的共识。</p>
<p>接着，再来聊聊第二种过程，了解有效的交易是如何被打包进区块的。经过一段时间后，一般是 10 分钟左右，每个节点的交易池里会收集到很多有效但还未确认的交易，这些交易会组装成一颗 <strong>Merkle Tree</strong>。关于 <strong>Merkle Tree</strong> 的结构，我们在之前的文章<a href="https://xiaozhuanlan.com/topic/2394807516" target="_blank" rel="noopener">《014|从微观到宏观理解区块链》</a>已经讲过，这里就不赘述了。不过，组装进 <strong>Merkle Tree</strong> 的第一笔交易是比较特殊的，这是一笔<strong>创币交易</strong>，也叫 <strong>Coinbase 交易</strong>，新的比特币就是从该笔交易产生的。这笔交易是由节点自己创建的，并将挖矿奖励支付到矿工自己的地址，挖矿奖励包括新创建的比特币和打包进该区块所有交易的手续费总额。组装好 <strong>Merkle Tree</strong> 之后，就得到 <strong>Merkle Root</strong>，再结合区块头的其他 5 个字段——<strong>Version、Pre Block、Times、Difficulty、Nonce</strong>，总共 6 个字段合在一起经过<strong>两次 SHA256 计算</strong>得到区块哈希值。一个有效的区块要求其哈希值必须小于 Difficulty 难度值，写作本文时的难度要求哈希值至少已经有 18 个 0 开头。挖矿其实就是通过修改参数的值而不断计算区块哈希值，直到计算出符合难度要求的哈希值。一般是通过修改 Nonce 值来计算区块哈希值，其他 5 个字段基本是不变的。而由于哈希函数的特性，难度值越大，理论上计算出符合要求的哈希值所需的计算量就越大。举个简单例子，比如你扔三个骰子，如果难度要求总和小于18，那是非常容易达到的，基本扔个一两次就能满足要求了；而如果加大难度，要求总和小于9，那从概率上来说相对就没那么容易了，可能要扔个十几次甚至几十次才能达到；而如果要求总和等于 3，那只能扔出三个 1 才行，这谁都知道要达到的概率是很低的，也许扔个一两百次才可能出现。因此，从统计学来说，一定的难度值可以推算出概率上对应所需的计算次数，也就是“工作量”，所以，只要你达到了难度要求，也就间接证明你付出了对应的工作量，这就是<strong>工作量证明</strong>。</p>
<p>当某个节点计算出符合难度要求的区块哈希时，即说明该矿工挖矿成功了，该节点就会将此区块组装到本地的区块链，同时也将此区块广播给其他节点。然后，就进入第三种过程了。当其他节点收到此区块时，也会各自独立验证该区块是否有效。和独立验证交易一样，也存在一份验证标准清单，包括但不限于校验引用的上一个区块是否是否正确、难度值是否符合标准、区块哈希是否真的符合难度要求、Coinbase 交易中的挖矿奖励是否多于应得的、整个区块的每笔交易是否都是有效的，等等。其中，难度值是有标准的计算公式的，每个节点都会根据标准公式独立计算实际的难度值，所以，矿工如果不按照标准而自己设置一个较低的难度，在其他节点是无法通过的。同样，挖矿奖励也是有标准公式的，所以，如果矿工给自己奖励过多的比特币，在其他节点也是同样无法通过的。每个节点验证该区块为有效之后，也会各自将该区块组装进它们本地的区块链，并继续将该区块广播给其他节点。</p>
<p>由于所有节点同时在挖同一个区块，就有可能会出现多个节点同时挖出了同个区块，并都将各自挖到的区块广播到其他节点。假设有两个节点同时挖出了新区块，分别为区块 N1 和 N2，它们的上一个区块都是 P。有些节点会先收到 N1，它们会将 N1 先组装进它们本地的区块链，也称为主链。但之后不久，这些节点也会收到 N2，这时候，它们会将 N2 放入备选链。而其他节点则先收到 N2 再收到 N1，则 N2 在它们的主链上，而 N1 在它们的备选链上。这时候，整个区块链暂时就分成了两个分叉，而要打破这种局面，就要看下一个生成的区块是基于 N1 还是 N2 了。如果下一个区块是基于 N1，自然，N1 的这条链就变成了最长链，也是累计工作量最多的链。那么，那些将 N2 链设为主链的节点就会根据实际情况自己选择将 N1 链改为主链，而 N2 将成为<strong>孤块</strong>而被废弃。</p>
<p>以上就是比特币共识机制的核心内容了，说白了其实就是根据一些所有节点都认可的标准对每个交易和区块的创建和校验进行独立验证，当大多数节点都认可并写入自己的区块链的时候，就自动形成了分布式共识。所有区块链基本都是这个逻辑，不同区块链主要在于制定的标准不同，比特币主要就是基于 POW 机制，这种机制实现简单，但它会造成大量的能源浪费，由于所有节点同时竞争挖矿同一个区块，而基本只有一个节点能胜出，那其他未胜出的节点所消耗的算力能源就白费了。另外，每次交易确认（即出块时间）大概 10 分钟，一笔交易一般要有 6 次确认才算安全，那基本就要 1 个小时了，这共识达成的时间太长了。</p>
<h2 id="以太坊共识机制"><a href="#以太坊共识机制" class="headerlink" title="以太坊共识机制"></a>以太坊共识机制</h2><p>以太坊的共识机制也是基于 POW 的，但与比特币相比，主要有两点不同：一是挖矿时间控制在 10 ~ 19 秒之间，出块时间比比特币快了很多；二是对于<strong>孤块</strong>也有挖矿奖励。在比特币中，<strong>孤块</strong>（即上文的 N2 区块）是会被丢弃的，挖出了孤块的矿工是得不到任何奖励的。但在以太坊中，孤块是能被打包进区块里的，如果后续的区块将前面产生的孤块也打包进区块里，那这个孤块就变成了<strong>叔块</strong>，那么，挖到这个叔块的矿工就能得到奖励，而将叔块打包进区块的矿工也能得到额外的奖励，但每个区块最多只能包含两个叔块，而且也不能包含太久的孤块，最多只支持到 7 层的祖先孤块。由于以太坊的出块时间短很多，那自然更容易出现临时分叉而产生孤块，而且这么短的时间内，每个区块也很难能够在全网充分传播，那对于网速慢的矿工来说，就非常吃亏了。所以，为了平衡各方利益，以太坊才设计了叔块机制。写作本文时，叔块率在 16.9% 左右。</p>
<p>不过，以太坊正在计划从 POW 机制切换为 <strong>POS（Proof of Stack，权益证明）</strong>机制，其新的共识机制名为 <strong>Casper</strong>，其存在两个不同实现的版本，分别是：</p>
<ul>
<li>Casper the Friendly Finality Gadget（FFG）</li>
<li>Casper the Friendly GHOST: Correct-by-Construction（CBC）</li>
</ul>
<p>Casper FFG 是由 Vitalik 主导的，侧重于通过逐步迭代实现，慢慢过渡到 POS 机制。而 Casper CBC 则是由 Vlad Zamfir 主导的，不同于传统的协议设计方式，即先定义完整的协议，CBC 协议在开始阶段只是部分确定的，其余部分协议以证明能够满足所需/必需属性的方式得到。不过，也只是两种不同的方法，关于 POS 的核心理念还是一致的。相对来说，FFG 比较容易理解，也很大可能是即将第一个部署到以太坊的 Casper 版本，所以下面的篇幅主要讲解 FFG。</p>
<p>FFG 版本的 Casper 是一种混合 POW / POS 的共识机制，该机制下的每次出块依然还是采用 POW 挖矿机制，但每 100 个区块会增加一个 POS <strong>检查点（checkpoint）</strong>，通过<strong>验证人（validator）</strong>来评估区块的最终有效性。创世区块是一个检查点，区块高度为 100 的倍数的区块也是检查点，将这些检查点连起来就组成了一条<strong>检查点链（checkpoint chain）</strong>。检查点一般会有两种状态：<strong>justified</strong> 和 <strong>finalized</strong>，<strong>finalized</strong> 则表示已经确定为最终有效的，该状态的检查点至少已经存在一个子检查点，<strong>justified</strong> 则表示该检查点是已经被证明合理的，<strong>finalized</strong> 的检查点一定是 <strong>justified</strong> 的，但反过来则不一定。而一个检查点是否有效，是通过多个验证人投票得出的结果。下面，我们就来简单聊聊这个过程。</p>
<p>首先，要成为验证人，是需要投入<strong>保证金</strong>的，即抵押一定量的以太币作为权益证明，才有资格成为验证人。投入保证金是通过广播一条 <strong>deposit</strong> 消息进行操作的，只要这条消息是有效的并被打包进区块中，那就能加入<strong>验证人集合（validator set）</strong>，成为其中一个验证人。另外，如果要退出<strong>验证人集合</strong>，则可以再广播一条 <strong>withdraw</strong> 消息。不过，需要注意，一旦退出后，该验证人的公钥将被永久禁止再次加入验证人集合。</p>
<p>接着，成为验证人之后，就可以开始投票选举检查点了，通过广播一条 <strong>vote</strong> 消息到网络中。vote 消息主要包含五个信息：两个检查点 <strong>s</strong> 和 <strong>t</strong>，以及这两个检查点的高度 <strong>h(s)</strong> 和 <strong>h(t)</strong>，以及验证人的公钥 <strong>ν</strong>。要求 s 必须是 t 的祖先，一般来说，t 就是最新的检查点，而 s 是上一个已经确定为最终有效的检查点。另外，还要求验证人的公钥 v 必须在验证人集合中找得到，否则都认为该投票是无效的。当超过 2/3 的验证人（实际上是 2/3 的总保证金）都投给了 (s, t) 这对检查点时，那 s 就是 <strong>finalized</strong> 的，t 则是 <strong>justified</strong> 的。而且，那些投注了 (s, t) 的验证人还会得到货币奖励，得到的奖励是和抵押的保证金成比例的，就是说抵押的保证金越多，得到的奖励越多。这个奖励也可以理解为抵押保证金的利息。</p>
<p>另外，Casper 设置了两条戒律：</p>
<ol>
<li>验证人不能发布两个 h(t) 相同的投票，即如果存在两个投票：&lt;ν, s1, t1, h(s1), h(t1)&gt; 和 &lt;ν,s2,t2,h(s2),h(t2)&gt;，那么 h(t1) = h(t2) 是不允许的；</li>
<li>如果 h(s1) &lt; h(s2) &lt; h(t2) &lt; h(t1)，则第一个投票的跨度已经涵盖了第二个投票，这也是不允许的。</li>
</ol>
<p>如果验证人违反了上面的戒律，则会对验证人进行惩罚，没收他抵押的保证金。</p>
<p>最后，Casper 对分叉链的选择不同于 POW 机制下选择累计工作量最多的那条链，Casper 对分叉链选择的规则就是选择 justified 检查点高度最大的链，原文是：</p>
<ul>
<li><strong>FOLLOW THE CHAIN CONTAINING THE JUSTIFIED CHECKPOINT OF THE GREATEST HEIGHT.</strong></li>
</ul>
<p>很明显，以太坊的共识机制和比特币相比复杂得多，主要在于两点引起的：一是大大缩短了出块时间，二是引入了 POS 机制。在 POW 机制下将出块时间缩短到十几秒，虽然加快了性能，但其实减低了安全性，因为会引入很多其他问题，比如新区块难以在这么短的时间内扩散到全网，比如分叉链出现的概率更大，为了解决这些问题，就需要设计更多共识协议来提高安全性。引入 POS 机制变成 POW + POS 的混合机制，那这种复杂度不是 1 + 1 = 2 这么简单的。</p>
<h2 id="思考和实践"><a href="#思考和实践" class="headerlink" title="思考和实践"></a>思考和实践</h2><p>EOS 的共识机制是怎样的？其安全性和性能又如何呢？</p>
<hr>
<p>扫描以下二维码即可关注订阅号。</p>
<img src="/post/blockchain/20180425/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keeganlee.me/post/blockchain/20180313/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keegan小钢">
      <meta itemprop="description" content="分享钢哥人生路上的点点滴滴">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keegan小钢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/post/blockchain/20180313/" class="post-title-link" itemprop="url">详解区块链P2P网络</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-03-13 16:48:12" itemprop="dateCreated datePublished" datetime="2018-03-13T16:48:12+08:00">2018-03-13</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-02 11:18:30" itemprop="dateModified" datetime="2019-07-02T11:18:30+08:00">2019-07-02</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/blockchain/" itemprop="url" rel="index"><span itemprop="name">blockchain</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原创文章，转载请注明：转载自<a href="http://keeganlee.me/">Keegan小钢</a><br>并标明原文链接：<a href="http://keeganlee.me/post/blockchain/20180313"><strong>http://keeganlee.me/post/blockchain/20180313</strong></a><br>微信订阅号：<strong>keeganlee_me</strong><br>写于2018-03-13</p>
<hr>
<p>专栏地址：<a href="https://xiaozhuanlan.com/fullstack" target="_blank" rel="noopener">https://xiaozhuanlan.com/fullstack</a></p>
<hr>
<p>根据前一篇文章《<a href="http://keeganlee.me/post/blockchain/20180224">从微观到宏观理解区块链</a>》我们已经了解到，微观上，区块链本质就是一种<strong>不可篡改且可追踪溯源的哈希链条</strong>；宏观上，还具备了另外三个基本特征：<strong>分布式存储、P2P 网络和共识机制</strong>。分布式存储无非就是网络上大部分节点都保存了整条区块链，这容易理解也不复杂，所以就没必要再展开细讲了。但区块链的 P2P 网络和共识机制相对则复杂得多，因此我将用两篇文章分别展开讲讲这两部分内容，本篇文章就先来了解区块链的 P2P 网络。</p>
<h2 id="P2P-网络"><a href="#P2P-网络" class="headerlink" title="P2P 网络"></a>P2P 网络</h2><p>由于大部分人对 P2P 网络了解甚少，因此有必要先聊聊 P2P 网络的一些基本原理。这个章节的内容主要来自<strong>《P2P对等网络原理与应用》</strong>这本书，这本书较为系统地介绍了 P2P 的理论基础，非常适合希望全面掌握 P2P 知识的初级读者，建议大伙都可以看看。</p>
<p>P2P 网络不同于传统的<strong>客户端/服务端(client/server,C/S)结构</strong>，P2P 网络中的每个节点都可以既是客户端也是服务端，因此也不适合使用 HTTP 协议进行节点之间的通信，一般都是直接使用 Socket 进行网络编程。</p>
<p>P2P 主要存在四种不同的网络模型，也代表着 P2P 技术的四个发展阶段：<strong>集中式、纯分布式、混合式和结构化模型</strong>。不过需要指出的是，这里所说的网络模型主要是指路由查询结构，即不同节点之间如何建立连接通道，两个节点之间一旦建立连接，具体传输什么数据则是两个节点之间的事情了。</p>
<p>最简单的路由方式就是<strong>集中式</strong>，即存在一个中心节点保存了其他所有节点的索引信息，索引信息一般包括节点 IP 地址、端口、节点资源等。集中式路由的优点就是结构简单、实现容易。但缺点也很明显，由于中心节点需要存储所有节点的路由信息，当节点规模扩展时，就很容易出现性能瓶颈；而且也存在单点故障问题。</p>
<img src="/post/blockchain/20180313/2018-03-06-22-25-08.jpg">

<p>那第二种路由结构则是<strong>纯分布式</strong>的，移除了中心节点，在 P2P 节点之间建立随机网络，就是在一个新加入节点和 P2P 网络中的某个节点间随机建立连接通道，从而形成一个随机拓扑结构。新节点加入该网络的实现方法也有很多种，最简单的就是随机选择一个已经存在的节点并建立邻居关系。像比特币的话，则是使用 DNS 的方式来查询其他节点，DNS 一般是硬编码到代码里的，这些 DNS 服务器就会提供比特币节点的 IP 地址列表，从而新节点就可以找到其他节点建立连接通道。新节点与邻居节点建立连接后，还需要进行全网广播，让整个网络知道该节点的存在。全网广播的方式就是，该节点首先向邻居节点广播，邻居节点收到广播消息后，再继续向自己的邻居节点广播，以此类推，从而广播到整个网络。这种广播方法也称为<strong>泛洪机制</strong>。纯分布式结构不存在集中式结构的单点性能瓶颈问题和单点故障问题，具有较好的可扩展性，但泛洪机制引入了新的问题，主要是可控性差的问题，包括两个较大的问题，一是容易形成泛洪循环，比如节点 A 发出的消息经过节点 B 到 节点 C，节点 C 再广播到节点 A，这就形成了一个循环；另一个棘手问题则是响应消息风暴问题，如果节点 A 想请求的资源被很多节点所拥有，那么在很短时间内，会出现大量节点同时向节点 A 发送响应消息，这就可能会让节点 A 瞬间瘫痪。</p>
<img src="/post/blockchain/20180313/2018-03-07-10-54-06.jpg">

<p>再来看看第三种路由结构：<strong>混合式</strong>。混合式其实就是混合了集中式和分布式结构，如下图所示，网络中存在多个<strong>超级节点</strong>组成分布式网络，而每个超级节点则有多个<strong>普通节点</strong>与它组成局部的集中式网络。一个新的普通节点加入，则先选择一个超级节点进行通信，该超级节点再推送其他超级节点列表给新加入节点，加入节点再根据列表中的超级节点状态决定选择哪个具体的超级节点作为父节点。这种结构的泛洪广播就只是发生在超级节点之间，就可以避免大规模泛洪存在的问题。在实际应用中，混合式结构是相对灵活并且比较有效的组网架构，实现难度也相对较小，因此目前较多系统基于混合式结构进行开发实现。其实，比特币网络如今也是这种结构，后面再细说。</p>
<img src="/post/blockchain/20180313/2018-03-06-22-27-23.jpg">

<p>最后一种网络则是<strong>结构化 P2P 网络</strong>，它也是一种分布式网络结构，但与纯分布式结构不同。纯分布式网络就是一个随机网络，而结构化网络则将所有节点按照某种结构进行有序组织，比如形成一个环状网络或树状网络。而结构化网络的具体实现上，普遍都是基于 <strong>DHT(Distributed Hash Table，分布式哈希表) *<em>算法思想。DHT 只是提出一种网络模型，并不涉及具体实现，主要想解决如何在分布式环境下快速而又准确地路由、定位数据的问题。具体的实现方案有 Chord、Pastry、CAN、Kademlia 等算法，其中 *</em>Kademlia</strong> 也是以太坊网络的实现算法，很多常用的 P2P 应用如 BitTorrent、电驴等也是使用 Kademlia。因为篇幅有限，就不展开讲这些算法的具体原理了。目前，我们主要理解 DHT 的核心思想即可。</p>
<p>在 P2P 网络中，可以抽象出两种空间：<strong>资源空间</strong>和<strong>节点空间</strong>。资源空间就是所有节点保存的资源集合，节点空间就是所有节点的集合。对所有资源和节点分别进行编号，如把资源名称或内容用 Hash 函数变成一个数值（这也是 DHT 常用的一种方法），这样，每个资源就有对应的一个 ID，每个节点也有一个 ID，资源 ID 和节点 ID 之间建立起一种映射关系，比如，将资源 n 的所有索引信息存放到节点 n 上，那要搜索资源 n 时，只要找到节点 n 即可，从而就可以避免泛洪广播，能更快速而又准确地路由和定位数据。当然，在实际应用中，资源 ID 和节点 ID 之间是无法做到一一对应的，但因为 ID 都是数字，就存在大小关系或偏序关系等，基于这些关系就能建立两者的映射关系。这就是 DHT 的核心思想。DHT 算法在资源编号和节点编号上就是使用了分布式哈希表，使得资源空间和节点空间的编号有唯一性、均匀分布式等较好的性质，能够适合结构化分布式网络的要求。</p>
<p>综上，这就是 P2P 网络的一点理论基础，不同的区块链可能会使用不一样的网络模型，但基本原理是一样的。后面分别讲解下最有代表性的两个区块链的网络：比特币网络和以太坊网络。</p>
<h2 id="比特币网络"><a href="#比特币网络" class="headerlink" title="比特币网络"></a>比特币网络</h2><p>首先，比特币网络中的节点主要有四大功能：<strong>钱包、挖矿、区块链数据库、网络路由</strong>。每个节点都会具备路由功能，但其他功能不一定都具备，不同类型的节点可能只包含部分功能，一般只有<strong>比特币核心(bitcoin core)</strong>节点才会包含所有四大功能。</p>
<img src="/post/blockchain/20180313/2018-03-09-16-35-26.jpg">

<p>所有节点都会参与校验和广播交易及区块信息，且会发现和维持与其他节点的连接。有些节点会包含完整的区块链数据库，包括所有交易数据，这种节点也称为<strong>全节点(Full Node)</strong>。另外一些节点只存储了区块链数据库的一部分，一般只存储区块头而不存储交易数据，它们会通过“<strong>简化交易验证(SPV)</strong>”的方式完成交易校验，这样的节点也称为 <strong>SPV节点</strong>或<strong>轻节点(Lightweight Node)</strong>。钱包一般是 PC 或手机客户端的功能，用户通过钱包查看自己的账户金额、管理钱包地址和私钥、发起交易等。除了比特币核心钱包是全节点之外，大部分钱包都是<strong>轻节点</strong>。挖矿节点则通过解决<strong>工作量证明(PoW)</strong>算法问题，与其他挖矿节点相互竞争创建新区块。有些挖矿节点同时也是<strong>全节点</strong>，即也存储了完整的区块链数据库，这种节点一般都是<strong>独立矿工(Solo Miner)</strong>。还有一些挖矿节点不是独立挖矿的，而是和其他节点一起连接到<strong>矿池</strong>，参与集体挖矿，这种节点一般也称为<strong>矿池矿工(Pool Miner)</strong>。这会形成一个局部的集中式矿池网络，中心节点是一个<strong>矿池服务器</strong>，其他挖矿节点全部连接到矿池服务器。<strong>矿池矿工</strong>和<strong>矿池服务器</strong>之间的通信也不是采用标准的<strong>比特币协议</strong>，而是使用<strong>矿池挖矿协议</strong>，而矿池服务器作为一个<strong>全节点</strong>再与其他比特币节点使用主网络的<strong>比特币协议</strong>进行通信。</p>
<p>在整个比特币网络中，除了不同节点间使用<strong>比特币协议</strong>作为通信协议的主网络，也存在很多扩展网络，包括上面提到的<strong>矿池网络</strong>。不同的矿池网络可能还会使用不同的矿池挖矿协议，目前主流的具体矿池协议应该是 <strong>Stratum协议</strong>，该协议除了支持挖矿节点，也支持<strong>瘦客户端钱包</strong>。一个包含了比特币协议主网络各种节点和 Stratum 网络，以及其他矿池网络的扩展比特币网络大概如下图所示：</p>
<img src="/post/blockchain/20180313/bitcoin-network.jpeg">

<p>另外，挖矿这块还有特殊需求。我们知道，矿工创建新区块后，是需要广播给全网所有节点的，当全网都接受了该区块，给矿工的挖矿奖励才算是有效的，这之后才好开始下一个区块 Hash 的计算。所以矿工必须最大限度缩短新区块的广播和下一个区块 Hash 计算之间的时间。如果矿工之间传播区块只采用上图所示的比特币协议网络，那无疑会有很高的网络延迟，所以，需要一个专门的传播网络用来加快新区块在矿工之间的同步传播，这个专门网络也叫<strong>比特币传播网络</strong>或<strong>比特币中继网络(Bitcoin Relay Network)</strong>。</p>
<h2 id="以太坊网络"><a href="#以太坊网络" class="headerlink" title="以太坊网络"></a>以太坊网络</h2><p>和比特币一样，以太坊的节点也具备<strong>钱包、挖矿、区块链数据库、网络路由</strong>四大功能，也同样存在很多不同类型的节点，除了主网络之外也同样存在很多扩展网络。但与比特币不同的，比特币主网的 P2P 网络是无结构的，但以太坊的 P2P 网络是有结构的。前面我们已经提过，以太坊的 P2P 网络主要采用了 <strong>Kademlia(简称 Kad)</strong> 算法实现，Kad 是一种<strong>分布式哈希表(DHT)</strong>技术，使用该技术，可以实现在分布式环境下快速而又准确地路由、定位数据的问题。所以，下面主要讲解下以太坊的 Kad 网络。</p>
<p>在 Kad 网络中，每个节点都具有一个唯一的节点 ID。另外，也会计算不同节点之间的距离，但这个距离不是物理上的距离，而是逻辑上的距离，是通过对两个节点 ID 进行 <strong>异或(符号为^)</strong> 计算得到的，即 A、B 两节点之间的距离的计算公式为：<strong>D(A,B) = A.ID^B.ID</strong>。异或有一个重要的性质：假设 a、b、c 为任意三个数，如果 a^b = a^c 成立，那就一定 b = c。因此，如果给定一个结点 a 和距离 L，那就有且仅有一个结点 b, 会使得 D(a,b) = L。通过这种方式，就能有效度量 Kad 网络中不同节点之间的逻辑距离。</p>
<p>在异或距离度量的基础上，Kad 还可以将整个网络拓扑组织成如下图所示的一个<strong>二叉前缀树</strong>，每个 NodeID 会映射到二叉树上的某个叶子。</p>
<img src="/post/blockchain/20180313/2018-03-13-12-31-47.png">

<p>映射规则主要是：</p>
<ol>
<li>将 NodeID 以二进制形式表示，然后从高到低对每一位的 0 或 1 依次处理；</li>
<li>二进制的第 n 位就对应了二叉树的第 n 层；</li>
<li>如果该位是 0，进入左子树，是 1 则进入右子树（反过来也可以）；</li>
<li>全部位都处理完后，这个 NodeID 就对应了二叉树上的某个叶子。</li>
</ol>
<p>在这种二叉树结构下，对每个节点来说，离它越近的节点异或距离也是越近的。接着，可以按照离自己异或距离的远近，对整颗二叉树进行拆分。拆分规则是：从根节点开始，将不包括自己的那颗子树拆分出来，然后在包含自己的子树中，把不包括自己的下一层子树再拆分出来，以此类推，直到只剩下自己。以上图的 110 节点为例，从根节点开始，由于 110 节点在右子树，所以将左边的整颗子树拆分出来，即包含 000、001、010 这三个节点的这颗子树；接着，到第二层子树，将不包含 110 节点的左子树再拆分出来，即包含 100 和 101 这两个节点的子树；最后，再将 111 拆分出来。这样，就将 110 节点之外的整个二叉树拆分出了三颗子树。</p>
<p>完成子树拆分后，只要知道每个子树里面的其中一个节点，就可以进行递归路由实现整颗二叉树所有节点的遍历。但在实际场景下，由于节点是动态变化的，所以一般不会只知道每个子树的一个节点，而是需要知道多个节点。因此，Kad 中有一个叫 <strong>K-桶(K-bucket)</strong>的概念，每个桶会记录每颗子树里所知道的多个节点。其实，一个<strong>K-桶</strong>就是一张<strong>路由表</strong>，如果拆分出来有 m 颗子树，那对应节点就需要维护 m 个路由表。每个节点都会各自维护自己的 m 个 K-桶，每个 K-桶里记录的节点信息一般会包括 NodeID、IP、Endpoint、与 Target 节点（即维护该 K-桶的节点）的异或距离等信息。以太坊中，每个节点维护的 K-桶数量为 256 个，这 256 个 K-桶会根据与 Target 节点的异或距离进行排序，每个 K-桶保存的节点数量上限是 16。</p>
<p>在以太坊的 Kad 网络中，节点之间的通信是基于 UDP 的，另外设置了 4 个主要的通信协议：</p>
<ol>
<li><strong>Ping</strong>：用于探测一个节点是否在线</li>
<li><strong>Pong</strong>：用于响应 Ping 命令</li>
<li><strong>FindNode</strong>：用于查找与 Target 节点异或距离最近的其他节点</li>
<li><strong>Neighbours</strong>：用于响应 FindNode 命令，会返回一或多个节点</li>
</ol>
<p>通过以上 4 个命令，就可以实现新节点的加入、K-桶的刷新等机制。具体的实现流程就不细讲了，留给大伙自己去思考。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不同结构的 P2P 网络，会有不同的优点和缺点。比特币网络的结构明显容易理解，实现起来也相对容易得多，而以太坊网络引入了异或距离、二叉前缀树、K-桶等，结构上复杂不少，但在节点路由上的确会比比特币快很多。另外，不管是比特币还是以太坊，其实都只是一种或多种协议的集合，不同节点其实可以用不同的具体实现，比如，比特币就有用 C++ 实现的 Bitcoin Core，还有用 Java 实现的 BitcoinJ；以太坊也有用 Go 语言实现的 go-ethereum，也有用 C++ 实现的 go-ethereum，还有用 Java 实现的 Ethereum(J)。</p>
<h2 id="思考和实践"><a href="#思考和实践" class="headerlink" title="思考和实践"></a>思考和实践</h2><p>在以太坊的 Kad 网络中，新节点的加入和 K-桶的刷新流程是怎样的？比特币的新节点加入流程又是怎样的？哈希表有哪些实现方式？</p>
<hr>
<p>扫描以下二维码即可关注订阅号。</p>
<img src="/post/blockchain/20180313/qrcode_keegan.jpg">
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Keegan小钢</p>
              <div class="site-description motion-element" itemprop="description">分享钢哥人生路上的点点滴滴</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">25</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Keegan小钢</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.1.2</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/affix.js?v=7.1.2"></script>

  <script src="/js/schemes/pisces.js?v=7.1.2"></script>




  

  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
